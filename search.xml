<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>携程Apollo配置中心</title>
    <url>/2019/04/09/apollo-1/</url>
    <content><![CDATA[<h2 id="携程-Apollo-配置中心"><a href="#携程-Apollo-配置中心" class="headerlink" title="携程 Apollo 配置中心"></a>携程 Apollo 配置中心</h2><p>在Spring Boot 2.0 整合携程Apollo配置中心一文中，我们在本地快速部署试用了Apollo。本文将介绍如何按照分布式部署（采用Docker部署）的方式编译、打包、部署Apollo配置中心，从而可以在开发、测试、生产等环境分别部署运行。</p>
<h3 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h3><ul>
<li>docker 安装</li>
<li>docker-compose 安装</li>
<li>mysql 安装</li>
</ul>
<h3 id="Apollo工程"><a href="#Apollo工程" class="headerlink" title="Apollo工程"></a>Apollo工程</h3><p>| 工程名 | 优先级 | 说明 | 端口 | sql |<br>|————————-|<br>| apollo-configservice | 1 | 服务 | 8090 | <a href="(https://github.com/ctripcorp/apollo/blob/master/scripts/docker-quick-start/sql/apolloconfigdb.sql">apolloconfigdb.sql</a> |<br>| apollo-adminservice | 2 | 管理 | 8091 | <a href="(https://github.com/ctripcorp/apollo/blob/master/scripts/docker-quick-start/sql/apolloconfigdb.sql">apolloconfigdb.sql</a> |<br>| apollo-portal | 3 | 界面 | 8092 | <a href="https://github.com/ctripcorp/apollo/blob/master/scripts/docker-quick-start/sql/apolloportaldb.sql">apolloportaldb.sql</a> |</p>
<span id="more"></span>


<h3 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h3><p>Apollo目前支持以下环境：</p>
<ul>
<li>DEV 开发环境</li>
<li>FAT 测试环境，相当于alpha环境(功能测试)</li>
<li>UAT 集成环境，相当于beta环境（回归测试）</li>
<li>PRO 生产环境</li>
</ul>
<h3 id="网络策略（官网）"><a href="#网络策略（官网）" class="headerlink" title="网络策略（官网）"></a>网络策略（官网）</h3><p>分布式部署的时候，apollo-configservice和apollo-adminservice需要把自己的IP和端口注册到Meta Server（apollo-configservice本身）。<br>Apollo客户端和Portal会从Meta Server获取服务的地址（IP+端口），然后通过服务地址直接访问。<br>所以如果实际部署的机器有多块网卡（如docker），或者存在某些网卡的IP是Apollo客户端和Portal无法访问的（如网络安全限制），那么我们就需要在apollo-configservice和apollo-adminservice中做相关限制以避免Eureka将这些网卡的IP注册到Meta Server。<br>如下面这个例子就是对于apollo-configservice，把docker0和veth.* 的网卡在注册到Eureka时忽略掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">      name: apollo-configservice</span><br><span class="line">  profiles:</span><br><span class="line">    active: $&#123;apollo_profile&#125;</span><br><span class="line">  cloud:</span><br><span class="line">    inetutils:</span><br><span class="line">      ignoredInterfaces:</span><br><span class="line">        - docker0</span><br><span class="line">        - veth.*</span><br></pre></td></tr></table></figure>

<p>另外一种方式是直接指定要注册的IP，可以修改startup.sh，通过JVM System Property在运行时传入，如-Deureka.instance.ip-address=${指定的IP}，或者也可以修改apollo-adminservice或apollo-configservice 的bootstrap.yml文件，加入以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    ip-address: $&#123;指定的IP&#125;</span><br></pre></td></tr></table></figure>

<p>最后一种方式是直接指定要注册的IP+PORT，可以修改startup.sh，通过JVM System Property在运行时传入，如-Deureka.instance.homePageUrl=http://${指定的IP}:${指定的Port}，或者也可以修改apollo-adminservice或apollo-configservice 的bootstrap.yml文件，加入以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    homePageUrl: http://$&#123;指定的IP&#125;:$&#123;指定的Port&#125;</span><br><span class="line">    preferIpAddress: false</span><br></pre></td></tr></table></figure>

<p>如果Apollo部署在公有云上，本地开发环境无法连接，但又需要做开发测试的话，客户端可以升级到0.11.0版本及以上，然后通过-Dapollo.configService=<a href="http://config-service的公网IP:端口来跳过meta">http://config-service的公网IP:端口来跳过meta</a> service的服务发现</p>
<h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>部署步骤共四步：</p>
<ul>
<li>创建数据库，所有Apollo服务端都依赖于MySQL数据库，所以在启动时，应先配置数据才能启动服务；</li>
<li>获取安装包：通过源码构建</li>
<li>构建docker镜像：为apollo-configservice, apollo-adminservice, apollo-portal构建Docker镜像</li>
<li>部署Apollo服务端：构建镜像后通过docker compose就可以部署到公司的测试和生产环境了</li>
</ul>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>Apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB，官网把数据库、表的创建和样例数据都分别准备了sql文件，只需要导入数据库即可。</p>
<p>| 服务器 | 数据库 | 端口 | 环境 |<br>|—————————-|<br>| 172.24.2.65 | ApolloConfigDB | 3306 | dev |<br>| 172.24.2.65 | ApolloPortalDB | 3306 | dev |</p>
<h5 id="调整服务端配置"><a href="#调整服务端配置" class="headerlink" title="调整服务端配置"></a>调整服务端配置</h5><p>Apollo自身的一些配置是放在数据库里面的，所以需要针对实际情况做一些调整</p>
<ul>
<li><p>ApolloPortalDB</p>
<blockquote>
<ul>
<li>配置项统一存储在ServerConfig表中，也可以通过管理员工具 - 系统参数页面进行配置。</li>
<li>apollo.portal.envs - 可支持的环境列表，默认值是dev，如果portal需要管理多个环境的话，以逗号分隔即可（大小写不敏感）</li>
</ul>
</blockquote>
</li>
<li><p>ApolloConfigDB</p>
<blockquote>
<ul>
<li>配置项统一存储在ServerConfig表中，需要注意每个环境的ApolloConfigDB.ServerConfig都需要单独配置。</li>
<li>eureka.service.url - Eureka服务Url，不管是apollo-configservice还是apollo-adminservice都需要向eureka服务注册，所以需要配置eureka服务地址。 按照目前的实现，apollo-configservice本身就是一个eureka服务，所以只需要填入apollo-configservice的地址即可，如有多个，用逗号分隔（注意不要忘了/eureka/后缀）。这里我填写<a href="http://172.24.2.63:8090/eureka%E3%80%82">http://172.24.2.63:8090/eureka。</a></li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="获取安装包"><a href="#获取安装包" class="headerlink" title="获取安装包"></a>获取安装包</h4><p>到github上进行<a href="https://github.com/ctripcorp/apollo">源码下载</a>，如果github下载比较慢，可以去<a href="https://www.ipaddress.com/">ipaddress</a>把CDN信息搜索出来，添加到hosts中</p>
<ul>
<li>151.101.185.194 github.global.ssl.fastly.net </li>
<li>192.30.253.113  github.com</li>
<li>192.30.253.120    codeload.github.com</li>
</ul>
<h5 id="调整源码"><a href="#调整源码" class="headerlink" title="调整源码"></a>调整源码</h5><p>配置数据库连接信息<code>scripts/build.bat</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># config</span><br><span class="line">set apollo_config_db_url=<span class="string">&quot;jdbc:mysql://172.24.2.65:3306/ApolloConfigDB?characterEncoding=utf8&quot;</span></span><br><span class="line">set apollo_config_db_username=<span class="string">&quot;apollo-config&quot;</span></span><br><span class="line">set apollo_config_db_password=<span class="string">&quot;apollo-config&quot;</span></span><br><span class="line"></span><br><span class="line"># portal</span><br><span class="line">set apollo_portal_db_url=<span class="string">&quot;jdbc:mysql://172.24.2.65:3306/ApolloPortalDB?characterEncoding=utf8&quot;</span></span><br><span class="line">set apollo_portal_db_username=<span class="string">&quot;apollo-portal&quot;</span></span><br><span class="line">set apollo_portal_db_password=<span class="string">&quot;apollo-portal&quot;</span></span><br><span class="line"></span><br><span class="line"># dev_meta</span><br><span class="line">set dev_meta=<span class="string">&quot;http://172.24.2.63:8090&quot;</span></span><br><span class="line">set META_SERVERS_OPTS=-Ddev_meta=%dev_meta%</span><br></pre></td></tr></table></figure>
<h6 id="调整apollo-configservice工程"><a href="#调整apollo-configservice工程" class="headerlink" title="调整apollo-configservice工程"></a>调整apollo-configservice工程</h6><ul>
<li>将所有端口改为8090</li>
<li><code>bootstrap.yml</code>调整<code>defaultZone: http://$&#123;eureka.instance.hostname&#125;:8090/eureka/</code></li>
<li><code>startup.sh</code> 新增 <code>export JAVA_OPTS=&quot;-Deureka.instance.ip-address=172.24.2.63&quot;</code></li>
</ul>
<h6 id="调整apollo-configservice工程-1"><a href="#调整apollo-configservice工程-1" class="headerlink" title="调整apollo-configservice工程"></a>调整apollo-configservice工程</h6><ul>
<li>将所有端口改为8091</li>
<li><code>bootstrap.yml</code>调整 <code>defaultZone: http://$&#123;eureka.instance.hostname&#125;:8090/eureka/</code></li>
<li><code>startup.sh</code> 新增 <code>export JAVA_OPTS=&quot;-Deureka.instance.ip-address=172.24.2.63&quot;</code></li>
</ul>
<h6 id="调整apollo-portal工程"><a href="#调整apollo-portal工程" class="headerlink" title="调整apollo-portal工程"></a>调整apollo-portal工程</h6><ul>
<li>将所有端口改为8092</li>
<li><code>apollo-env.properties</code>调整<code>local.meta=http://172.24.2.63:8090</code></li>
</ul>
<h5 id="执行编译、打包"><a href="#执行编译、打包" class="headerlink" title="执行编译、打包"></a>执行编译、打包</h5><p>做完上述配置后，就可以执行编译和打包了。执行/scripts目录下build.sh脚本，该脚本会依次打包apollo-configservice, apollo-adminservice, apollo-portal。</p>
<h5 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h5><p>将target下的apollo-*-github.zip和Dockerfile上传到服务器，形成结构<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/apollo/1.png"></p>
<p>构建镜像</p>
<ul>
<li>docker build -t apollo-configservice:1.0.0 .</li>
<li>docker build -t apollo-adminservice:1.0.0 .</li>
<li>docker build -t apollo-portal:1.0.0 .<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/apollo/2.png"></li>
</ul>
<h5 id="部署Apollo服务端"><a href="#部署Apollo服务端" class="headerlink" title="部署Apollo服务端"></a>部署Apollo服务端</h5><p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/apollo/3.png"></p>
<p>在配置文件目录执行如下命令启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>spring cloud</tag>
        <tag>apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式之对象适配器</title>
    <url>/2018/02/22/design/pattern-1/</url>
    <content><![CDATA[<p>问题导入：比如有A型螺母和B型螺母，那么用户可以再A型螺母上直接使用按着A型螺母生产的A型螺丝，同样也可以在B型螺母上直接使用按着B型螺母标准生产的B型螺丝。但是由于A型螺母和B型螺母的标准不一样，用户在A型螺母上不能直接使用B型的螺丝，反之也一样。该如何达到这个目的呢？</p>
<p>使用适配器就可以解决这个问题：生产一种“A型螺母适配器”，这种A型螺母适配器的前端符合A型螺母标准要求，可以拧在A型螺母上，后端又焊接了一个B型螺母。这样用户就可以借助A型螺母适配器在A型螺母上使用B型的螺丝了。</p>
<p>适配器模式又称为包装器，是用来将一个类的接口转换成客户希望的另外一个接口。这可以使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式的关键是建立一个适配器，这个适配器实现了目标接口并且包含了被适配者的引用。</p>
<p><strong>适配器模式的三种角色：</strong></p>
<ul>
<li>目标：目标是一个接口，该接口是客户想要使用的接口。</li>
<li>被适配者：被适配者是一个已经存在的接口或抽象类，这个接口接口或者抽象类需要适配。</li>
<li>适配器：适配器是一个类，该类实现了目标接口并且包含有被适配者的引用，即适配器的职责是对适配者接口或抽象类与目标接口进行适配。</li>
</ul>
<p>以下通过一个简单的问题来描述适配器模式中所涉及的各个角色。</p>
<span id="more"></span>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>用户已经有一个两厢的插座，但是最近用户又有了一个新的三厢插座。用户现有一台洗衣机和一台电视机，洗衣机是三厢插头，而电视机是两厢插头。现在用户想用心的三厢插座来使用洗衣机和电视机，即用心的三厢插座为洗衣机和电视机接通电流。</p>
<p>针对以上问题，使用适配器模式设计若干个类。</p>
<ol>
<li><strong>目标</strong></li>
</ol>
<p> 本问题是使用三厢插座来为电视机和洗衣机接通电流，所以目标是三厢插座。把三厢插座设置为一个接口：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adatpe;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配目标：三相插座</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreeElectricOutlet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">connectElectricCurrent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>被适配者</strong></li>
</ol>
<p> 对于本问题，用户是想要用三厢插座为两厢插头的电视机接通电流，所以被适配者应该是两厢插座，也设置为一个接口：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adatpe;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被适配者：两相插座</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TwoElectricOutlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectElectricCurrent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>适配器</strong></li>
</ol>
<p> 该适配器实现了目标接口三厢插座ThreeElectricOutlet，同时又包含了两厢插座TwoElectricOutlet的引用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adatpe;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器：实现目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeElectricAdapter</span> <span class="keyword">implements</span> <span class="title">ThreeElectricOutlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//适配器包含被适配者的引用</span></span><br><span class="line">    <span class="keyword">private</span> TwoElectricOutlet outlet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeElectricAdapter</span><span class="params">(TwoElectricOutlet outlet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outlet = outlet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectElectricCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        outlet.connectElectricCurrent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下列应用程序中，Application.java使用了适配器模式中所涉及的类，应用程序负责用Wash类创建一个对象来模拟一台洗衣机，使用TV类创建一个对象来模拟一台电视机</p>
<p>使用ThreeElectricOutlet接口变量调用Wash对象的connectElectricCurrent()方法，并借助适配器调用TV对象的connectElectricCurrent()方法，即用三厢插座分别为洗衣机和电视机接通电流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adatpe; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreeElectricOutlet outlet; <span class="comment">//目标接口（三相插座）</span></span><br><span class="line">        Wash wash = <span class="keyword">new</span> Wash();     <span class="comment">//洗衣机</span></span><br><span class="line">        outlet = wash;              <span class="comment">//洗衣机插在三相插座上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用三相插座接通电流&quot;</span>);</span><br><span class="line">        outlet.connectElectricCurrent();    <span class="comment">//接通电流开始洗衣服</span></span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();           <span class="comment">//电视机</span></span><br><span class="line">        ThreeElectricAdapter adapter = <span class="keyword">new</span> ThreeElectricAdapter(tv); <span class="comment">//把电视插在适配器上面</span></span><br><span class="line">        outlet = adapter;           <span class="comment">//再把适配器插在三厢插座上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用三厢插座接通电流&quot;</span>);</span><br><span class="line">        outlet.connectElectricCurrent();  <span class="comment">//接通电流，开始播放电视节目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//洗衣机使用三相插座</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wash</span> <span class="keyword">implements</span> <span class="title">ThreeElectricOutlet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;黄河洗衣机&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wash</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectElectricCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;开始洗衣服了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视机使用两厢插座</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> <span class="keyword">implements</span> <span class="title">TwoElectricOutlet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;长江电视机&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TV</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectElectricCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;开始播放电视节目&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果为：</strong></p>
<p>使用三相插座接通电流<br>黄河洗衣机开始洗衣服了<br>使用三厢插座接通电流<br>长江电视机开始播放电视节目</p>
<h4 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h4><p>在适配器模式中，如果Adapter角色同时实现目标接口和被适配者接口，并包含目标接口和被适配接口的引用，那么该适配器就是一个双向适配器。使用双向适配器，用户既可以用新的接口又可以用已有的接口。在以上例子中，如果用户希望能有三厢插座来接通洗衣机和电视机的电流，有可以用两厢插座来接通洗衣机和电视机的电流，那么就必须使用一个双向适配器。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.adatpe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeAndTwoElectricAdapter</span> <span class="keyword">implements</span> <span class="title">ThreeElectricOutlet</span>,</span></span><br><span class="line"><span class="class">        <span class="title">TwoElectricOutlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreeElectricOutlet threeElectricOutlet;</span><br><span class="line">    <span class="keyword">private</span> TwoElectricOutlet twoElectricOutlet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeAndTwoElectricAdapter</span><span class="params">(ThreeElectricOutlet threeOutlet,TwoElectricOutlet twoOutlet)</span> </span>&#123;</span><br><span class="line">        threeElectricOutlet = threeOutlet;</span><br><span class="line">        twoElectricOutlet = twoOutlet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeAndTwoElectricAdapter</span><span class="params">(TwoElectricOutlet twoOutlet,ThreeElectricOutlet threeOutlet)</span></span>&#123;</span><br><span class="line">        threeElectricOutlet = threeOutlet;</span><br><span class="line">        twoElectricOutlet = twoOutlet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectElectricCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> ThreeElectricOutlet)&#123;</span><br><span class="line">            twoElectricOutlet.connectElectricCurrent();<span class="comment">//twoElectricOutlet是被适配的接口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> TwoElectricOutlet)&#123;</span><br><span class="line">            threeElectricOutlet.connectElectricCurrent(); <span class="comment">//threeElectricOutlet是被适配的接口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreeElectricOutlet threeOutlet;</span><br><span class="line">        TwoElectricOutlet twOutlet;</span><br><span class="line">        Wash wash = <span class="keyword">new</span> Wash();</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line">        ThreeAndTwoElectricAdapter adapter = <span class="keyword">new</span> ThreeAndTwoElectricAdapter(wash,tv);</span><br><span class="line">        threeOutlet = adapter;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用三厢插座接通电源&quot;</span>);</span><br><span class="line">        threeOutlet.connectElectricCurrent();</span><br><span class="line">        twOutlet = adapter;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用两厢插座接通电源&quot;</span>);</span><br><span class="line">        twOutlet.connectElectricCurrent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果为：</strong></p>
<p>使用三厢插座接通电源<br>长江电视机开始播放电视节目<br>黄河洗衣机开始洗衣服了<br>使用两厢插座接通电源<br>长江电视机开始播放电视节目<br>黄河洗衣机开始洗衣服了  </p>
<p>这样就实现了即可以用三厢插座又可以用两厢插座来为电视机和洗衣机接通电流了。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>目标和被适配者是完全解耦的关系。</li>
<li>适配器模式满足“开–闭原则”，当添加一个实现了Adapter接口的新类时，不必修改Adapter，Adapter就能对这个新类的实例进行适配。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用非root用户</title>
    <url>/2019/01/17/docker/1/</url>
    <content><![CDATA[<h4 id="Docker使用非root用户"><a href="#Docker使用非root用户" class="headerlink" title="Docker使用非root用户"></a>Docker使用非root用户</h4><p>通常我们使用Docker的时候都是使用的root，官方说法如下：</p>
<blockquote>
<p>The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can access it with sudo. For this reason, docker daemon always runs as the root user.<br>To avoid having to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.</p>
</blockquote>
<p>下面是使用非root用户操作的步骤</p>
<h5 id="创建docker组"><a href="#创建docker组" class="headerlink" title="创建docker组"></a>创建docker组</h5><blockquote>
<p>sudo groupadd docker</p>
</blockquote>
<h5 id="将当前用户加入docker组"><a href="#将当前用户加入docker组" class="headerlink" title="将当前用户加入docker组"></a>将当前用户加入docker组</h5><blockquote>
<p>sudo gpasswd -a ${USER} docker</p>
</blockquote>
<h5 id="重新启动docker服务（下面是CentOS7的命令）"><a href="#重新启动docker服务（下面是CentOS7的命令）" class="headerlink" title="重新启动docker服务（下面是CentOS7的命令）"></a>重新启动docker服务（下面是CentOS7的命令）</h5><blockquote>
<p>sudo systemctl restart docker</p>
</blockquote>
<h5 id="当前用户退出系统重新登陆"><a href="#当前用户退出系统重新登陆" class="headerlink" title="当前用户退出系统重新登陆"></a>当前用户退出系统重新登陆</h5><h5 id="运行docker命令"><a href="#运行docker命令" class="headerlink" title="运行docker命令"></a>运行docker命令</h5><blockquote>
<p>docker ps</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用国内镜像</title>
    <url>/2019/01/17/docker/2/</url>
    <content><![CDATA[<h4 id="为什么要为docker配置国内镜像"><a href="#为什么要为docker配置国内镜像" class="headerlink" title="为什么要为docker配置国内镜像"></a>为什么要为docker配置国内镜像</h4><p>在正常情况下，docker有一个默认连接的国外官方镜像，在国外的网友访问该官方镜像自然不成问题，但是国内毕竟不是国外，由于国情不同，中国的网络访问国外官方镜像网速一向很慢，而且往往还会遭遇断网的窘境，所以说我们要想正常使用docker的镜像，那么我们就不得不配置相应的国内镜像。</p>
<h4 id="可以使用的国内镜像有哪些"><a href="#可以使用的国内镜像有哪些" class="headerlink" title="可以使用的国内镜像有哪些"></a>可以使用的国内镜像有哪些</h4><p>Docker可以配置的国内镜像有很多可供选择，比如说：阿里云，网易蜂巢，DaoCloud，Docker中国区官方镜像等，这些都是可以提供给大家随意选择的不错的镜像仓库。</p>
<h4 id="配置Docker中国区官方镜像"><a href="#配置Docker中国区官方镜像" class="headerlink" title="配置Docker中国区官方镜像"></a>配置Docker中国区官方镜像</h4><h5 id="Docker中国区官方镜像简介"><a href="#Docker中国区官方镜像简介" class="headerlink" title="Docker中国区官方镜像简介"></a>Docker中国区官方镜像简介</h5><p>在国内，可以通过registry.docker-cn.com访问官方镜像库，目前该镜像库只包含流行的公有镜像，而私有镜像仍需要从美国镜像库中拉取。</p>
<h5 id="配置Docker中国区官方镜像-1"><a href="#配置Docker中国区官方镜像-1" class="headerlink" title="配置Docker中国区官方镜像"></a>配置Docker中国区官方镜像</h5><p>使用vi修改 /etc/docker/daemon.json 文件并添加上”registry-mirrors”: [“<a href="https://registry.docker-cn.com“]，如下：">https://registry.docker-cn.com“]，如下：</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@172 ~]$ sudo vi /etc/docker/daemon.json </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重启Docker"><a href="#重启Docker" class="headerlink" title="重启Docker"></a>重启Docker</h5><p>配置完之后执行下面的命令，以使docker的配置文件生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus搭建Docker私库</title>
    <url>/2019/04/23/docker/4/</url>
    <content><![CDATA[<h4 id="Nexus搭建Docker私库"><a href="#Nexus搭建Docker私库" class="headerlink" title="Nexus搭建Docker私库"></a>Nexus搭建Docker私库</h4><p>Nexus是用于Maven私服的，不过在官网上发现最新的Nexus 3.x还支持Docker仓库了，所以使用docker来搭建一下Nexus</p>
<blockquote>
<p>前面安装docker，docker-compose就不说了，直接来文件</p>
</blockquote>
<p>docker-compose.yml</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">nexus:</span><br><span class="line">  image: registry.cn-shenzhen.aliyuncs.com/zhouqi/nexus:<span class="number">3.0</span></span><br><span class="line">  restart: always</span><br><span class="line">  ports:</span><br><span class="line">    - <span class="number">8081</span>:<span class="number">8081</span></span><br><span class="line">    - <span class="number">5000</span>:<span class="number">5000</span></span><br><span class="line">  volumes:</span><br><span class="line">    - ~/docker/nexus/nexus-data:/nexus-data:Z</span><br><span class="line">  container_name:</span><br><span class="line">    nexus</span><br></pre></td></tr></table></figure>

<p>注意：端口5000，是为了让docker能登录的端口地址和nexus上要设置一样</p>
<span id="more"></span>

<ol>
<li><p>创建一个docker本地仓库<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/nexus/1.png?1"></p>
</li>
<li><p>在docker所在服务上进行设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Docker注册本地</span></span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;172.24.2.65:5000&quot;],</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> Docker pull 优先拉取本地</span></span><br><span class="line">  &quot;add-registry&quot;: [&quot;172.24.2.65:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li>重启docker并登录<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">docker login -u admin -p admin123 172.24.2.65:5000</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker集群(一)</title>
    <url>/2019/01/16/docker/jq-1/</url>
    <content><![CDATA[<h4 id="Docker使用Swarm搭建集群"><a href="#Docker使用Swarm搭建集群" class="headerlink" title="Docker使用Swarm搭建集群"></a>Docker使用Swarm搭建集群</h4><h5 id="selinux"><a href="#selinux" class="headerlink" title="selinux"></a>selinux</h5><p>查看selinux是否关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# /usr/sbin/sestatus -v</span><br><span class="line">SELinux status:                 disabled</span><br></pre></td></tr></table></figure>
<p>如果没有关闭，可以直接修改<code>/etc/selinux/config</code>中的<code>SELINUX</code>为<code>disabled</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ vi /etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash"> This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     disabled - No SELinux policy is loaded.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">SELINUX=enforcing</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUXTYPE= can take one of three two values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     minimum - Modification of targeted policy. Only selected processes are protected.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure>

<p><strong>注意：修改xelinux后需重启服务器</strong></p>
<p>打开docker.service中的2375端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~]$ sudo vi /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=http://docs.docker.com</span><br><span class="line">After=network.target rhel-push-plugin.socket registries.service</span><br><span class="line">Wants=docker-storage-setup.service</span><br><span class="line">Requires=docker-cleanup.timer</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">NotifyAccess=all</span><br><span class="line">EnvironmentFile=-/run/containers/registries.conf</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker-storage</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker-network</span><br><span class="line">Environment=GOTRACEBACK=crash</span><br><span class="line">Environment=DOCKER_HTTP_HOST_COMPAT=1</span><br><span class="line">Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin</span><br><span class="line">ExecStart=/usr/bin/dockerd-current \</span><br><span class="line">          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \</span><br><span class="line">          --default-runtime=docker-runc \</span><br><span class="line">          --exec-opt native.cgroupdriver=systemd \</span><br><span class="line">          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \</span><br><span class="line">          --init-path=/usr/libexec/docker/docker-init-current \</span><br><span class="line">          --seccomp-profile=/etc/docker/seccomp.json \</span><br><span class="line">          $OPTIONS \</span><br><span class="line">          $DOCKER_STORAGE_OPTIONS \</span><br><span class="line">          $DOCKER_NETWORK_OPTIONS \</span><br><span class="line">          $ADD_REGISTRY \</span><br><span class="line">          $BLOCK_REGISTRY \</span><br><span class="line">          $INSECURE_REGISTRY \</span><br><span class="line">          $REGISTRIES \</span><br><span class="line">          -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure>

<p>重启docker</p>
<span id="more"></span>

<h5 id="创建swarm管理节点"><a href="#创建swarm管理节点" class="headerlink" title="创建swarm管理节点"></a>创建swarm管理节点</h5><p>下面开始创建swarm。登录到centos7主机上，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker swarm init --advertise-addr 172.24.2.63</span><br><span class="line">Swarm initialized: current node (5levgh6t0qizmgwyn789dcuqx) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-5g3hxk4q7eg3atnuw45ijrqei21y2aopiqha31v04jwmnz5svt-bsudrrah0zgdx7qzjcm6xvfy3 \</span><br><span class="line">    172.24.2.63:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</span><br></pre></td></tr></table></figure>

<p>如果你不知道或者忘记了Swarm Manager节点的Token信息， 你可以在Manager节点上执行以下命令查看Worker节点连接所需要的Token信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker swarm join-token worker</span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-5g3hxk4q7eg3atnuw45ijrqei21y2aopiqha31v04jwmnz5svt-bsudrrah0zgdx7qzjcm6xvfy3 \</span><br><span class="line">    172.24.2.63:2377</span><br></pre></td></tr></table></figure>

<p>使用docker info和docker node ls查看集群中的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker node ls</span><br><span class="line">ID                           HOSTNAME               STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">5levgh6t0qizmgwyn789dcuqx *  localhost.localdomain  Ready   Active        Leader</span><br></pre></td></tr></table></figure>
<h5 id="把docker中的selinux去掉，然后重启docker"><a href="#把docker中的selinux去掉，然后重启docker" class="headerlink" title="把docker中的selinux去掉，然后重启docker"></a>把docker中的<code>selinux</code>去掉，然后重启docker</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/sysconfig/docker</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/sysconfig/docker</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Modify these options <span class="keyword">if</span> you want to change the way the docker daemon runs</span></span><br><span class="line"><span class="meta">#</span><span class="bash">OPTIONS=<span class="string">&#x27;--selinux-enabled --log-driver=journald --signature-verification=false&#x27;</span></span></span><br><span class="line">OPTIONS=&#x27;--log-driver=journald --signature-verification=false&#x27;</span><br><span class="line">if [ -z &quot;$&#123;DOCKER_CERT_PATH&#125;&quot; ]; then</span><br><span class="line">    DOCKER_CERT_PATH=/etc/docker</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>
<h5 id="将Worker节点加入swarm集群"><a href="#将Worker节点加入swarm集群" class="headerlink" title="将Worker节点加入swarm集群"></a>将Worker节点加入swarm集群</h5><p>登录到172.24.2.62主机上，执行前面创建swarm时输出的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker swarm join \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     --token SWMTKN-1-5g3hxk4q7eg3atnuw45ijrqei21y2aopiqha31v04jwmnz5svt-bsudrrah0zgdx7qzjcm6xvfy3 \</span></span><br><span class="line"><span class="bash">&gt;     172.24.2.63:2377</span></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>

<p>去<code>master</code>查看节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker node ls</span><br><span class="line">ID                           HOSTNAME               STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">5levgh6t0qizmgwyn789dcuqx *  localhost.localdomain  Ready   Active        Leader</span><br><span class="line">i8x5wur7ux01rewkffavfyw3x    localhost.localdomain  Ready   Active        </span><br></pre></td></tr></table></figure>
<p>这个时候能看见有2个节点了，但是hostname无法识别，所以我们可以使用命令来修改hostname的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname 172.24.2.62</span><br><span class="line">[root@localhost ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>我们在去<code>master</code>中查看节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker node ls</span><br><span class="line">ID                           HOSTNAME               STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">5levgh6t0qizmgwyn789dcuqx *  localhost.localdomain  Ready   Active        Leader</span><br><span class="line">i8x5wur7ux01rewkffavfyw3x    172.24.2.62            Ready   Active</span><br></pre></td></tr></table></figure>
<p>那么节点加入成功了。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker集群(二)</title>
    <url>/2019/01/16/docker/jq-2/</url>
    <content><![CDATA[<h4 id="Docker使用Portainer管理Swarm集群"><a href="#Docker使用Portainer管理Swarm集群" class="headerlink" title="Docker使用Portainer管理Swarm集群"></a>Docker使用Portainer管理Swarm集群</h4><p>在上一节中已经将了，如果将子节点加入到主节点中，本节将使用portainer来对swarm集群进行管理</p>
<h5 id="安装portainer管理工具"><a href="#安装portainer管理工具" class="headerlink" title="安装portainer管理工具"></a>安装portainer管理工具</h5><p>下载portainer工具，并启用docker服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker pull registry.cn-shenzhen.aliyuncs.com/zhouqi/portainer:1.20.0</span><br><span class="line"></span><br><span class="line">[neusoft@localhost ~/docker]$ docker service create \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --name portainer \</span></span><br><span class="line"><span class="bash">&gt; --publish 9000:9000 \</span></span><br><span class="line"><span class="bash">&gt; --constraint <span class="string">&#x27;node.role == manager&#x27;</span> \</span></span><br><span class="line"><span class="bash">&gt; --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span></span><br><span class="line"><span class="bash">&gt; registry.cn-shenzhen.aliyuncs.com/zhouqi/portainer:1.20.0 \</span></span><br><span class="line"><span class="bash">&gt; -H unix:///var/run/docker.sock</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>查看docker的服务，已经启用成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker service ls</span><br><span class="line">ID            NAME       MODE        REPLICAS  IMAGE</span><br><span class="line">y6ydozgujzjo  portainer  replicated  1/1       registry.cn-shenzhen.aliyuncs.com/zhouqi/portainer:1.20.0</span><br></pre></td></tr></table></figure>
<p>如果想停用该服务可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[neusoft@localhost ~/docker]$ docker service rm portainer</span><br><span class="line">portainer</span><br></pre></td></tr></table></figure>

<h5 id="查看portainer并进行集群设置"><a href="#查看portainer并进行集群设置" class="headerlink" title="查看portainer并进行集群设置"></a>查看portainer并进行集群设置</h5><p>访问<code>http://172.24.2.63:9000</code>地址，首先进行设置密码<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/8.png"></p>
<p>登录进去后，能查看到首页的信息<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/9.png"></p>
<p>添加一个子节点到portainer中<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/10.png"></p>
<p>现在可以查看添加进去的节点信息了<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/11.png"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库之ETL</title>
    <url>/2019/10/08/dwh/etl-1/</url>
    <content><![CDATA[<h3 id="数据仓库之ETL"><a href="#数据仓库之ETL" class="headerlink" title="数据仓库之ETL"></a>数据仓库之ETL</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ETL，Extraction-Transformation-Loading的缩写，中文名称为数据抽取、转换和加载。<br>一般随着业务的发展扩张，产线也越来越多，产生的数据也越来越多，这些数据的收集方式、原始数据格式、数据量、存储要求、使用场景等方面有很大的差异。作为数据中心，既要保证数据的准确性，存储的安全性，后续的扩展性，以及数据分析的时效性，这是一个很大的挑战。</p>
<h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul>
<li>ODS——操作性数据</li>
<li>DW——数据仓库</li>
<li>DM——数据集市</li>
</ul>
<span id="more"></span>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/dwh/etl-1.png"></p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/dwh/etl-2.png"></p>
<h4 id="数据抽取"><a href="#数据抽取" class="headerlink" title="数据抽取"></a>数据抽取</h4><p>数据抽取是指把ODS源数据抽取到DW中，然后处理成展示给相关人员查看的数据</p>
<p>源数据：</p>
<ul>
<li>用户访问日志</li>
<li>自定义事件日志、操作日志</li>
<li>业务日志</li>
<li>各服务产生的日志</li>
<li>系统日志：操作系统日志，CDN日志等</li>
<li>监控日志</li>
<li>其它日志</li>
</ul>
<p>抽取频次：</p>
<ul>
<li>如果没有特殊要求可以一天一次，但是需要避开拉去日志的高峰期</li>
<li>对于有实时性要求的日志，可以一小时一次，或者直接使用kafka等相关工具收集，需要考虑到系统能否承受</li>
</ul>
<p>抽取策略：</p>
<ul>
<li>由于数据量较大，一般都是采用增量抽取，但是对于一些特殊场景的数据，比如订单数据，由于订单的状态会发生变化，并且订单的量级是可预知和相对较少的，就需要采用全量拉取的策略</li>
<li>对于增量拉取的日志，如果是文件类型，可以在文件名称上追加日期，例如 server_log_2018082718.log，这样就可以满足按小时拉取的需求</li>
<li>对于源数据的保留，考虑到突发情况，服务器上的源数据至少要保证2天以上的时间</li>
</ul>
<h4 id="数据转换、清洗"><a href="#数据转换、清洗" class="headerlink" title="数据转换、清洗"></a>数据转换、清洗</h4><p>顾名思义，就是把不需要的和不符合规范的数据进行处理。数据清洗最好不要放在抽取的环节进行，考虑到有时可能会查原始数据。一般各公司都会有自己的规范，以下列出几点仅供参考</p>
<p>数据清洗主要包括以下几个方面：</p>
<ul>
<li><p>空值处理；根据业务需要，可以将空值替换为特定的值或者直接过滤掉；</p>
</li>
<li><p>验证数据正确性；主要是把不符合业务含义的数据做一处理，比如，把一个表示数量的字段中的字符串替换为0，把一个日期字段的非日期字符串过滤掉等等；</p>
</li>
<li><p>规范数据格式；比如，把所有的日期都格式化成yyyy-MM-dd HH:mm:ss的格式等；</p>
</li>
<li><p>数据转码；把一个源数据中用编码表示的字段，通过关联编码表，转换成代表其真实意义的值等等；</p>
</li>
<li><p>数据标准，统一；比如在源数据中表示男女的方式有很多种，在抽取的时候，直接根据模型中定义的值做转化，统一表示男女；</p>
</li>
<li><p>其他业务规则定义的数据清洗…</p>
</li>
</ul>
<h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><p>数据拉取，清洗完之后，就需要展示了。一般是把清洗好的数据加载到mysql中，然后在各系统中使用，或者使用Tableau直接给相关人员展示</p>
<h4 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h4><h5 id="Talend"><a href="#Talend" class="headerlink" title="Talend"></a>Talend</h5><p>易用性：有 GUI 图形界面但是以 Eclipse 的插件方式提供</p>
<p>技术支持：主要在美国</p>
<p>速度：需要手工调整，对特定数据源有优化知识</p>
<p>监控：有监控和日志工具</p>
<p>连接性：各种常用 数据库 ，文件， web，service</p>
<h5 id="Kettle"><a href="#Kettle" class="headerlink" title="Kettle"></a>Kettle</h5><p>易用性：有非常容易使用的 GUI，出现问题可以到社区咨询</p>
<p>技术支持：在美国，欧洲（比利时，德国，法国，英国），亚洲（ 中国 ，日本，韩国）都可以找到相关技术支持人员</p>
<p>速度：比 Talend 快，不过也需要手工调整，对 Oracle 和 PostGre 等数据源做了优化，同时也取决于转换任务的设计</p>
<p>监控：有监控和日志工具</p>
<p>连接性：非常广泛的数据库，文件，另外可以通过插件扩展</p>
<h5 id="Informatica"><a href="#Informatica" class="headerlink" title="Informatica"></a>Informatica</h5><p>易用性：有非常容易使用的 GUI，但是要专门的训练</p>
<p>技术支持：遍布全世界</p>
<p>速度：是最快的</p>
<p>监控：有非常详细的监控和日志工具</p>
<p>连接性：各种数据源</p>
]]></content>
      <categories>
        <category>dwh</category>
        <category>etl</category>
      </categories>
      <tags>
        <tag>data-warehouse</tag>
        <tag>etl</tag>
      </tags>
  </entry>
  <entry>
    <title>kettle</title>
    <url>/2019/10/08/dwh/kettle-1/</url>
    <content><![CDATA[<h3 id="Kettle"><a href="#Kettle" class="headerlink" title="Kettle"></a>Kettle</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Kettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定。中文名称叫水壶，该项目的主程序员MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。</p>
<h4 id="产品家族"><a href="#产品家族" class="headerlink" title="产品家族"></a>产品家族</h4><p>Kettle家族目前包括4个产品：Spoon、Pan、CHEF、Kitchen</p>
<ul>
<li><p><strong>SPOON</strong> 允许你通过图形界面来设计ETL转换过程（Transformation）。</p>
</li>
<li><p><strong>PAN</strong> 允许你批量运行由Spoon设计的ETL转换 (例如使用一个时间调度器)。Pan是一个后台执行的程序，没有图形界面。</p>
</li>
<li><p><strong>CHEF</strong> 允许你创建任务（Job）。 任务通过允许每个转换，任务，脚本等等，更有利于自动化更新数据仓库的复杂工作。任务通过允许每个转换，任务，脚本等等。任务将会被检查，看看是否正确地运行了。</p>
</li>
<li><p><strong>KITCHEN</strong> 允许你批量使用由Chef设计的任务 (例如使用一个时间调度器)。KITCHEN也是一个后台运行的程序。</p>
</li>
</ul>
<span id="more"></span>


<h4 id="手动编译和运行"><a href="#手动编译和运行" class="headerlink" title="手动编译和运行"></a>手动编译和运行</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><ul>
<li><p>JDK1.8+</p>
</li>
<li><p>下载源码：<a href="https://github.com/pentaho/pentaho-kettle">地址</a></p>
</li>
<li><p>版本号：pentaho-kettle-8.3.0.4-R</p>
</li>
<li><p>Maven version 3+</p>
</li>
<li><p><a href="https://raw.githubusercontent.com/pentaho/maven-parent-poms/master/maven-support-files/settings.xml">settings.xml</a>配置</p>
</li>
</ul>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>在源码的根目录中执行，会等一段时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install -DskipTests</span><br></pre></td></tr></table></figure>



<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>编译成功后，会在<code>assemblies/client/target</code>生成一个<code>pdi-ce-*.zip</code>压缩包文件，解压后双击运行<code>Spoon.bat</code>就启动了。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><p>问题：编译时文件过大，通过maven无法下载文件</p>
<p>解决：可以根据拉取的地址进行直接下载，并发动maven本地仓库位置</p>
</li>
</ul>
<ul>
<li><p>问题：Spoon.bat启动直接未响应</p>
<p>解决：修改该文件中的<code>-Xms</code>，<code>-Xmx</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if &quot;%PENTAHO_DI_JAVA_OPTIONS%&quot;==&quot;&quot; set PENTAHO_DI_JAVA_OPTIONS=&quot;-Xms512m&quot; &quot;-Xmx512m&quot; &quot;-XX:MaxPermSize=256m&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>dwh</category>
        <category>etl</category>
      </categories>
      <tags>
        <tag>etl</tag>
        <tag>dwh</tag>
        <tag>kettle</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP响应头和请求头信息对照表</title>
    <url>/2018/01/09/http/header/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。HTTP的头信息包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。</p>
<ul>
<li>通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。</li>
<li>请求头标：允许客户端传递关于自身的信息和希望的响应形式。</li>
<li>响应头标：服务器和于传递自身信息的响应。</li>
<li>实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。</li>
</ul>
<p>根据以上分类的HTTP请求头介绍可以参考此文，本工具根据请求和输出分为Request和Response两部分。</p>
<span id="more"></span>

<h3 id="HTTP-Request-Header"><a href="#HTTP-Request-Header" class="headerlink" title="HTTP Request Header"></a>HTTP Request Header</h3><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: keep-alive</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: admckid=1607301350151121825;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: <a href="mailto:&#x75;&#115;&#101;&#x72;&#x40;&#101;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#x75;&#115;&#101;&#x72;&#x40;&#101;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>c.xxx.com.cn</td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.iqiyi.com/a_19rrhahmi9.html">http://www.iqiyi.com/a_19rrhahmi9.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody></table>
<h3 id="HTTP-Responses-Header"><a href="#HTTP-Responses-Header" class="headerlink" title="HTTP Responses Header"></a>HTTP Responses Header</h3><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: max-age=31536000</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: application/octet-stream</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Mon, 15 Aug 2016 02:43:15 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Tue, 15 Aug 2017 02:42:58 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Fri, 29 Jul 2016 16:26:41 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.xxx.com/act/RdFHgKt4WyNYv27z.html">http://www.xxx.com/act/RdFHgKt4WyNYv27z.html</a></td>
</tr>
<tr>
<td>P3P</td>
<td>P3P提供的个人隐私保护策略</td>
<td>P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: <a href="http://www.xxx.com/">http://www.xxx.com/</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: nginx/7ed94dd662ffeb274371f6f0438ac6587fed8d84</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>MIME类型列表</title>
    <url>/2018/01/09/http/mime/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。<br>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。<br>官方的 MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的：</p>
<blockquote>
<p>RFC-822 Standard for ARPA Internet text messages<br>RFC-2045 MIME Part 1: Format of Internet Message Bodies<br>RFC-2046 MIME Part 2: Media Types<br>RFC-2047 MIME Part 3: Header Extensions for Non-ASCII Text<br>RFC-2048 MIME Part 4: Registration Procedures<br>RFC-2049 MIME Part 5: Conformance Criteria and Examples</p>
</blockquote>
<p>不同的应用程序支持不同的 MIME 类型。<br>下面的参考手册是由 Microsoft Internet Information Server version 5 所支持的 MIME 类型列表。</p>
<span id="more"></span>

<hr>
<p><strong>按照内容类型排列的 Mime 类型列表</strong></p>
<p>| 类型/子类型 | 扩展名 |<br>|——–|——–|                                  |<br>|application/envoy|    evy                             |<br>|application/fractals |    fif                         |<br>|application/futuresplash |    spl                     |<br>|application/hta |    hta                             |<br>|application/internet-property-stream |    acx         |<br>|application/mac-binhex40 |    hqx                     |<br>|application/msword |    doc                             |<br>|application/msword |    dot                             |<br>|application/octet-stream |    *                        |<br>|application/octet-stream |    bin                      |<br>|application/octet-stream |    class                    |<br>|application/octet-stream |    dms                      |<br>|application/octet-stream |    exe                      |<br>|application/octet-stream |    lha                      |<br>|application/octet-stream |    lzh                      |<br>|application/oda    | oda                              |<br>|application/olescript    | axs                          |<br>|application/pdf    | pdf                              |<br>|application/pics-rules    | prf                          |<br>|application/pkcs10    | p10                              |<br>|application/pkix-crl    | crl                          |<br>|application/postscript    | ai                           |<br>|application/postscript    | eps                          |<br>|application/postscript    | ps                           |<br>|application/rtf    | rtf                              |<br>|application/set-payment-initiation |    setpay           |<br>|application/set-registration-initiation |    setreg   |<br>|application/vnd.ms-excel    | xla                      |<br>|application/vnd.ms-excel    | xlc                      |<br>|application/vnd.ms-excel    | xlm                      |<br>|application/vnd.ms-excel    | xls                      |<br>|application/vnd.ms-excel    | xlt                      |<br>|application/vnd.ms-excel    | xlw                      |<br>|application/vnd.ms-outlook    | msg                      |<br>|application/vnd.ms-pkicertstore |    sst              |<br>|application/vnd.ms-pkiseccat |    cat                  |<br>|application/vnd.ms-pkistl |    stl                      |<br>|application/vnd.ms-powerpoint |    pot                  |<br>|application/vnd.ms-powerpoint |    pps                  |<br>|application/vnd.ms-powerpoint |    ppt                  |<br>|application/vnd.ms-project |    mpp                      |<br>|application/vnd.ms-works |    wcm                      |<br>|application/vnd.ms-works |    wdb                      |<br>|application/vnd.ms-works |    wks                      |<br>|application/vnd.ms-works |    wps                      |<br>|application/winhlp |    hlp                              |<br>|application/x-bcpio |    bcpio                        |<br>|application/x-cdf |    cdf                              |<br>|application/x-compress |    z                            |<br>|application/x-compressed |    tgz                      |<br>|application/x-cpio |    cpio                             |<br>|application/x-csh |    csh                              |<br>|application/x-director |    dcr                          |<br>|application/x-director |    dir                          |<br>|application/x-director |    dxr                          |<br>|application/x-dvi |    dvi                              |<br>|application/x-gtar |    gtar                             |<br>|application/x-gzip |    gz                               |<br>|application/x-hdf |    hdf                              |<br>|application/x-internet-signup |    ins                  |<br>|application/x-internet-signup |    isp                  |<br>|application/x-iphone |    iii                          |<br>|application/x-javascript |    js                       |<br>|application/x-latex |    latex                        |<br>|application/x-msaccess |    mdb                          |<br>|application/x-mscardfile |    crd                      |<br>|application/x-msclip |    clp                          |<br>|application/x-msdownload    | dll                      |<br>|application/x-msmediaview    | m13                      |<br>|application/x-msmediaview    | m14                      |<br>|application/x-msmediaview    | mvb                      |<br>|application/x-msmetafile    | wmf                      |<br>|application/x-msmoney    | mny                          |<br>|application/x-mspublisher    | pub                      |<br>|application/x-msschedule    | scd                      |<br>|application/x-msterminal    | trm                      |<br>|application/x-mswrite    | wri                          |<br>|application/x-netcdf    | cdf                          |<br>|application/x-netcdf    | nc                           |<br>|application/x-perfmon    | pma                          |<br>|application/x-perfmon    | pmc                          |<br>|application/x-perfmon    | pml                          |<br>|application/x-perfmon    | pmr                          |<br>|application/x-perfmon    | pmw                          |<br>|application/x-pkcs12    | p12                          |<br>|application/x-pkcs12    | pfx                          |<br>|application/x-pkcs7-certificates    | p7b              |<br>|application/x-pkcs7-certificates    | spc              |<br>|application/x-pkcs7-certreqresp    | p7r              |<br>|application/x-pkcs7-mime    | p7c                      |<br>|application/x-pkcs7-mime    | p7m                      |<br>|application/x-pkcs7-signature    | p7s                  |<br>|application/x-sh    | sh                               |<br>|application/x-shar    | shar                             |<br>|application/x-shockwave-flash |    swf                  |<br>|application/x-stuffit    | sit                          |<br>|application/x-sv4cpio    | sv4cpio                      |<br>|application/x-sv4crc    | sv4crc                       |<br>|application/x-tar    | tar                              |<br>|application/x-tcl    | tcl                              |<br>|application/x-tex    | tex                              |<br>|application/x-texinfo    | texi                         |<br>|application/x-texinfo    | texinfo                      |<br>|application/x-troff    | roff                         |<br>|application/x-troff    | t                            |<br>|application/x-troff    | tr                           |<br>|application/x-troff-man    | man                      |<br>|application/x-troff-me    | me                           |<br>|application/x-troff-ms    | ms                           |<br>|application/x-ustar    | ustar                        |<br>|application/x-wais-source    | src                      |<br>|application/x-x509-ca-cert    | cer                      |<br>|application/x-x509-ca-cert    | crt                      |<br>|application/x-x509-ca-cert    | der                      |<br>|application/ynd.ms-pkipko    | pko                      |<br>|application/zip    | zip                              |<br>|audio/basic    | au                                   |<br>|audio/basic |    snd                                  |<br>|audio/mid    | mid                                      |<br>|audio/mid    | rmi                                      |<br>|audio/mpeg    | mp3                                      |<br>|audio/x-aiff    | aif                                  |<br>|audio/x-aiff    | aifc                                 |<br>|audio/x-aiff    | aiff                                 |<br>|audio/x-mpegurl    | m3u                              |<br>|audio/x-pn-realaudio    | ra                           |<br>|audio/x-pn-realaudio    | ram                          |<br>|audio/x-wav    | wav                                  |<br>|image/bmp    | bmp                                      |<br>|image/cis-cod    | cod                                  |<br>|image/gif    | gif                                      |<br>|image/ief    | ief                                      |<br>|image/jpeg    | jpe                                      |<br>|image/jpeg    | jpeg                                     |<br>|image/jpeg    | jpg                                      |<br>|image/pipeg    | jfif                                 |<br>|image/svg+xml    | svg                                  |<br>|image/tiff    | tif                                      |<br>|image/tiff    | tiff                                     |<br>|image/x-cmu-raster    | ras                              |<br>|image/x-cmx    | cmx                                  |<br>|image/x-icon    | ico                                  |<br>|image/x-portable-anymap    | pnm                      |<br>|image/x-portable-bitmap    | pbm                      |<br>|image/x-portable-graymap    | pgm                      |<br>|image/x-portable-pixmap    | ppm                      |<br>|image/x-rgb    | rgb                                  |<br>|image/x-xbitmap    | xbm                              |<br>|image/x-xpixmap    | xpm                              |<br>|image/x-xwindowdump    | xwd                          |<br>|message/rfc822    | mht                                  |<br>|message/rfc822    | mhtml                                |<br>|message/rfc822    | nws                                  |<br>|text/css    | css                                      |<br>|text/h323    | 323                                      |<br>|text/html    | htm                                      |<br>|text/html    | html                                     |<br>|text/html    | stm                                      |<br>|text/iuls    | uls                                      |<br>|text/plain    | bas                                      |<br>|text/plain    | c                                        |<br>|text/plain    | h                                        |<br>|text/plain    | txt                                      |<br>|text/richtext    | rtx                                  |<br>|text/scriptlet    | sct                                  |<br>|text/tab-separated-values    | tsv                      |<br>|text/webviewhtml    | htt                              |<br>|text/x-component    | htc                              |<br>|text/x-setext    | etx                                  |<br>|text/x-vcard    | vcf                                  |<br>|video/mpeg    | mp2                                      |<br>|video/mpeg    | mpa                                      |<br>|video/mpeg    | mpe                                      |<br>|video/mpeg    | mpeg                                     |<br>|video/mpeg    | mpg                                      |<br>|video/mpeg    | mpv2                                     |<br>|video/quicktime    | mov                              |<br>|video/quicktime    | qt                               |<br>|video/x-la-asf    | lsf                                  |<br>|video/x-la-asf    | lsx                                  |<br>|video/x-ms-asf    | asf                                  |<br>|video/x-ms-asf    | asr                                  |<br>|video/x-ms-asf    | asx                                  |<br>|video/x-msvideo    | avi                              |<br>|video/x-sgi-movie    | movie                            |<br>|x-world/x-vrml    | flr                                  |<br>|x-world/x-vrml    | vrml                                 |<br>|x-world/x-vrml    | wrl                                  |<br>|x-world/x-vrml    | wrz                                  |<br>|x-world/x-vrml    | xaf                                  |<br>|x-world/x-vrml    | xof                                  |</p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea中整合Docker</title>
    <url>/2018/05/11/idea/1/</url>
    <content><![CDATA[<h4 id="IDEA在Windows上结合Docker"><a href="#IDEA在Windows上结合Docker" class="headerlink" title="IDEA在Windows上结合Docker"></a>IDEA在Windows上结合Docker</h4><p>在网上找了很多文章，却没有一篇文章明确说明如何整合，如何使用Idea+Docker，下面来一一说下整合。</p>
<h5 id="虚拟机（192-168-3-60）"><a href="#虚拟机（192-168-3-60）" class="headerlink" title="虚拟机（192.168.3.60）"></a>虚拟机（192.168.3.60）</h5><p>在虚拟机上安装Docker，我这里安装的是<code>Docker version 1.13.1, build 092cba3</code>。编辑Docker运行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/systemd/system/docker.service</span></span><br></pre></td></tr></table></figure>

<p>在ExecStart节点上增加<code>unix:///var/run/docker.sock -H 0.0.0.0:2375</code>，打开Docker外部访问，保存后重启Docker服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure>

<p>查看Docker中是否开启2375端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -anp|grep 2375</span></span><br></pre></td></tr></table></figure>

<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/1.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在虚拟机上的配置就完毕了。</p>
<span id="more"></span>

<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>在windows系统环境变量中新建DOCKER_HOST,值为tcp://192.168.3.60:2375</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/2.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>打开Idea，安装Docker插件</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/3.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>设置Docker远程访问地址为tcp://192.168.3.60:2375</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/4.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在Idea的运行中，运行Docker，就可查看到远程Docker的服务了</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/5.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>我们现在在POM.xml中增加插件并设置要编译后的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;imageName&gt;test/test:<span class="number">1.0</span>&lt;/imageName&gt;</span><br><span class="line">          &lt;baseImage&gt;java&lt;/baseImage&gt;</span><br><span class="line">          &lt;entryPoint&gt;[<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/$&#123;project.build.finalName&#125;.jar&quot;</span>]&lt;/entryPoint&gt;</span><br><span class="line">          &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">              &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">              &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">              &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">          &lt;/resources&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>执行<code>mvn clean package docker:build</code>，就可以进行远程编译了。编译后在会target下生成一个Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM java</span><br><span class="line">ADD /demo-1.0-SNAPSHOT.jar //</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/demo-1.0-SNAPSHOT.jar&quot;]</span><br></pre></td></tr></table></figure>

<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/6.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>查看远程编译后的包</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/7.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok介绍</title>
    <url>/2018/02/12/java/lombok/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法，那Java中有没有一种方式能够避免这种重复的劳动呢？答案是有，我们来看一下下面这张图，右面是一个简单的JavaBean，只定义了两个属性，在类上加上了@Data，从左面的结构图上可以看到，已经自动生成了上面提到的方法。 </p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/2.jpg"></p>
<h3 id="Lombok简介"><a href="#Lombok简介" class="headerlink" title="Lombok简介"></a>Lombok简介</h3><p>ombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p>
<ul>
<li>官方地址：<a href="https://projectlombok.org/">https://projectlombok.org/</a></li>
<li>github地址：<a href="https://projectlombok.org/">https://github.com/rzwitserloot/lombok</a></li>
</ul>
<span id="more"></span>

<h3 id="Lombok使用"><a href="#Lombok使用" class="headerlink" title="Lombok使用"></a>Lombok使用</h3><h4 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h4><ol>
<li><p><strong>@Getter / @Setter</strong></p>
<blockquote>
<p>可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。</p>
</blockquote>
</li>
<li><p><strong>@EqualsAndHashCode</strong></p>
<blockquote>
<p>默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p>
</blockquote>
</li>
<li><p><strong>@ToString</strong></p>
<blockquote>
<p>生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p>
</blockquote>
</li>
<li><p><strong>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</strong></p>
<blockquote>
<p>无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。</p>
</blockquote>
</li>
<li><p><strong>@Data</strong></p>
<blockquote>
<p>@ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。</p>
</blockquote>
</li>
</ol>
<h3 id="Lombok原理"><a href="#Lombok原理" class="headerlink" title="Lombok原理"></a>Lombok原理</h3><p>了解了简单的使用之后，现在应该比较好奇它是如何实现的。整个使用的过程中，只需要使用注解而已，不需要做其它额外的工作，那玄妙之处应该是在注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。</p>
<h3 id="运行时解析"><a href="#运行时解析" class="headerlink" title="运行时解析"></a>运行时解析</h3><p>运行时能够解析的注解，必须将@Retention设置为RUNTIME，这样可以通过反射拿到该注解。java.lang.reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，大部分开发者应该都很熟悉这种解析方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span>;</span><br><span class="line">&lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span></span>;</span><br><span class="line">Annotation[] getAnnotations();</span><br><span class="line">Annotation[] getDeclaredAnnotations();</span><br></pre></td></tr></table></figure>

<h3 id="编译时解析"><a href="#编译时解析" class="headerlink" title="编译时解析"></a>编译时解析</h3><p>编译时解析有两种机制，网上很多文章都把它俩搞混了，分别简单描述一下。</p>
<h3 id="Annotation-Processing-Tool"><a href="#Annotation-Processing-Tool" class="headerlink" title="Annotation Processing Tool"></a>Annotation Processing Tool</h3><p>apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：</p>
<ul>
<li>api都在com.sun.mirror非标准包下</li>
<li>没有集成到javac中，需要额外运行</li>
</ul>
<h3 id="Pluggable-Annotation-Processing-API"><a href="#Pluggable-Annotation-Processing-API" class="headerlink" title="Pluggable Annotation Processing API"></a>Pluggable Annotation Processing API</h3><p>JSR 269，自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，这时javac执行的过程如下： </p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/3.jpg"></p>
<h3 id="Lombok问题"><a href="#Lombok问题" class="headerlink" title="Lombok问题"></a>Lombok问题</h3><ul>
<li>无法支持多种参数构造器的重载</li>
<li>奇淫巧技，使用会有争议</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE PO VO BO DTO POJO DAO 整理总结</title>
    <url>/2018/02/12/java/pojo/</url>
    <content><![CDATA[<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/1.jpg"></p>
<ol>
<li><p><strong>DAO[data access object]数据访问对象</strong></p>
<blockquote>
</blockquote>
<p>DAO层对开发人员黑盒，由架构师设计封装。<br>在很长一段时间内，我将它理解为对数据库的访问，后面随着项目的积累。<br>发现自己的理解相对狭隘，对数据访问不仅仅指的是对数据库的访问。<br>假如A系统调用B系统的服务获取数据，这时候A系统对B系统访问数据对象的封装也可以称为DAO。</p>
</li>
<li><p><strong>DTO[data transfer object]数据传输对象</strong></p>
<blockquote>
</blockquote>
<p>假设数据表中存在20个字段，但是在页面展示列表的时候，这20个字段显然都不会用到。<br>我想对其中的5个字段进行展示，而且这5个字段展示的时候，也并不是数据库中他们原有的样子。<br>还需要进行计算、截取、业务代码转名称 …..等等<br>数据传输对象因此而被诞生，一是能提高数据传输的速度，二能隐藏后端表结构。</p>
</li>
<li><p><strong>PO[persistant object]持久层对象</strong></p>
<blockquote>
</blockquote>
<p>持久对象属性和数据库中的字段是一一对应的，数据库中的一条数据可以理解为一个持久对象。<br>因ORM框架的广泛使用而被引入到 JavaEE 项目设计当中。</p>
</li>
<li><p><strong>BO[bussiness object]业务对象</strong></p>
<blockquote>
</blockquote>
<p>业务对象顾名思义是在业务处理中抽象出来的对象，里面除了get/set 方法外，也可以有对字段进行业务处理的方法。<br>假设你要对一个班级进行业务处理，其中的学生、教师、甚至是桌椅板凳都是业务对象的组成部分。<br>当然其中的学生、教室….都可以是和数据库对应的PO。</p>
</li>
<li><p><strong>VO[value object]值对象</strong></p>
<blockquote>
</blockquote>
<p>值对象也可以称做页面对象，如果称做页面对象，那门它所代表的将是整个页面展示层的对象。<br>可以由需要的业务对象进行的换算转换而来。<br>如果称呼他为值对象的话，那门他可以理解为存放业务对象的一个地方。<br>假设锅碗瓢盆分别为对应的业务对象的话，那门整个碗柜就是一个值对象。</p>
</li>
<li><p><strong>POJO[plain ordiary java object] 简单java对象</strong></p>
<blockquote>
</blockquote>
<p>简单java对象应该是JavaEE世界里面最灵活的对象。<br>在简单系统中，如果从数据库到页面展示都是POJO的话，它可以是DTO。<br>如果从数据库中到业务处理中都是POJO的话，他也可以是BO。<br>同样如果从数据库到整个页面的展示的话，它同样可以是VO。</p>
</li>
</ol>
<p><strong>小结：</strong></p>
<blockquote>
</blockquote>
<p>各个数据对象之间的转换是相当灵活的，在项目中可以定义上述对象的全部和其中的几种类型，这取决与架构师和需求。<br>在大型项目中，架构师在项目初期的任务除了搭建起整个开发环境以外，定义在系统中流转的数据结构对象同样是重重之重。<br>这项工作需要许多项目的积累和长期对软件开发的思考，多实践，多思考，提供最合适的数据对象解决方法，方能展现架构师的魅力。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>pojo</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA动态代理机制</title>
    <url>/2018/05/04/java/proxy-1/</url>
    <content><![CDATA[<h4 id="JAVA动态代理机制以及使用场景"><a href="#JAVA动态代理机制以及使用场景" class="headerlink" title="JAVA动态代理机制以及使用场景"></a>JAVA动态代理机制以及使用场景</h4><h5 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h5><p>大道理上讲代理是一种软件设计模式，目的地希望能做到代码重用。具体上讲，代理这种设计模式是通过不直接访问被代理对象的方式，而访问被代理对象的方法。这个就好比 商户—-&gt;明星经纪人(代理)—-&gt;明星这种模式。我们可以不通过直接与明星对话的情况下，而通过明星经纪人(代理)与其产生间接对话。</p>
<h5 id="什么情况下使用代理？"><a href="#什么情况下使用代理？" class="headerlink" title="什么情况下使用代理？"></a>什么情况下使用代理？</h5><ul>
<li><p>设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑(sometimes the code is really like shit)，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。</p>
</li>
<li><p>我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</p>
</li>
<li><p>Spring的AOP机制就是采用动态代理的机制来实现切面编程。</p>
</li>
</ul>
<span id="more"></span>

<h5 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h5><p>我们根据加载被代理类的时机不同，将代理分为静态代理和动态代理。如果我们在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类这就是动态代理，比如RPC框架和Spring AOP机制。</p>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>我们先创建一个接口，遗憾的是java api代理机制求被代理类必须要实现某个接口，对于静态代理方式代理类也要实现和被代理类相同的接口；对于动态代理代理类则不需要显示的实现被代理类所实现的接口。</p>
<p>接口文件：IUser.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明星：User.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">IUser</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;我叫Fighting&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经纪人：UserProxyFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxyFactory</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> IUser user;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserProxyFactory</span><span class="params">(IUser user)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user = user;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;代理开始&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.user.sayHello();</span><br><span class="line">		System.out.println(<span class="string">&quot;代理结束&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>商户：app.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">app</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//user为被代理的对象，某些情况下 我们不希望修改已有的代码，我们采用代理来间接访问</span></span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		<span class="comment">//创建代理类对象</span></span><br><span class="line">		UserProxyFactory proxy = <span class="keyword">new</span> UserProxyFactory(user);</span><br><span class="line">		<span class="comment">//调用代理类对象的方法</span></span><br><span class="line">		System.out.println(proxy.getUserName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态代理看起来是比较简单的，没有什么问题只不过是在代理类中引入了被代理类的对象而已。<br>那么接下来我们看看动态代理。</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>IUser.java不变，User.java不变，UserProxyFactory.java发生改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">				target.getClass().getClassLoader(),</span><br><span class="line">				target.getClass().getInterfaces(),</span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;代理开始&quot;</span>);</span><br><span class="line">						Object retVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;代理结束&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> retVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最重要的一点，类似于Spring AOP切面，在<code>代理开始</code>,<code>代理结束</code>地方加上逻辑，就成了切面方式了！这也是为什么要用代理的一个重要原因之一！你不用修改任何已经编写好的代码，只要使用代理就可以灵活的加入任何东西，将来不喜欢了，不用也不会影响原来的代码。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7升级后无法重启或关机解决办法</title>
    <url>/2018/03/02/linux/centos-1/</url>
    <content><![CDATA[<p>由于CentOS7新发布的yum源升级包中systemd关机流程判断条件发生了变化，可能会导致centos7升级后，服务器重启时卡死。新发布的systemd进程的判断更加严格，如果某些进程不响应SIGTERM信号，可能会导致重启是挂死。该问题和业务进程对SIGTERM信号的处理有关。</p>
<p>执行yum update systemd（或者yum update）将systemd系列软件包更新到219-19.el7版本之后，reboot会出现如下卡机界面导致系统挂住，无法重启： </p>
<p><strong>现象：</strong></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/9.jpg"></p>
<span id="more"></span>

<p><strong>查询版本包：</strong></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/10.jpg"></p>
<p><strong>解决办法：</strong></p>
<ol>
<li>新建/etc/systemd/system/rc-local.service并写入：</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.d/rc.local Compatibility</span><br><span class="line">ConditionFileIsExecutable=/etc/rc.d/rc.local</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.d/rc.local start</span><br><span class="line">TimeoutSec=5</span><br><span class="line">RemainAfterExit=yes</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>备份/etc/systemd/system.conf<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /etc/systemd/system.conf /etc/systemd/system.conf_bak</span><br></pre></td></tr></table></figure></li>
<li>修改文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/#DefaultTimeoutStopSec=90s/DefaultTimeoutStopSec=30s/g&#x27; /etc/systemd/system.conf</span><br></pre></td></tr></table></figure></li>
<li>重新加载<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置全路径显示</title>
    <url>/2018/01/12/linux/config-setallpath/</url>
    <content><![CDATA[<p>在Linux中，编辑<code>vi /etc/bashrc</code>文件，搜索<code>PS1=&quot;[\u@\h \W]</code>，将大写的W改为w</p>
<blockquote>
</blockquote>
<p>修改前：<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/7.png"></p>
<blockquote>
</blockquote>
<p>修改后:<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/6.png"></p>
<blockquote>
</blockquote>
<p>效果显示:<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/8.png"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell /bin/bash^M: bad interpreter错误解决</title>
    <url>/2018/01/19/linux/error-bash-1/</url>
    <content><![CDATA[<blockquote>
<p>错误原因之一很有可能是你的脚本文件是DOS格式的, 即每一行的行尾以\r\n来标识, 其ASCII码分别是0x0D, 0x0A.可以有很多种办法看这个文件是DOS格式的还是UNIX格式的, 还是MAC格式的。</p>
</blockquote>
<ol>
<li><p><code>vi filename</code>然后用命令<code>:set ff?</code>可以看到dos或unix的字样. 如果的确是dos格式的, 那么你可以用set ff=unix把它强制为unix格式的, 然后存盘退出. 再运行一遍看.</p>
</li>
<li><p>用<code>joe filename</code>如果是DOS格式的, 那么行尾会有很多绿色的^M字样出现. 你也可以用上述办法把它转为UNIX格式的.</p>
</li>
<li><p>用<code>od -t x1 filename</code>如果你看到有0d 0a 这样的字符, 那么它是dos格式的, 如果只有0a而没有0d, 那么它是UNIX格式的, 同样可以用上述方法把它转为UNIX格式的. </p>
</li>
</ol>
<blockquote>
<p>转换不同平台的文本文件格式可以用</p>
</blockquote>
<ol>
<li>unix2dos或dos2unix这两个小程序来做. 很简单. 在djgpp中这两个程序的名字叫dtou和utod, u代表unix, d代表dos</li>
<li>也可以用sed 这样的工具来做:    </li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">&#x27;s/^M//&#x27;</span> filename &gt; tmp_filename</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv -f tmp_filename filename</span></span><br></pre></td></tr></table></figure>
<p>  来做说明:^M并不是按键shift + 6产生的^和字母M, 它是一个字符, 其ASCII是0x0D, 生成它的办法是先按CTRL+V, 然后再回车(或CTRL+M)</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobaxterm session stopped</title>
    <url>/2018/05/29/linux/mobaxterm-1/</url>
    <content><![CDATA[<h4 id="Mobaxterm-Session-Stopped"><a href="#Mobaxterm-Session-Stopped" class="headerlink" title="Mobaxterm Session Stopped"></a>Mobaxterm Session Stopped</h4><ol>
<li>点击当前的Session</li>
<li>编辑Edit Session</li>
<li>点击Telnet设置Remote host地址为你的SSH地址</li>
<li>在<code>Advanced Telnet settings</code>选项卡的<code>Telnet Client</code>中选择<code>Busybox telnet</code></li>
<li>尝试连接（肯定没效果）</li>
<li>切换到SSH，重新输入Remote host，点击连接，输入账号密码，ok连上了！</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>mobaxterm</tag>
      </tags>
  </entry>
  <entry>
    <title>DATE命令</title>
    <url>/2018/01/19/linux/shell-date/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；</span><br><span class="line">-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；</span><br><span class="line">-u：显示GMT；</span><br><span class="line">--help：在线帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="格式列表"><a href="#格式列表" class="headerlink" title="格式列表"></a>格式列表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">n : 下一行</span></span><br><span class="line"><span class="meta">%</span><span class="bash">t : 跳格</span></span><br><span class="line"><span class="meta">%</span><span class="bash">H : 小时(00..23)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">I : 小时(01..12)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">k : 小时(0..23)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">l : 小时(1..12)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">M : 分钟(00..59)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">p : 显示本地 AM 或 PM</span></span><br><span class="line"><span class="meta">%</span><span class="bash">r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数</span></span><br><span class="line"><span class="meta">%</span><span class="bash">S : 秒(00..61)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">T : 直接显示时间 (24 小时制)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">X : 相当于 %H:%M:%S</span></span><br><span class="line"><span class="meta">%</span><span class="bash">Z : 显示时区 %a : 星期几 (Sun..Sat)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">A : 星期几 (Sunday..Saturday)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">b : 月份 (Jan..Dec)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">B : 月份 (January..December)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">c : 直接显示日期与时间</span></span><br><span class="line"><span class="meta">%</span><span class="bash">d : 日 (01..31)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">D : 直接显示日期 (mm/dd/yy)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">h : 同 %b</span></span><br><span class="line"><span class="meta">%</span><span class="bash">j : 一年中的第几天 (001..366)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">m : 月份 (01..12)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">w : 一周中的第几天 (0..6)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">x : 直接显示日期 (mm/dd/yy)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">y : 年份的最后两位数字 (00.99)</span></span><br><span class="line"><span class="meta">%</span><span class="bash">Y : 完整年份 (0000..9999)</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -s //设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01 //设置具体时间，不会对日期做更改</span><br><span class="line">date -s “01:01:01 2008-05-23″ //这样可以设置全部时间</span><br><span class="line">date -s “01:01:01 20080523″ //这样可以设置全部时间</span><br><span class="line">date -s “2008-05-23 01:01:01″ //这样可以设置全部时间</span><br><span class="line">date -s “20080523 01:01:01″ //这样可以设置全部时间</span><br></pre></td></tr></table></figure>

<h4 id="时间加减"><a href="#时间加减" class="headerlink" title="时间加减"></a>时间加减</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date +%Y%m%d         //显示现在天年月日</span><br><span class="line">date +%Y%m%d --date=&quot;+1 day&quot;  //显示后一天的日期</span><br><span class="line">date +%Y%m%d --date=&quot;-1 day&quot;  //显示前一天的日期</span><br><span class="line">date +%Y%m%d --date=&quot;-1 month&quot;  //显示上一月的日期</span><br><span class="line">date +%Y%m%d --date=&quot;+1 month&quot;  //显示下一月的日期</span><br><span class="line">date +%Y%m%d --date=&quot;-1 year&quot;  //显示前一年的日期</span><br><span class="line">date +%Y%m%d --date=&quot;+1 year&quot;  //显示下一年的日期</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title>DF命令</title>
    <url>/2018/01/12/linux/shell-df/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a或--all：包含全部的文件系统；</span><br><span class="line">--block-size=&lt;区块大小&gt;：以指定的区块大小来显示区块数目；</span><br><span class="line">-h或--human-readable：以可读性较高的方式来显示信息；</span><br><span class="line">-H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；</span><br><span class="line">-i或--inodes：显示inode的信息；</span><br><span class="line">-k或--kilobytes：指定区块大小为1024字节；</span><br><span class="line">-l或--local：仅显示本地端的文件系统；</span><br><span class="line">-m或--megabytes：指定区块大小为1048576字节；</span><br><span class="line">--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；</span><br><span class="line">-P或--portability：使用POSIX的输出格式；</span><br><span class="line">--sync：在取得磁盘使用信息前，先执行sync指令；</span><br><span class="line">-t&lt;文件系统类型&gt;或--type=&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息；</span><br><span class="line">-T或--print-type：显示文件系统的类型；</span><br><span class="line">-x&lt;文件系统类型&gt;或--exclude-type=&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息；</span><br><span class="line">--help：显示帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="查看系统磁盘设备，默认是KB为单位"><a href="#查看系统磁盘设备，默认是KB为单位" class="headerlink" title="查看系统磁盘设备，默认是KB为单位"></a>查看系统磁盘设备，默认是KB为单位</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果显示：<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/4.png"></p>
</blockquote>
<blockquote>
</blockquote>
<p>字段说明：<br>Filesystem:        文件系统<br>1K-blocks:        1K-块<br>Used:            已用<br>Available:        可用<br>Use%:            已用%<br>Mounted on:        挂载点</p>
<h4 id="使用-h选项以KB以上的单位来显示，可读性高"><a href="#使用-h选项以KB以上的单位来显示，可读性高" class="headerlink" title="使用-h选项以KB以上的单位来显示，可读性高"></a>使用-h选项以KB以上的单位来显示，可读性高</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果显示：<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/5.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>df</tag>
      </tags>
  </entry>
  <entry>
    <title>GREP命令</title>
    <url>/2018/01/12/linux/shell-grep/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a 不要忽略二进制数据。</span><br><span class="line">-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span><br><span class="line">-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-c 计算符合范本样式的列数。</span><br><span class="line">-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span><br><span class="line">-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span><br><span class="line">-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</span><br><span class="line">-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span><br><span class="line">-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span><br><span class="line">-F 将范本样式视为固定字符串的列表。</span><br><span class="line">-G 将范本样式视为普通的表示法来使用。</span><br><span class="line">-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span><br><span class="line">-H 在显示符合范本样式的那一列之前，标示该列的文件名称。</span><br><span class="line">-i 忽略字符大小写的差别。</span><br><span class="line">-l 列出文件内容符合指定的范本样式的文件名称。</span><br><span class="line">-L 列出文件内容不符合指定的范本样式的文件名称。</span><br><span class="line">-n 在显示符合范本样式的那一列之前，标示出该列的编号。</span><br><span class="line">-q 不显示任何信息。</span><br><span class="line">-R/-r 此参数的效果和指定“-d recurse”参数相同。</span><br><span class="line">-s 不显示错误信息。</span><br><span class="line">-v 反转查找。</span><br><span class="line">-w 只显示全字符合的列。</span><br><span class="line">-x 只显示全列符合的列。</span><br><span class="line">-y 此参数效果跟“-i”相同。</span><br><span class="line">-o 只输出文件中匹配到的部分。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p>在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep match_pattern file_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;match_pattern&quot;</span> file_name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在多个文件中查找</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;match_pattern&quot;</span> file_1 file_2 file_3 ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出除之外的所有行 -v 选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -v <span class="string">&quot;match_pattern&quot;</span> file_name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>标记匹配颜色 –color=auto 选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;match_pattern&quot;</span> file_name --color=auto</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用正则表达式 -E 选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -E <span class="string">&quot;[1-9]+&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> egrep <span class="string">&quot;[1-9]+&quot;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只输出文件中匹配到的部分 -o 选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | grep -o -E <span class="string">&quot;[a-z]+\.&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a <span class="built_in">test</span> line. | egrep -o <span class="string">&quot;[a-z]+\.&quot;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计文件或者文本中包含匹配字符串的行数 -c 选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -c <span class="string">&quot;text&quot;</span> file_name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出包含匹配字符串的行数 -n 选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;text&quot;</span> -n file_name</span></span><br><span class="line">或</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file_name | grep <span class="string">&quot;text&quot;</span> -n</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">多个文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;text&quot;</span> -n file_1 file_2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印样式匹配所位于的字符或字节偏移</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> gun is not unix | grep -b -o <span class="string">&quot;not&quot;</span></span></span><br><span class="line">7:not</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索多个文件并查找匹配文本在哪些文件中</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -l <span class="string">&quot;text&quot;</span> file1 file2 file3...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在多级目录中对文本进行递归搜索</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;text&quot;</span> . -r -n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .表示当前目录。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>忽略匹配样式中的字符大小写</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | grep -i <span class="string">&quot;HELLO&quot;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项 -e 制动多个匹配样式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> this is a text line | grep -e <span class="string">&quot;is&quot;</span> -e <span class="string">&quot;line&quot;</span> -o</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> aaa bbb ccc ddd eee | grep -f patfile -o</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在grep搜索结果中包括或者排除指定文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">只在目录中所有的.php和.html文件中递归搜索字符<span class="string">&quot;main()&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;main()&quot;</span> . -r --include *.&#123;php,html&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在搜索结果中排除所有README文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;main()&quot;</span> . -r --exclude <span class="string">&quot;README&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;main()&quot;</span> . -r --exclude-from filelist</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用0值字节后缀的grep与xargs</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">测试文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;aaa&quot;</span> &gt; file1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;bbb&quot;</span> &gt; file2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;aaa&quot;</span> &gt; file3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;aaa&quot;</span> file* -lZ | xargs -0 rm</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>grep静默输出</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -q <span class="string">&quot;test&quot;</span> filename</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印出匹配文本之前或者之后的行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示匹配某个结果之后的3行，使用 -A 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">&quot;5&quot;</span> -A 3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示匹配某个结果之前的3行，使用 -B 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">&quot;5&quot;</span> -B 3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示匹配某个结果的前三行和后三行，使用 -C 选项：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 10 | grep <span class="string">&quot;5&quot;</span> -C 3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc\na\nb\nc&quot;</span> | grep a -A 1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>hwclock命令</title>
    <url>/2018/01/19/linux/shell-hwclock/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>hwclock命令是一个硬件时钟访问工具，它可以显示当前时间、设置硬件时钟的时间和设置硬件时钟为系统时间，也可设置系统时间为硬件时钟的时间。</p>
<p>在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--adjust：hwclock每次更改硬件时钟时，都会记录在/etc/adjtime文件中。使用--adjust参数，可使hwclock根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟；</span><br><span class="line">--debug：显示hwclock执行时详细的信息；</span><br><span class="line">--directisa：hwclock预设从/dev/rtc设备来存取硬件时钟。若无法存取时，可用此参数直接以I/O指令来存取硬件时钟；</span><br><span class="line">--hctosys：将系统时钟调整为与目前的硬件时钟一致；</span><br><span class="line">--set --date=&lt;日期与时间&gt;：设定硬件时钟；</span><br><span class="line">--show：显示硬件时钟的时间与日期；</span><br><span class="line">--systohc：将硬件时钟调整为与目前的系统时钟一致；</span><br><span class="line">--test：仅测试程序，而不会实际更改硬件时钟；</span><br><span class="line">--utc：若要使用格林威治时间，请加入此参数，hwclock会执行转换的工作；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="设置硬件时间要依赖于操作系统时间"><a href="#设置硬件时间要依赖于操作系统时间" class="headerlink" title="设置硬件时间要依赖于操作系统时间"></a>设置硬件时间要依赖于操作系统时间</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hwclock –systohc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hwclock --systohc –-utc</span></span><br></pre></td></tr></table></figure>

<h4 id="查看当前的硬件日期和时间"><a href="#查看当前的硬件日期和时间" class="headerlink" title="查看当前的硬件日期和时间"></a>查看当前的硬件日期和时间</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hwclock</span></span><br></pre></td></tr></table></figure>

<h4 id="设置硬件时间"><a href="#设置硬件时间" class="headerlink" title="设置硬件时间"></a>设置硬件时间</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hwclock -w</span></span><br></pre></td></tr></table></figure>

<h4 id="查看clock文件，确认是否设置了UTC"><a href="#查看clock文件，确认是否设置了UTC" class="headerlink" title="查看clock文件，确认是否设置了UTC"></a>查看clock文件，确认是否设置了UTC</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/default/rcS</span> </span><br><span class="line">UTC=yes</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>hwclock</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables之nat表应用——IP与端口的映射 </title>
    <url>/2018/01/22/linux/shell-iptables-1/</url>
    <content><![CDATA[<ol>
<li>** 需求 **</li>
</ol>
<p> 将192.168.3.195：80 映射到192.168.3.193：80，即访问192.168.3.195：80，得到192.168.3.193：80的结果，实现linux的路由。</p>
<ol start="2">
<li>** 实现 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">打开转发功能</span></span><br><span class="line">echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">         </span><br><span class="line">/sbin/iptables -F -t filter</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">清空iptables</span></span><br><span class="line">/sbin/iptables -F -t nat</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">去192.168.3.193的一条路</span></span><br><span class="line">/sbin/iptables -t nat -A PREROUTING -d 192.168.3.195 -p tcp --dport 80 -j DNAT --to-destination 192.168.3.193:80    </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">返回的时候的一条路，ip传输要有去有回才能连通</span> </span><br><span class="line">/sbin/iptables -t nat -A POSTROUTING  -s 192.168.3.0/24 -o eth0 -j SNAT --to 192.168.3.195  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">用2网段访问的时候的回路</span></span><br><span class="line">/sbin/iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -o eth0 -j SNAT --to 192.168.3.195  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">用0网段访问的时候的回路</span></span><br><span class="line">/sbin/iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to 192.168.3.195  </span><br></pre></td></tr></table></figure>

<p> 回路的那一条，或者只用下面这一句：<br> <code>iptables -t nat -A POSTROUTING -s 0.0.0.0/0 -o eth0 -j SNAT --to 192.168.3.195 </code>或者<br> <code>iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 192.168.3.195</code>把193上的80端口打开</p>
<ol start="3">
<li>** 测试 **<br>在192.168.3.195上访问 192.168.3.195：80看到 195的apache主页，因为在本机上访问，没有走PREROUTING这条链。在其他主机上访问192.168.3.195：80 返回193的apache主页，路线为PREROUTING–&gt;FORWARD–&gt;PSOTROUTING.</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>Iptables命令</title>
    <url>/2018/01/19/linux/shell-iptables/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>iptables命令是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-t&lt;表&gt;：指定要操纵的表；</span><br><span class="line">-A：向规则链中添加条目；</span><br><span class="line">-D：从规则链中删除条目；</span><br><span class="line">-i：向规则链中插入条目；</span><br><span class="line">-R：替换规则链中的条目；</span><br><span class="line">-L：显示规则链中已有的条目；</span><br><span class="line">-F：清楚规则链中已有的条目；</span><br><span class="line">-Z：清空规则链中的数据包计算器和字节计数器；</span><br><span class="line">-N：创建新的用户自定义规则链；</span><br><span class="line">-P：定义规则链中的默认目标；</span><br><span class="line">-h：显示帮助信息；</span><br><span class="line">-p：指定要匹配的数据包协议类型；</span><br><span class="line">-s：指定要匹配的数据包源ip地址；</span><br><span class="line">-j&lt;目标&gt;：指定要跳转的目标；</span><br><span class="line">-i&lt;网络接口&gt;：指定数据包进入本机的网络接口；</span><br><span class="line">-o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作</code></p>
<blockquote>
<p>表名包括 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">raw：高级功能，如：网址过滤。</span><br><span class="line">mangle：数据包修改（QOS），用于实现服务质量。</span><br><span class="line">net：地址转换，用于网关路由器。</span><br><span class="line">filter：包过滤，用于防火墙规则。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>规则链名包括 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INPUT链：处理输入数据包。</span><br><span class="line">OUTPUT链：处理输出数据包。</span><br><span class="line">PORWARD链：处理转发数据包。</span><br><span class="line">PREROUTING链：用于目标地址转换（DNAT）。</span><br><span class="line">POSTOUTING链：用于源地址转换（SNAT）。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动作包括</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">accept：接收数据包。</span><br><span class="line">DROP：丢弃数据包。</span><br><span class="line">REDIRECT：重定向、映射、透明代理。</span><br><span class="line">SNAT：源地址转换。</span><br><span class="line">DNAT：目标地址转换。</span><br><span class="line">MASQUERADE：IP伪装（NAT），用于ADSL。</span><br><span class="line">LOG：日志记录。</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="清除已有iptables规则"><a href="#清除已有iptables规则" class="headerlink" title="清除已有iptables规则"></a>清除已有iptables规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -F</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -X</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -Z</span></span><br></pre></td></tr></table></figure>

<h4 id="开放指定的端口"><a href="#开放指定的端口" class="headerlink" title="开放指定的端口"></a>开放指定的端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               <span class="comment">#允许本地回环接口(即运行本机访问本机)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    <span class="comment">#允许已建立的或相关连的通行</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A OUTPUT -j ACCEPT         <span class="comment">#允许所有本机向外的访问</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 22 -j ACCEPT    <span class="comment">#允许访问22端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 80 -j ACCEPT    <span class="comment">#允许访问80端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 21 -j ACCEPT    <span class="comment">#允许ftp服务的21端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 20 -j ACCEPT    <span class="comment">#允许FTP服务的20端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -j reject       <span class="comment">#禁止其他未允许的规则访问</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A FORWARD -j REJECT     <span class="comment">#禁止其他未允许的规则访问</span></span></span><br></pre></td></tr></table></figure>

<h4 id="屏蔽IP"><a href="#屏蔽IP" class="headerlink" title="屏蔽IP"></a>屏蔽IP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 123.45.6.7 -j DROP       <span class="comment">#屏蔽单个IP的命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 123.0.0.0/8 -j DROP      <span class="comment">#封整个段即从123.0.0.1到123.255.255.254的命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 124.45.0.0/16 -j DROP    <span class="comment">#封IP段即从123.45.0.1到123.45.255.254的命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 123.45.6.0/24 -j DROP    <span class="comment">#封IP段即从123.45.6.1到123.45.6.254的命令是</span></span></span><br></pre></td></tr></table></figure>

<h4 id="查看已添加的iptables规则"><a href="#查看已添加的iptables规则" class="headerlink" title="查看已添加的iptables规则"></a>查看已添加的iptables规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -L -n -v</span></span><br><span class="line">Chain INPUT (policy DROP 48106 packets, 2690K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"> 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"> 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line"> 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"> 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0  </span><br></pre></td></tr></table></figure>

<h4 id="删除已添加的iptables规则"><a href="#删除已添加的iptables规则" class="headerlink" title="删除已添加的iptables规则"></a>删除已添加的iptables规则</h4><blockquote>
<p>将所有iptables以序号标记显示，执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -L -n --line-numbers</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如要删除INPUT里序号为8的规则，执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -D INPUT 8</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>9个常用iptables配置实例</title>
    <url>/2018/01/22/linux/shell-iptabls-2/</url>
    <content><![CDATA[<p>iptables命令可用于配置Linux的包过滤规则，常用于实现防火墙、NAT。咋一看iptables的配置很复杂，掌握规律后，其实用iptables完成指定任务并不难，下面我们通过具体实例，学习iptables的详细用法。</p>
<span id="more"></span>

<ol>
<li>** 删除已有规则 **</li>
</ol>
<p> 在新设定iptables规则时，我们一般先确保旧规则被清除，用以下命令清除旧规则</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -F</span></span><br><span class="line">(or iptables --flush)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>** 设置chain策略 **</li>
</ol>
<p> 对于filter table，默认的chain策略为ACCEPT，我们可以通过以下命令修改chain的策略</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -P INPUT DROP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -P FORWARD DROP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -P OUTPUT DROP</span></span><br></pre></td></tr></table></figure>

<p> 以上命令配置将接收、转发和发出包均丢弃，施行比较严格的包管理。由于接收和发包均被设置为丢弃，当进一步配置其他规则的时候，需要注意针对INPUT和OUTPUT分别配置。当然，如果信任本机器往外发包，以上第三条规则可不必配置。</p>
<ol start="3">
<li>** 屏蔽指定ip **</li>
</ol>
<p> 有时候我们发现某个ip不停的往服务器发包，这时我们可以使用以下命令，将指定ip发来的包丢弃</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> BLOCK_THIS_IP=<span class="string">&quot;x.x.x.x&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -i eth0 -p tcp -s <span class="string">&quot;<span class="variable">$BLOCK_THIS_IP</span>&quot;</span> -j DROP</span></span><br></pre></td></tr></table></figure>

<p> 以上命令设置将由x.x.x.x ip发往eth0网口的tcp包丢弃</p>
<ol start="4">
<li>** 配置服务项 **</li>
</ol>
<p> 利用iptables，我们可以对日常用到的服务项进行安全管理，比如设定只能通过指定网段、由指定网口通过SSH连接本机</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0/24 --dport 22 -m state --state NEW,ESTABLESHED -j ACCEPT</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p> 若要支持由本机通过SSH连接其他机器，由于在本机端口建立连接，因而还需要设置以下规则</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0/24 --dport 22 -m state --state ESTABLESHED -j ACCEPT</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p> 类似的，对于HTTP/HTTPS(80/443)、pop3(110)、rsync(873)、MySQL(3306)等基于tcp连接的服务，也可以参照上述命令配置。</p>
<p> 对于基于udp的dns服务，使用以下命令开启端口服务</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>** 网口转发配置 **</li>
</ol>
<p> 对于用作防火墙或网关的服务器，一个网口连接到公网，其他网口的包转发到该网口实现内网向公网通信，假设eth0连接内网，eth1连接公网，配置规则如下</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>** 端口转发配置 **</li>
</ol>
<p> 对于端口，我们也可以运用iptables完成转发配置</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to  192.168.102.37:22</span></span><br></pre></td></tr></table></figure>

<p> 以上命令将422端口的包转发到22端口，因而通过422端口也可进行SSH连接，当然对于422端口，我们也需要像以上“4.配置服务项”一节一样，配置其支持连接建立的规则。</p>
<ol start="7">
<li>** DoS攻击防范 **</li>
</ol>
<p> 利用扩展模块limit，我们还可以配置iptables规则，实现DoS攻击防范</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 25/minute --limit-burst 100 -j ACCEPT</span></span><br></pre></td></tr></table></figure>
<p> –litmit 25/minute 指示每分钟限制最大连接数为25<br> –litmit-burst 100 指示当总连接数超过100时，启动 litmit/minute 限制</p>
<ol start="8">
<li>** 配置web流量均衡 **</li>
</ol>
<p> 我们可以将一台服务器作为前端服务器，利用iptables进行流量分发，配置方法如下</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A PREROUTING -i eth0 -p tcp --dport 80 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:80</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A PREROUTING -i eth0 -p tcp --dport 80 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.102:80</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A PREROUTING -i eth0 -p tcp --dport 80 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.103:80</span></span><br></pre></td></tr></table></figure>

<p> 以上配置规则用到nth扩展模块，将80端口的流量均衡到三台服务器</p>
<ol start="9">
<li>** 将丢弃包情况记入日志 **</li>
</ol>
<p> 使用LOG目标和syslog服务，我们可以记录某协议某端口下的收发包情况。拿记录丢包情况举例，可以通过以下方式实现。</p>
<p> 首先自定义一个chain</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -N LOGGING</span></span><br></pre></td></tr></table></figure>

<p> 其次将所有接收包导入LOGGING chain中</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -j LOGGING</span></span><br></pre></td></tr></table></figure>

<p> 然后设置日志前缀、日志级别</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A LOGGING -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 2/min -j LOG --log-prefix <span class="string">&quot;IPTables Packet Dropped: &quot;</span> --log-level 7</span></span><br></pre></td></tr></table></figure>

<p> 最后将包倒向DROP，将包丢弃</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A LOGGING -j DROP</span></span><br></pre></td></tr></table></figure>

<p> 另可以配置syslog.conf文件，指定iptables的日志输出</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>LN命令</title>
    <url>/2018/01/09/linux/shell-ln/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用<code>-s</code>选项。</p>
<p>注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-b: 删除，覆盖以前建立的链接</span><br><span class="line">-d: 允许超级用户制作目录的硬链接</span><br><span class="line">-f: 强制执行</span><br><span class="line">-i: 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n: 把符号链接视为一般目录</span><br><span class="line">-s: 软链接(符号链接)</span><br><span class="line">-v: 显示详细的处理过程</span><br><span class="line">-S: “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”</span><br><span class="line">-V: “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</span><br><span class="line">--help: 显示帮助信息</span><br><span class="line">--version: 显示版本信息</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="建立一个符号链接"><a href="#建立一个符号链接" class="headerlink" title="建立一个符号链接"></a>建立一个符号链接</h4><blockquote>
</blockquote>
<p>在目录<code>/usr/liu</code>下建立一个符号链接文件<code>abc</code>，使它指向目录<code>/usr/mengqc/mub1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s /usr/mengqc/mub1 /usr/liu/abc</span></span><br></pre></td></tr></table></figure>

<h4 id="删除一个符号链接"><a href="#删除一个符号链接" class="headerlink" title="删除一个符号链接"></a>删除一个符号链接</h4><blockquote>
<p>将目录<code>/usr/liu/</code>下的<code>abc</code>链接删除，注意不是<code>rm -rf symbolic_name/ </code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/liu/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf symbolic_name</span> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>ln</tag>
      </tags>
  </entry>
  <entry>
    <title>LS命令</title>
    <url>/2018/01/09/linux/shell-ls/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ls命令用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；</span><br><span class="line">-A：显示除影藏文件“.”和“..”以外的所有文件列表；</span><br><span class="line">-C：多列显示输出结果。这是默认选项；</span><br><span class="line">-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；</span><br><span class="line">-F：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；</span><br><span class="line">-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；</span><br><span class="line">-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；</span><br><span class="line">-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；</span><br><span class="line">-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；</span><br><span class="line">-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；</span><br><span class="line">--file-type：与“-F”选项的功能相同，但是不显示“*”；</span><br><span class="line">-k：以KB（千字节）为单位显示文件大小；</span><br><span class="line">-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；</span><br><span class="line">-m：用“,”号区隔每个文件和目录的名称；</span><br><span class="line">-n：以用户识别码和群组识别码替代其名称；</span><br><span class="line">-r：以文件名反序排列并输出目录内容列表；</span><br><span class="line">-s：显示文件和目录的大小，以区块为单位；</span><br><span class="line">-t：用文件和目录的更改时间排序；</span><br><span class="line">-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；</span><br><span class="line">-R：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">--full-time：列出完整的日期与时间；</span><br><span class="line">--color[=WHEN]：使用不同的颜色高亮显示不同类型的。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="使用长清单模式"><a href="#使用长清单模式" class="headerlink" title="使用长清单模式"></a>使用长清单模式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br></pre></td></tr></table></figure>

<h4 id="显示文件大小"><a href="#显示文件大小" class="headerlink" title="显示文件大小"></a>显示文件大小</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lh</span></span><br></pre></td></tr></table></figure>

<h4 id="排序文件大小"><a href="#排序文件大小" class="headerlink" title="排序文件大小"></a>排序文件大小</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lhS</span></span><br></pre></td></tr></table></figure>

<h4 id="测量大小"><a href="#测量大小" class="headerlink" title="测量大小"></a>测量大小</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l --block-size=M</span></span><br></pre></td></tr></table></figure>

<h4 id="显示隐藏文件"><a href="#显示隐藏文件" class="headerlink" title="显示隐藏文件"></a>显示隐藏文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -a</span></span><br></pre></td></tr></table></figure>

<h4 id="只列出目录条目"><a href="#只列出目录条目" class="headerlink" title="只列出目录条目"></a>只列出目录条目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -d */</span></span><br></pre></td></tr></table></figure>

<h4 id="不打印所有者信息"><a href="#不打印所有者信息" class="headerlink" title="不打印所有者信息"></a>不打印所有者信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -g</span></span><br></pre></td></tr></table></figure>

<h4 id="不打印组信息"><a href="#不打印组信息" class="headerlink" title="不打印组信息"></a>不打印组信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lG</span></span><br></pre></td></tr></table></figure>

<h4 id="打印UID和GID"><a href="#打印UID和GID" class="headerlink" title="打印UID和GID"></a>打印UID和GID</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -n</span></span><br></pre></td></tr></table></figure>

<h4 id="不带颜色打印"><a href="#不带颜色打印" class="headerlink" title="不带颜色打印"></a>不带颜色打印</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls --color=never</span></span><br></pre></td></tr></table></figure>

<h4 id="打印每个文件的索引号"><a href="#打印每个文件的索引号" class="headerlink" title="打印每个文件的索引号"></a>打印每个文件的索引号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -li</span></span><br></pre></td></tr></table></figure>

<h4 id="增加-斜线-标记目录"><a href="#增加-斜线-标记目录" class="headerlink" title="增加 / (斜线) 标记目录"></a>增加 / (斜线) 标记目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -p</span></span><br></pre></td></tr></table></figure>

<h4 id="排序时反转顺序"><a href="#排序时反转顺序" class="headerlink" title="排序时反转顺序"></a>排序时反转顺序</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -r</span></span><br></pre></td></tr></table></figure>

<h4 id="递归列出子目录"><a href="#递归列出子目录" class="headerlink" title="递归列出子目录"></a>递归列出子目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -R</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展名排序"><a href="#扩展名排序" class="headerlink" title="扩展名排序"></a>扩展名排序</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lX</span></span><br></pre></td></tr></table></figure>

<h4 id="通过修改时间列出"><a href="#通过修改时间列出" class="headerlink" title="通过修改时间列出"></a>通过修改时间列出</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt</span></span><br></pre></td></tr></table></figure>

<h4 id="列出你的主目录"><a href="#列出你的主目录" class="headerlink" title="列出你的主目录"></a>列出你的主目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls ~</span></span><br></pre></td></tr></table></figure>

<h4 id="打印ls命令版本"><a href="#打印ls命令版本" class="headerlink" title="打印ls命令版本"></a>打印ls命令版本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls --version</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title>PS命令</title>
    <url>/2018/01/07/linux/shell-ps/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程,而ps命令就是最基本同时也是非常强大的进程查看命令.使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到的.</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：显示现行终端机下的所有进程，包括其他用户的进程</span><br><span class="line">-A：所有的进程均显示出来，与 -e 具有同样的效用</span><br><span class="line">-u：以用户为主的进程状态</span><br><span class="line">-f：做一个更为完整的输出</span><br><span class="line">-e：等于“-A”</span><br><span class="line">x： 通常与 a 这个参数一起使用，可列出较完整信息</span><br><span class="line">l： 较长、较详细的将该 PID 的的信息列出</span><br><span class="line">j： 工作的格式 (jobs format)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="PS-L字段说明"><a href="#PS-L字段说明" class="headerlink" title="PS L字段说明"></a>PS L字段说明</h3><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/1.png"></p>
<blockquote>
</blockquote>
<p>F    ：代表这个程序的旗标 (flag)， 4 代表使用者为 super user<br>S    ：代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍<br>UID ：程序被该 UID 所拥有<br>PID ：就是这个程序的 ID ！<br>PPID ：则是其上级父程序的ID<br>C    ：CPU 使用的资源百分比<br>PRI ：这个是 Priority (优先执行序) 的缩写，详细后面介绍<br>NI    ：这个是 Nice 值，在下一小节我们会持续介绍<br>ADDR ：这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“<br>SZ    ：使用掉的内存大小<br>WCHAN ：目前这个程序是否正在运作当中，若为 - 表示正在运作<br>TTY ：登入者的终端机位置<br>TIME ：使用掉的 CPU 时间。<br>CMD ：所下达的指令为何</p>
<h3 id="PS-AUX字段说明"><a href="#PS-AUX字段说明" class="headerlink" title="PS AUX字段说明"></a>PS AUX字段说明</h3><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/2.png"></p>
<blockquote>
</blockquote>
<p>USER：该进程属于那个使用者账号的？<br>PID ：该进程的进程ID号。<br>%CPU：该进程使用掉的 CPU 资源百分比；<br>%MEM：该进程所占用的物理内存百分比；<br>VSZ ：该进程使用掉的虚拟内存量 (Kbytes)<br>RSS ：该进程占用的固定的内存量 (Kbytes)<br>TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。<br>START：该进程被触发启动的时间；<br>TIME ：该进程实际使用 CPU 运作的时间。<br>COMMAND：该程序的实际指令为什么？</p>
<blockquote>
<blockquote>
<p>STAT：该程序目前的状态，主要的状态有：<br>   R ：该程序目前正在运作，或者是可被运作；<br>   S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号(signal) 唤醒。<br>   T ：该程序目前正在侦测或者是停止了；<br>   Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</p>
</blockquote>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="显示所有进程信息"><a href="#显示所有进程信息" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -A</span></span><br></pre></td></tr></table></figure>

<h4 id="显示指定用户信息"><a href="#显示指定用户信息" class="headerlink" title="显示指定用户信息"></a>显示指定用户信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -u root</span></span><br></pre></td></tr></table></figure>
<h4 id="显示所有进程信息，连同命令行"><a href="#显示所有进程信息，连同命令行" class="headerlink" title="显示所有进程信息，连同命令行"></a>显示所有进程信息，连同命令行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef</span></span><br></pre></td></tr></table></figure>

<h4 id="ps-与grep-常用组合用法，查找特定进程"><a href="#ps-与grep-常用组合用法，查找特定进程" class="headerlink" title="ps 与grep 常用组合用法，查找特定进程"></a>ps 与grep 常用组合用法，查找特定进程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef|grep ssh</span></span><br></pre></td></tr></table></figure>

<h4 id="列出类似程序树的程序显示"><a href="#列出类似程序树的程序显示" class="headerlink" title="列出类似程序树的程序显示"></a>列出类似程序树的程序显示</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -axjf</span></span><br></pre></td></tr></table></figure>

<h4 id="找出与-cron-与-syslog-这两个服务有关的-PID-号码"><a href="#找出与-cron-与-syslog-这两个服务有关的-PID-号码" class="headerlink" title="找出与 cron 与 syslog 这两个服务有关的 PID 号码"></a>找出与 cron 与 syslog 这两个服务有关的 PID 号码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps aux | egrep <span class="string">&#x27;(cron|syslog)&#x27;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>Route命令</title>
    <url>/2018/01/12/linux/shell-route/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p>
<p>在Linux系统中设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的ip地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A：设置地址类型；</span><br><span class="line">-C：打印将Linux核心的路由缓存；</span><br><span class="line">-v：详细信息模式；</span><br><span class="line">-n：不执行DNS反向查找，直接显示数字形式的IP地址；</span><br><span class="line">-e：netstat格式显示路由表；</span><br><span class="line">-net：到一个网络的路由表；</span><br><span class="line">-host：到一个主机的路由表。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="显示当前路由"><a href="#显示当前路由" class="headerlink" title="显示当前路由"></a>显示当前路由</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route -n</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果显示：<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/linux/3.png"></p>
</blockquote>
<blockquote>
<p>字段说明：</p>
<blockquote>
</blockquote>
<p>U Up表示此路由当前为启动状态。<br>H Host，表示此网关为一主机。<br>G Gateway，表示此网关为一路由器。<br>R Reinstate Route，使用动态路由重新初始化的路由。<br>D Dynamically,此路由是动态性地写入。<br>M Modified，此路由是由路由守护程序或导向器动态修改。<br>! 表示此路由当前为关闭状态。</p>
</blockquote>
<h4 id="添加网关-设置网关"><a href="#添加网关-设置网关" class="headerlink" title="添加网关/设置网关"></a>添加网关/设置网关</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span></span><br></pre></td></tr></table></figure>

<h4 id="屏蔽一条路由"><a href="#屏蔽一条路由" class="headerlink" title="屏蔽一条路由"></a>屏蔽一条路由</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route add -net 224.0.0.0 netmask 240.0.0.0 reject</span></span><br></pre></td></tr></table></figure>

<h4 id="删除路由记录"><a href="#删除路由记录" class="headerlink" title="删除路由记录"></a>删除路由记录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route del -net 224.0.0.0 netmask 240.0.0.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> route del -net 224.0.0.0 netmask 240.0.0.0 reject</span></span><br></pre></td></tr></table></figure>

<h4 id="删除和添加设置默认网关"><a href="#删除和添加设置默认网关" class="headerlink" title="删除和添加设置默认网关"></a>删除和添加设置默认网关</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> route del default gw 192.168.120.240</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> route add default gw 192.168.120.240</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title>Tail命令</title>
    <url>/2018/01/12/linux/shell-tail/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。</p>
<p>注意：如果表示字节或行数的N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；</span><br><span class="line">-c&lt;N&gt;或——bytes=&lt;N&gt;：输出文件尾部的N（N为整数）个字节内容；</span><br><span class="line">-f&lt;name/descriptor&gt;或；--follow&lt;nameldescript&gt;：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；</span><br><span class="line">-F：与选项“-follow=name”和“--retry&quot;连用时功能相同；</span><br><span class="line">-n&lt;N&gt;或——line=&lt;N&gt;：输出文件的尾部N（N位数字）行内容。</span><br><span class="line">--pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；</span><br><span class="line">-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；</span><br><span class="line">-s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数；</span><br><span class="line">-v或——verbose：当有多个文件参数时，总是输出各个文件名；</span><br><span class="line">--help：显示指令的帮助信息；</span><br><span class="line">--version：显示指令的版本信息。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="显示文件末尾内容"><a href="#显示文件末尾内容" class="headerlink" title="显示文件末尾内容"></a>显示文件末尾内容</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -n 5 log2014.log</span></span><br></pre></td></tr></table></figure>

<h4 id="循环查看文件内容"><a href="#循环查看文件内容" class="headerlink" title="循环查看文件内容"></a>循环查看文件内容</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -f test.log</span></span><br></pre></td></tr></table></figure>

<h4 id="从第5行开始显示文件"><a href="#从第5行开始显示文件" class="headerlink" title="从第5行开始显示文件"></a>从第5行开始显示文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -n +5 log2014.log</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>tail</tag>
      </tags>
  </entry>
  <entry>
    <title>TC基于CBQ队列的流量管理范例</title>
    <url>/2018/01/22/linux/shell-tc-1/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>参考了TC的很多文档，自己也整理了一篇配置记录。在实际使用过程中效果还不错，在此分享给大家以备参考。<br>环境：局域网规模不是很大40多台机器。 NAT共享上网（内网：eth0 外网：eth2）<br>CBQ是通过硬件的闲置时间来计算队列，硬件不同，效果也不同，对于比较大的网络使用HTB比较好。以下限制上传和下载的方法可以写成脚本，通过mrtg发现流量的异常情况，然后通过ntop查处是谁在干坏事，最后用写好的tc脚本限制他的流量，避免影响其他人的网络使用。</p>
 <span id="more"></span>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="针对网络物理设备绑定一个CBQ队列"><a href="#针对网络物理设备绑定一个CBQ队列" class="headerlink" title="针对网络物理设备绑定一个CBQ队列"></a>针对网络物理设备绑定一个CBQ队列</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc qdisc add dev eth0 root handle 1: cbq bandwidth 10Mbit avpkt 1000 cell 8 mpu 64</span></span><br></pre></td></tr></table></figure>

<p> 将一个cbq队列绑定到网络物理设备eth0上，其编号为1:0；网络物理设备eth0的实际带宽为10Mbit，包的平均大小为1000字节；包间隔发送单元的大小为8字节，最小传输包大小为64字节。</p>
<h4 id="在该队列上建立分类"><a href="#在该队列上建立分类" class="headerlink" title="在该队列上建立分类"></a>在该队列上建立分类</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 10Mbit rate 10Mbit maxburst 20 allot 1514 prio 1 avpkt 1000 cell 8 weight 1Mbit</span></span><br></pre></td></tr></table></figure>

<p> 创建根分类1:1；分配带宽为10Mbit，优先级别为1。该队列的最大可用带宽为10Mbit，实际分配的带宽为10Mbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为1，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为1Mbit。</p>
<blockquote>
<p>** 创建子分类 **</p>
</blockquote>
<ul>
<li>创建分类1:2，其父分类为1:1，分配带宽为64Kbit，优先级别为8。该队列的最大可用带宽为10Mbit，实际分配的带宽为64Kbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为8，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，且不可借用未使用带宽。<br><code>$ tc class add dev eth0 parent 1:1 classid 1:2 cbq bandwidth 10Mbit rate 64Kbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 100Kbit bounded</code></li>
<li>创建分类1:3，其父分类为1:1，分配带宽为64Kbit，优先级别为9。该队列的最大可用带宽为10Mbit，实际分配的带宽为64Kbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为9，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，且不可借用未使用带宽。<br><code>$ tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 10Mbit rate 64Kbit maxburst 20 allot 1514 prio 9 avpkt 1000 cell 8 weight 100Kbit bounded</code></li>
</ul>
<h4 id="在子分类地下创建队列，使用sfq随机公平队列"><a href="#在子分类地下创建队列，使用sfq随机公平队列" class="headerlink" title="在子分类地下创建队列，使用sfq随机公平队列"></a>在子分类地下创建队列，使用sfq随机公平队列</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc qdisc add dev eth0 parent 1:2 sfq quantum 1514b perturb 15</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tc qdisc add dev eth0 parent 1:3 sfq quantum 1514b perturb 15</span></span><br></pre></td></tr></table></figure>
<p> 在分类底下，创建队列，使用sfq随即公平队列</p>
<h4 id="为每一分类建立一个基于路由的过滤"><a href="#为每一分类建立一个基于路由的过滤" class="headerlink" title="为每一分类建立一个基于路由的过滤"></a>为每一分类建立一个基于路由的过滤</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.116 flowid 1:2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.66 flowid 1:3</span></span><br></pre></td></tr></table></figure>
<p> 限制各ip地址的下载带宽，使用u32过滤器，对目的地址进行分类，对应已经创建的队列需要添加新的被限制ip的下载带宽，需要先要创建新的分类(比如1:4),然后根据新的分类创建新的sfq队列，最后使用u32过滤器对目的地址进行带宽限制。需要对几个ip限制下载带宽，就需要创建几个分类、队列、过滤器</p>
<h4 id="限制上传"><a href="#限制上传" class="headerlink" title="限制上传"></a>限制上传</h4><p> 将一个cbq队列绑定到网络物理设备eth2上，其编号为2:0；网络物理设备eth2的实际带宽为2Mbit，包的平均大小为1000字节；包间隔发送单元的大小为8字节，最小传输包大小为64字节。<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc qdisc add dev eth2 root handle 2: cbq bandwidth 2Mbit avpkt 1000 cell 8 mpu 64</span></span><br></pre></td></tr></table></figure><br> 创建根分类2:1；分配带宽为2Mbit，优先级别为1。该队列的最大可用带宽为2Mbit，实际分配的带宽2Mbit，<br> 可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为1，包的平均<br> 大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为200Kbit。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc class add dev eth2 parent 2:0 classid 2:1 cbq bandwidth 2Mbit rate 2Mbit maxburst 20 allot 1514 prio 1 avpkt 1000 cell 8 weight 200Kbit</span></span><br></pre></td></tr></table></figure>
<p> 创建分类2:2，其父分类为2:1，分配带宽为64Kbit，优先级别为8。该队列的最大可用带宽为2Mbit，实际分配的带宽为64Kbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为8，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，且不可借用未使用带宽。<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc class add dev eth2 parent 2:1 classid 2:2 cbq bandwidth 2Mbit rate 64Kbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 200Kbit bounded</span></span><br></pre></td></tr></table></figure></p>
<p> 在分类底下，创建队列，使用sfq随即公平队列<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc qdisc add dev eth2 parent 2:2 sfq quantum 1514b perturb 15</span></span><br></pre></td></tr></table></figure></p>
<p> 应用路由分类器到cbq队列的根，过滤协议为ip，优先级为100<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc filter add dev eth2 parent 2:0 protocol ip prio 1 handle 2 fw classid 2:2</span></span><br></pre></td></tr></table></figure></p>
<p> 给数据包打标签,可以通过RETURN方法避免遍历所有的规则，加快处理速度<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables –t mangle –A PREROUTING –i eth0 –s 192.111.1.xxx –j MARK --set-mark 2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables –t mangle –A PREROUTING –i eth0 –s 192.111.1.xxx –j RETURN</span> </span><br></pre></td></tr></table></figure><br> nat模式<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -t nat -A POSTROUTING -s 192.111.1.0/24 -o eth2 -j SNAT --to 外网IP</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要添加新的被限制ip的上传带宽，需要先要创建新的分类(比如2:3),然后根据新的分类创建新的sfq队列，最后使用路由过滤器，过滤协议为ip，给原地址是需要限制的ip地址来的数据包打标记。<br>需要对几个ip限制下载带宽，就需要创建几个分类、队列、路由过滤器、iptable的mangle表的PREROUTING链</p>
</blockquote>
<p> 另外还有其他的过滤器比如<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 2 flowid 1:2 ip route add 192.111.1.24 dev eth0 via 192.111.1.4 realm 2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p> 主要包括对队列、分类、过滤器和路由的增添、修改和删除。 增添动作一般依照”队列-&gt;分类-&gt;过滤器-&gt;路由”的顺序进行；修改动作则没有什么要求；删除则依照”路由-&gt;过滤器-&gt;分类-&gt;队列”的顺序进行。</p>
<p> 简单显示指定设备的队列状况<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc qdisc ls dev eth0</span></span><br></pre></td></tr></table></figure></p>
<p> 详细显示指定设备的队列状况<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc –s qdisc ls dev eth0</span></span><br></pre></td></tr></table></figure></p>
<p> 简单显示指定设备的分类状况<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc class ls dev eth0</span></span><br></pre></td></tr></table></figure></p>
<p> 详细显示指定设备的分类状况<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc –s class ls dev eth0</span></span><br></pre></td></tr></table></figure></p>
<p> 显示过滤器的状况<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc –s filter ls dev eth0</span></span><br></pre></td></tr></table></figure></p>
<p> 队列的维护<br> 一般对于一台流量控制器来说，出厂时针对每个以太网卡均已配置好一个队列了，通常情况下对队列无需进行增添、修改和删除动作了。</p>
<h4 id="分类的维护"><a href="#分类的维护" class="headerlink" title="分类的维护"></a>分类的维护</h4><p> 增添动作通过<code>tc class add</code>命令实现。</p>
<p> 修改动作通过<code>tc class change</code>命令实现，如下所示：<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc class change dev eth0 parent 1:1 classid 1:2 cbq bandwidth 10Mbit rate 64Kbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 100Kbit bounded</span></span><br></pre></td></tr></table></figure><br> 对于bounded命令应慎用，一旦添加后就进行修改，只可通过删除后再添加来实现。</p>
<h4 id="过滤器的维护"><a href="#过滤器的维护" class="headerlink" title="过滤器的维护"></a>过滤器的维护</h4><p> 增添动作通过<code>tc filter add</code>命令实现。</p>
<p> 修改动作通过<code>tc filter change</code>命令实现，如下所示：<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc filter change dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.116 flowid 1:2</span></span><br></pre></td></tr></table></figure></p>
<p> 删除动作通过<code>tc filter del</code>命令实现，如下所示：<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tc filter del dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.116 flowid 1:</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>tc</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcpdump命令</title>
    <url>/2018/01/19/linux/shell-tcpdump/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><blockquote>
<p>使用格式</p>
</blockquote>
<p> <code> $ tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -wfile ] [ expression ]   </code></p>
<blockquote>
<p>抓包选项  </p>
</blockquote>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定&quot;-c 10&quot;将获取10个包，但可能已经 处理了100个包，</span><br><span class="line">只不过只有10个包是满足条件的包。 </span><br><span class="line">-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置</span><br><span class="line">好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)，一旦找到第一个符合条件的接</span><br><span class="line">口，搜寻马上结束。可以使用&#x27;any&#x27;关键字表示所有网络接口。  </span><br><span class="line">-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。</span><br><span class="line">-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。</span><br><span class="line">-N：不打印出host的域名部分。例如tcpdump将会打印&#x27;nic&#x27;而不是&#x27;nic.ddn.mil&#x27;。</span><br><span class="line">-P：指定要抓取的包是流入还是流出的包。可以给定的值为&quot;in&quot;、&quot;out&quot;和&quot;inout&quot;，默认为&quot;inout&quot;。</span><br><span class="line">-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大</span><br><span class="line">时，长度设置不够可能会产生包截断，若出现包截断，输出行中会出现&quot;[|proto]&quot;的标志(proto实际会显示</span><br><span class="line">为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量，从而会导致</span><br><span class="line">数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出选项</p>
</blockquote>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。</span><br><span class="line">-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。</span><br><span class="line">-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。</span><br><span class="line">-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。</span><br><span class="line">-v：当分析和打印的时候，产生详细的输出。</span><br><span class="line">-vv：产生比-v更详细的输出。</span><br><span class="line">-vvv：产生比-vv更详细的输出。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他功能性选项</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于&quot;-i&quot;后。</span><br><span class="line">-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。</span><br><span class="line">-w：将抓包数据输出到文件中而不是标准输出。可以同时配合&quot;-G time&quot;选项使得输出文件每time秒就自动切</span><br><span class="line">换到另一个文件。可通过&quot;-r&quot;选项载入这些文件以进行分析和打印。</span><br><span class="line">-r：从给定的数据包文件中读取数据。使用&quot;-&quot;表示从标准输入中读取。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li>** 监视指定网络接口的数据包 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth1</span></span><br></pre></td></tr></table></figure>
<p> 如果不指定网卡，默认tcpdump只会监视第一个网络接口，如eth0。</p>
<ol start="2">
<li>** 监视指定主机的数据包，例如所有进入或离开longshuai的数据包 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump host longshuai</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>** 打印helios&lt;–&gt;hot或helios&lt;–&gt;ace之间通信的数据包 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump host helios and \( hot or ace \)</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>** 打印ace与任何其他主机之间通信的IP数据包,但不包括与helios之间的数据包 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip host ace and not helios</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>** 截获主机hostname发送的所有数据 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump src host hostname</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>** 监视所有发送到主机hostname的数据包 **<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump dst host hostname</span></span><br></pre></td></tr></table></figure></li>
<li>** 监视指定主机和端口的数据包 **<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump tcp port 22 and host hostname</span></span><br></pre></td></tr></table></figure></li>
<li>** 对本机的udp 123端口进行监视(123为ntp的服务端口) **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump udp port 123</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>** 监视指定网络的数据包，如本机与192.168网段通信的数据包，”-c 10”表示只抓取10个包 **<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -c 10 net 192.168</span></span><br></pre></td></tr></table></figure></li>
<li>** 打印所有通过网关snup的ftp数据包(注意,表达式被单引号括起来了,这可以防止shell对其中的括号进行错误解析) **<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;gateway snup and (port ftp or ftp-data)&#x27;</span></span></span><br></pre></td></tr></table></figure></li>
<li>** 抓取ping包 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -c 5 -nn -i eth0 icmp</span> </span><br></pre></td></tr></table></figure>

<p> 如果明确要抓取主机为192.168.100.70对本机的ping，则使用and操作符。  </p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -c 5 -nn -i eth0 icmp and src 192.168.100.62</span></span><br></pre></td></tr></table></figure>
<p> 注意不能直接写icmp src 192.168.100.70，因为icmp协议不支持直接应用host这个type。</p>
<ol start="12">
<li>** 抓取到本机22端口包 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -c 10 -nn -i eth0 tcp dst port 22</span>  </span><br></pre></td></tr></table></figure>
<ol start="13">
<li>** 解析包数据 **</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -c 2 -q -XX -vvv -nn -i eth0 tcp dst port 22</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>WGET命令</title>
    <url>/2018/01/07/linux/shell-wget/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；</span><br><span class="line">-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</span><br><span class="line">-b：进行后台的方式运行wget；</span><br><span class="line">-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；</span><br><span class="line">-c：继续执行上次终端的任务；</span><br><span class="line">-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</span><br><span class="line">-d：调试模式运行指令；</span><br><span class="line">-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；</span><br><span class="line">-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；</span><br><span class="line">-h：显示指令帮助信息；</span><br><span class="line">-i&lt;文件&gt;：从指定文件获取要下载的URL地址；</span><br><span class="line">-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；</span><br><span class="line">-L：仅顺着关联的连接；</span><br><span class="line">-r：递归下载方式；</span><br><span class="line">-nc：文件存在时，下载文件不覆盖原有文件；</span><br><span class="line">-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；</span><br><span class="line">-q：不显示指令执行过程；</span><br><span class="line">-nh：不查询主机名称；</span><br><span class="line">-v：显示详细执行过程；</span><br><span class="line">-V：显示版本信息；</span><br><span class="line">--passive-ftp：使用被动模式PASV连接FTP服务器；</span><br><span class="line">--follow-ftp：从HTML文件中下载FTP连接文件。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="下载单个文件"><a href="#下载单个文件" class="headerlink" title="下载单个文件"></a>下载单个文件</h3><blockquote>
<p>以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://www.xxx.net/xxx.zip</span></span><br></pre></td></tr></table></figure>


<h3 id="下载并以不同的文件名保存"><a href="#下载并以不同的文件名保存" class="headerlink" title="下载并以不同的文件名保存"></a>下载并以不同的文件名保存</h3><blockquote>
<p>wget默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -O wordpress.zip http://www.xxx.net/xxx.aspx?id=1080</span></span><br></pre></td></tr></table></figure>


<h3 id="wget限速下载"><a href="#wget限速下载" class="headerlink" title="wget限速下载"></a>wget限速下载</h3><blockquote>
<p>当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --limit-rate=300k http://www.xxx.net/testfile.zip</span></span><br></pre></td></tr></table></figure>


<h3 id="使用wget断点续传"><a href="#使用wget断点续传" class="headerlink" title="使用wget断点续传"></a>使用wget断点续传</h3><blockquote>
<p>使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -c http://www.xxx.net/testfile.zip</span></span><br></pre></td></tr></table></figure>

<h3 id="使用wget后台下载"><a href="#使用wget后台下载" class="headerlink" title="使用wget后台下载"></a>使用wget后台下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -b http://www.xxx.net/testfile.zip</span></span><br></pre></td></tr></table></figure>


<h3 id="伪装代理名称下载"><a href="#伪装代理名称下载" class="headerlink" title="伪装代理名称下载"></a>伪装代理名称下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --user-agent=<span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot;</span> http://www.xxx.net/testfile.zip</span></span><br></pre></td></tr></table></figure>

<h3 id="测试下载链接"><a href="#测试下载链接" class="headerlink" title="测试下载链接"></a>测试下载链接</h3><blockquote>
<p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --spider URL</span></span><br></pre></td></tr></table></figure>

<h3 id="增加重试次数"><a href="#增加重试次数" class="headerlink" title="增加重试次数"></a>增加重试次数</h3><blockquote>
<p>如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --tries=40 URL</span></span><br></pre></td></tr></table></figure>

<h3 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h3><blockquote>
<p>首先，保存一份下载链接文件：<br>cat &gt; filelist.txt<br>url1<br>url2<br>url3<br>url4<br>接着使用这个文件和参数-i下载。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -i filelist.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="镜像网站"><a href="#镜像网站" class="headerlink" title="镜像网站"></a>镜像网站</h3><blockquote>
<p>下载整个网站到本地。<br>–miror开户镜像下载。<br>-p下载所有为了html页面显示正常的文件。<br>–convert-links下载后，转换成本地的链接。<br>-P ./LOCAL保存所有文件和目录到本地指定目录。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --mirror -p --convert-links -P ./LOCAL URL</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤指定格式下载"><a href="#过滤指定格式下载" class="headerlink" title="过滤指定格式下载"></a>过滤指定格式下载</h3><blockquote>
<p>下载一个网站，但你不希望下载图片，可以使用这条命令。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --reject=gif ur</span></span><br></pre></td></tr></table></figure>

<h3 id="把下载信息存入日志文件"><a href="#把下载信息存入日志文件" class="headerlink" title="把下载信息存入日志文件"></a>把下载信息存入日志文件</h3><blockquote>
<p>不希望下载信息直接显示在终端而是在一个日志文件，可以使用。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -o download.log URL</span></span><br></pre></td></tr></table></figure>

<h3 id="限制总下载文件大小"><a href="#限制总下载文件大小" class="headerlink" title="限制总下载文件大小"></a>限制总下载文件大小</h3><blockquote>
<p>当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -Q5m -i filelist.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="下载指定格式文件"><a href="#下载指定格式文件" class="headerlink" title="下载指定格式文件"></a>下载指定格式文件</h3><blockquote>
<p>可以在以下情况使用该功能：<br>下载一个网站的所有图片。<br>下载一个网站的所有视频。<br>下载一个网站的所有PDF文件。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -r -A.pdf url</span></span><br></pre></td></tr></table></figure>

<h3 id="FTP下载"><a href="#FTP下载" class="headerlink" title="FTP下载"></a>FTP下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget ftp-url</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span></span><br></pre></td></tr></table></figure>

<h3 id="Https下载"><a href="#Https下载" class="headerlink" title="Https下载"></a>Https下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -r -np -nd --accept=gz --no-check-certificate https://www.xxx.com/dir/ --http-user=username --http-password=password</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd安装</title>
    <url>/2018/01/12/linux/software-vsftpd/</url>
    <content><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>linux系统centos7</li>
<li>vsftpd软件</li>
<li>yum安装</li>
</ul>
<h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><h5 id="安装vsftpd服务器"><a href="#安装vsftpd服务器" class="headerlink" title="安装vsftpd服务器"></a>安装vsftpd服务器</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install vsftpd</span></span><br></pre></td></tr></table></figure>

<h5 id="安装一个加密工具"><a href="#安装一个加密工具" class="headerlink" title="安装一个加密工具"></a>安装一个加密工具</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install libdb-utils.x86_64</span></span><br></pre></td></tr></table></figure>

<h5 id="修改配置VSFTP"><a href="#修改配置VSFTP" class="headerlink" title="修改配置VSFTP"></a>修改配置VSFTP</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure>

<h5 id="配置文件参数说明"><a href="#配置文件参数说明" class="headerlink" title="配置文件参数说明"></a>配置文件参数说明</h5><blockquote>
</blockquote>
<p> anonymous_enable=NO #设定不允许匿名访问<br> local_enable=YES #设定本地用户可以访问。注：如使用虚拟宿主用户，在该项目设定为NO的情况下所有虚拟用户将无法访问。<br> chroot_list_enable=YES #使用户不能离开主目录<br> ascii_upload_enable=YES #允许使用ASCII模式上传<br> ascii_download_enable=YES #设定支持ASCII模式的上传和下载功能。<br> pam_service_name=vsftpd #PAM认证文件名。PAM将根据/etc/pam.d/vsftpd进行认证<br> guest_enable=YES #设定启用虚拟用户功能。<br> guest_username=ftp #指定虚拟用户的宿主用户。-RHEL/CentOS中已经有内置的ftp用户了<br> user_config_dir=/etc/vsftpd/vuser_conf #设定虚拟用户个人vsftp的RHEL/CentOS FTP服务文件存放路  径。<br> listen=YES    # 只监听ipv4的地址<br> xferlog_file=/var/log/xferlog    # 日志文件的路径<br> listen_port=1315        #FTP端口<br> pasv_enable=YES            #开启被动模式<br> pasv_min_port=10060<br> pasv_max_port=10070</p>
<h5 id="创建chroot-list，将ftp用户加入其中"><a href="#创建chroot-list，将ftp用户加入其中" class="headerlink" title="创建chroot list，将ftp用户加入其中"></a>创建chroot list，将ftp用户加入其中</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /etc/vsftpd/chroot_list</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ftp &gt;&gt; /etc/vsftpd/chroot_list</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h5 id="安装Berkeley-DB工具"><a href="#安装Berkeley-DB工具" class="headerlink" title="安装Berkeley DB工具"></a>安装Berkeley DB工具</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install db4 db4-utils</span></span><br></pre></td></tr></table></figure>

<h5 id="创建用户密码文本"><a href="#创建用户密码文本" class="headerlink" title="创建用户密码文本"></a>创建用户密码文本</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch /etc/vsftpd/vuser_passwd.txt</span> </span><br></pre></td></tr></table></figure>

<h5 id="生成虚拟用户认证的db文件"><a href="#生成虚拟用户认证的db文件" class="headerlink" title="生成虚拟用户认证的db文件"></a>生成虚拟用户认证的db文件</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/vuser_passwd.txt /etc/vsftpd/vuser_passwd.db</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 /etc/vsftpd/vuser_passwd.db</span></span><br></pre></td></tr></table></figure>

<h5 id="编辑认证文件"><a href="#编辑认证文件" class="headerlink" title="编辑认证文件"></a>编辑认证文件</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/pam.d/vsftpd</span></span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p> 把前面的注释去掉，然后加上以下几条</p>
<blockquote>
<p>系统为32位：<br> auth required pam_userdb.so db=/etc/vsftpd/vuser_passwd account<br> required pam_userdb.so db=/etc/vsftpd/vuser_passwd</p>
</blockquote>
<blockquote>
<p>系统为64位：<br>auth required /lib64/security/pam_userdb.so<br>db=/etc/vsftpd/vuser_passwd account required<br>/lib64/security/pam_userdb.so db=/etc/vsftpd/vuser_passwd</p>
</blockquote>
<h5 id="修改VSFTPD端口"><a href="#修改VSFTPD端口" class="headerlink" title="修改VSFTPD端口"></a>修改VSFTPD端口</h5><p> 执行<code>vi /etc/services</code>，将其中的 <code>ftp 21/tcp</code> 改为 <code>ftp 1315/tcp</code> , <code>ftp21/udp</code>改为 <code>ftp 1315/udp</code></p>
<h5 id="重启动vsftp服务"><a href="#重启动vsftp服务" class="headerlink" title="重启动vsftp服务"></a>重启动vsftp服务</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service vsftpd restart</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>software</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建跳板机</title>
    <url>/2018/03/12/linux/ssh-drawboard-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>近遇到这样一个问题，我在阿里云室架设了一台服务器，发现外部网元对服务器攻击非常平凡，都知道服务器开放出来的端口越多，对服务器的风险越大。如何来规避这些风险呢，下面具体说明在阿里云上搭建一个跳板机来访问内网服务器，提升服务器的安全。</p>
<h5 id="描述一下目前的机器状况，梳理梳理："><a href="#描述一下目前的机器状况，梳理梳理：" class="headerlink" title="描述一下目前的机器状况，梳理梳理："></a>描述一下目前的机器状况，梳理梳理：</h5><table>
<thead>
<tr>
<th align="left">机器</th>
<th align="left">IP</th>
<th align="left">用户名</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="left">123.78.150.91</td>
<td align="left">root</td>
<td align="left">外网服务器，相当于桥梁的作用，跳板机</td>
</tr>
<tr>
<td align="left">B</td>
<td align="left">172.18.62.123</td>
<td align="left">root</td>
<td align="left">目标服务器，处于内网</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">123.123.123.123</td>
<td align="left">win</td>
<td align="left">自己的电脑</td>
</tr>
</tbody></table>
<span id="more"></span>

<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>通俗地说：就是在机器C上使用xshell/mobaXterm软件连接A机器，自动转向到B机器上。</p>
<h5 id="实现前的准备"><a href="#实现前的准备" class="headerlink" title="实现前的准备"></a>实现前的准备</h5><p>每台都要安装ssh的客户端，在这里我使用的是centos7，都自带ssh。如果是使用其他版本Linux，请手动Google一下咯。</p>
<h5 id="介绍一下使用到的ssh参数"><a href="#介绍一下使用到的ssh参数" class="headerlink" title="介绍一下使用到的ssh参数"></a>介绍一下使用到的ssh参数</h5><p><strong>反向代理</strong><br><code>ssh -fCNR</code></p>
<p><strong>正向代理</strong><br><code>ssh -fCNL</code></p>
<blockquote>
</blockquote>
<p>-f 后台执行ssh指令<br>-C 允许压缩数据<br>-N 不执行远程指令<br>-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口<br>-L 将本地机(客户机)的某个端口转发到远端指定机器的指定端口<br>-p 指定远程主机的端口</p>
<h5 id="首先在A上面操作"><a href="#首先在A上面操作" class="headerlink" title="首先在A上面操作"></a>首先在A上面操作</h5><p>建立A机器到B机器的反向代理，具体指令为<br><code>ssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器端口] [登陆B机器的用户名@服务器IP]</code></p>
<p>在这里我使用了B机器的2222端口，以及A机器的22端口，按照上面的指令就是这样子的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -ngfNTR 2222:172.18.62.123:22 root@123.78.150.91 -o ServerAliveInterval=300</span><br></pre></td></tr></table></figure>

<p>检验是否已经启动了可以使用ps aux | grep ssh指令来查看</p>
<h5 id="阿里云打开端口"><a href="#阿里云打开端口" class="headerlink" title="阿里云打开端口"></a>阿里云打开端口</h5><p>A服务器要打开2222<br>B服务器要打开22，仅限A服务器访问</p>
<h5 id="接着在B上面操作"><a href="#接着在B上面操作" class="headerlink" title="接着在B上面操作"></a>接着在B上面操作</h5><p>建立B机器的ssh-key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>然后一直按回车就可以了，将<code>~/ssh/id_rsa.pub</code>拷贝给A服务器<code>~/ssh/authorized_keys</code></p>
<h5 id="在B上用autossh建立稳定隧道"><a href="#在B上用autossh建立稳定隧道" class="headerlink" title="在B上用autossh建立稳定隧道"></a>在B上用autossh建立稳定隧道</h5><p>centos7上没有默认安装<code>autossh</code>的，所以使用一下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install autossh</span><br></pre></td></tr></table></figure>

<p>在B服务器上使用autossh建立稳定隧道</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">autossh -p 22 -M 6777 -fNR 2222:127.0.0.1:22 root@123.78.150.91</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令说明<br>-M 6777 这个表示是监控端口，检测到这个端口不通会重新连接<br>2222:127.0.0.1:22  2222表示需要在远程主机上开启的端口，22表示本地的ssh端口<br><a href="mailto:&#114;&#111;&#111;&#116;&#64;&#49;&#50;&#51;&#x2e;&#55;&#56;&#46;&#x31;&#x35;&#x30;&#x2e;&#x39;&#49;">&#114;&#111;&#111;&#116;&#64;&#49;&#50;&#51;&#x2e;&#55;&#56;&#46;&#x31;&#x35;&#x30;&#x2e;&#x39;&#49;</a> -p 22 root为vps上面的用户，22为vps ssh端口</p>
</blockquote>
<p><strong>现在就可以在A服务器使用SSH端口为2222访问B服务器了</strong></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>drawboard</tag>
      </tags>
  </entry>
  <entry>
    <title>npm使用</title>
    <url>/2018/02/05/npm/1/</url>
    <content><![CDATA[<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">2.3.0</span><br></pre></td></tr></table></figure>

<p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install npm -g</span></span><br><span class="line">/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js</span><br><span class="line">npm@2.14.2 /usr/local/lib/node_modules/npm</span><br></pre></td></tr></table></figure>

<p>如果是 Window 系统使用以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install npm -g</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a>使用 npm 命令安装模块</h4><p>npm 安装 Node.js 模块语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install &lt;Module Name&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express</span></span><br></pre></td></tr></table></figure>

<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a>全局安装与本地安装</h4><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express          <span class="comment"># 本地安装</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install express -g   		  <span class="comment"># 全局安装</span></span></span><br></pre></td></tr></table></figure>

<p>如果出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 </span><br></pre></td></tr></table></figure>

<p>解决办法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm config <span class="built_in">set</span> proxy null</span></span><br></pre></td></tr></table></figure>

<h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h4><ul>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ul>
<h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><ul>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ul>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。<br>接下来我们使用全局方式安装 express</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express -g</span></span><br></pre></td></tr></table></figure>

<h4 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a>查看安装信息</h4><p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm list -g</span></span><br></pre></td></tr></table></figure>

<p>如果要查看某个模块的版本号，可以使用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm list grunt</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-package-json"><a href="#使用-package-json" class="headerlink" title="使用 package.json"></a>使用 package.json</h4><p>package.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;3.4.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.2.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;,</span><br><span class="line">    &quot;gulp-htmlclean&quot;: &quot;^2.7.16&quot;,</span><br><span class="line">    &quot;gulp-htmlmin&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,</span><br><span class="line">    &quot;gulp-uglify&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-admin&quot;: &quot;^2.3.0&quot;,</span><br><span class="line">    &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;,</span><br><span class="line">    &quot;hexo-wordcount&quot;: &quot;^3.0.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">Package.json 属性说明</span><br><span class="line">- name - 包名。</span><br><span class="line">- version - 包的版本号。</span><br><span class="line">- description - 包的描述。</span><br><span class="line">- homepage - 包的官网 url 。</span><br><span class="line">- author - 包的作者姓名。</span><br><span class="line">- contributors - 包的其他贡献者姓名。</span><br><span class="line">- dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</span><br><span class="line">- repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</span><br><span class="line">- main - main 字段指定了程序的主入口文件，require(&#x27;moduleName&#x27;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</span><br><span class="line">- keywords - 关键字</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 卸载模块</span></span></span><br><span class="line"></span><br><span class="line">我们可以使用以下命令来卸载 Node.js 模块。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall express</span></span><br></pre></td></tr></table></figure>

<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm ls</span></span><br></pre></td></tr></table></figure>

<h4 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h4><p>我们可以使用以下命令更新模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm update express</span></span><br></pre></td></tr></table></figure>

<h4 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h4><p>使用以下来搜索模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm search express</span></span><br></pre></td></tr></table></figure>

<h4 id="使用淘宝-NPM-镜像"><a href="#使用淘宝-NPM-镜像" class="headerlink" title="使用淘宝 NPM 镜像"></a>使用淘宝 NPM 镜像</h4><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>

<h4 id="安装不创建bin链接"><a href="#安装不创建bin链接" class="headerlink" title="安装不创建bin链接"></a>安装不创建bin链接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --no-bin-links</span></span><br></pre></td></tr></table></figure>

<h4 id="编译并不创建bin链接"><a href="#编译并不创建bin链接" class="headerlink" title="编译并不创建bin链接"></a>编译并不创建bin链接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm rebuild node-sass --no-bin-links</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle安装（一）</title>
    <url>/2018/03/28/oracle/1/</url>
    <content><![CDATA[<h4 id="Linux下Oracle安装（一）"><a href="#Linux下Oracle安装（一）" class="headerlink" title="Linux下Oracle安装（一）"></a>Linux下Oracle安装（一）</h4><p>在Linux中安装Oracle主要有以下几步</p>
<h5 id="安装Oracle依赖包"><a href="#安装Oracle依赖包" class="headerlink" title="安装Oracle依赖包"></a>安装Oracle依赖包</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum -y install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel glibc glibc-common glibc-devel gcc gcc-c++ libaio-devel libaio libgcc libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel pdksh ksh libaio.i686 glibc.i686 compat-libstdc++-33.i686 libaio-devel.i686 libgcc.i686 libstdc++.i686 unixODBC.i686 unixODBC-devel.i686</span></span><br></pre></td></tr></table></figure>

<h5 id="创建Oracle对应目录并设置权限"><a href="#创建Oracle对应目录并设置权限" class="headerlink" title="创建Oracle对应目录并设置权限"></a>创建Oracle对应目录并设置权限</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /oracle/app/oracle &amp;&amp; chown -R oracle:oinstall /oracle/app/oracle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /oracle/app/oraInventory &amp;&amp; chown -R oracle:oinstall /oracle/app/oraInventory</span></span><br></pre></td></tr></table></figure>

<h5 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install xhost</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum grouplist</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum groupinstall <span class="string">&quot;X Window System&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum groupinstall Desktop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install xterm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install xclock</span></span><br></pre></td></tr></table></figure>

 <span id="more"></span>

<h5 id="设置图形界面显示位置"><a href="#设置图形界面显示位置" class="headerlink" title="设置图形界面显示位置"></a>设置图形界面显示位置</h5><p> <code>export DISPLAY=客户端IP:0.0</code></p>
<h5 id="创建Oracle系统用户"><a href="#创建Oracle系统用户" class="headerlink" title="创建Oracle系统用户"></a>创建Oracle系统用户</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> groupadd oinstall</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> groupadd dba</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> useradd -g oinstall -G dba oracle</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> passwd oracle</span></span><br></pre></td></tr></table></figure>

<h5 id="修改系统内核（可选）"><a href="#修改系统内核（可选）" class="headerlink" title="修改系统内核（可选）"></a>修改系统内核（可选）</h5><p> <code>vi /etc/sysctl.conf</code></p>
<blockquote>
<p>新增内容如下：<br> kernel.shmall = 2097152<br> kernel.shmmax = 536870912<br> kernel.shmmni = 4096<br> kernel.sem = 250 32000 100 128<br> fs.aio-max-nr = 1048576<br> fs.file-max = 6815744<br> net.ipv4.ip_local_port_range = 9000 65500<br> net.core.rmem_default = 262144<br> net.core.rmem_max = 4194304<br> net.core.wmem_default = 262144<br> net.core.wmem_max = 1048586</p>
</blockquote>
<h5 id="配置文件限制（可选）"><a href="#配置文件限制（可选）" class="headerlink" title="配置文件限制（可选）"></a>配置文件限制（可选）</h5><p> <code>vi /etc/security/limits.conf</code></p>
<blockquote>
<p>内容如下：<br> oracle           soft    nproc   2047<br> oracle           hard    nproc   16384<br> oracle           soft    nofile  1024<br> oracle           hard    nofile  65536</p>
</blockquote>
<h5 id="配置Oracle环境变量"><a href="#配置Oracle环境变量" class="headerlink" title="配置Oracle环境变量"></a>配置Oracle环境变量</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> su oracle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi .bash_profile</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>bash_profile内容修改如下：<br> export ORACLE_BASE=/oracle/app/oracle        #ORACLE基础目录<br> export ORACLE_HOME=/oracle/app/oracle/product/11.2.0/dbhome_1        #ORACLE安装目录<br> export ORACLE_SID=CCMP                        #SID<br> export PATH=$ORACLE_HOME/bin:$PATH<br> export ORACLE_TERM=xterm<br> export TNS_ADMIN=$ORACLE_HOME/network/admin<br> export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/oracm/lib:$ORACLE_HOME/lib<br> export CLASSPATH=$CLASSPATH:$ORACLE_HOME/rdbms/jlib:$ORACLE_HOME/jlib:$ORACLE_HOME/network/lib<br> export LANG=en_US.gbk<br> export NLS_LANG=american_america.ZHS16GBK<br> export EDITOR=vi<br> PATH=$PATH:$HOME/.local/bin:$HOME/bin<br> export PATH</p>
</blockquote>
<h5 id="使用Xshell-MobaXterm来显示界面"><a href="#使用Xshell-MobaXterm来显示界面" class="headerlink" title="使用Xshell/MobaXterm来显示界面"></a>使用Xshell/MobaXterm来显示界面</h5><p> <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/1.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p> <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/2.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p> <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/3.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p> <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/4.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle安装（二）</title>
    <url>/2018/03/29/oracle/2/</url>
    <content><![CDATA[<h4 id="Linux下Oracle安装（二）"><a href="#Linux下Oracle安装（二）" class="headerlink" title="Linux下Oracle安装（二）"></a>Linux下Oracle安装（二）</h4><h5 id="运行Oracle安装文件"><a href="#运行Oracle安装文件" class="headerlink" title="运行Oracle安装文件"></a>运行Oracle安装文件</h5> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> su oracle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /opt/oracle/database/runInstaller -jreLoc /opt/jdk1.7.0_80/</span></span><br></pre></td></tr></table></figure>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/5.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/6.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
  <span id="more"></span>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/7.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/8.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/9.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/10.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/11.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/12.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/13.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/14.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/15.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/16.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h5 id="运行Oracle自带脚本"><a href="#运行Oracle自带脚本" class="headerlink" title="运行Oracle自带脚本"></a>运行Oracle自带脚本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /oracle/app/oraInventory/orainstRoot.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /oracle/app/oracle/product/11.2.0/dbhome_1/root.sh</span></span><br></pre></td></tr></table></figure>

<h5 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /oracle/app/oracle/product/11.2.0/dbhome_1/bin/dbca</span></span><br></pre></td></tr></table></figure>

<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/17.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/18.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  这里有3个模板，在这里就使用第一个，一般用途或事务处理<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/19.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  在这里需要填上之前在环境变量文件中写的sid<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/20.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  Oracle的EM资料档案库，可以做到很多的功能实现，可以做到很多的功能，但是如果是不需要的话就把钩去掉<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/21.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  在这里设置用户密码，可以让用户的密码单独不一样，在这里就设置成一样的<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/22.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  这里使用文件系统<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/23.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  在这里设置闪回区大小，建议20~30GB，这个要根据磁盘的时间情况设置，闪回区如果满了Oracle数据库会停止，所以这个需要注意<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/24.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  说明示例，这里不需要<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/25.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  配置Oracle的默认的一些系统配置，这里需要注意的是字符集，这个需要根据需求修改<br>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/26.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/27.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/28.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/29.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>  这样数据库的创建dbca的部分就安装完成了</p>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle安装（三）</title>
    <url>/2018/03/29/oracle/3/</url>
    <content><![CDATA[<h4 id="Linux下Oracle安装（三）"><a href="#Linux下Oracle安装（三）" class="headerlink" title="Linux下Oracle安装（三）"></a>Linux下Oracle安装（三）</h4><h5 id="配置监听文件和本地服务"><a href="#配置监听文件和本地服务" class="headerlink" title="配置监听文件和本地服务"></a>配置监听文件和本地服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /oracle/app/oracle/product/11.2.0/dbhome_1/bin/netca</span></span><br></pre></td></tr></table></figure>

<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/30.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>创建监听服务，作为Oracle的服务端</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/31.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/32.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>使用tcp协议<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/33.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>Oracle的默认的端口是1521<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/34.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<span id="more"></span>

<p>是否要创建另外一个监听文件，这里就选NO<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/35.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/36.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>配置本地网络服务名，作为Oracle的客户端<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/38.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/40.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/41.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>这里填服务器的ip<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/42.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>这里选yes测试一下，之后就和之前一样结束即可，到此Oracle的安装部署就已经完成了<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/oracle/43.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle安装（四）</title>
    <url>/2018/03/29/oracle/4/</url>
    <content><![CDATA[<h4 id="Linux下Oracle安装（四）"><a href="#Linux下Oracle安装（四）" class="headerlink" title="Linux下Oracle安装（四）"></a>Linux下Oracle安装（四）</h4><h5 id="启动监听和数据库"><a href="#启动监听和数据库" class="headerlink" title="启动监听和数据库"></a>启动监听和数据库</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /oracle/app/oracle/product/11.2.0/dbhome_1/bin/lsnrctl start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /oracle/app/oracle/product/11.2.0/dbhome_1/bin/sqlplus / as sysdba</span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> startup</span></span><br></pre></td></tr></table></figure>
<h5 id="设置dba密码"><a href="#设置dba密码" class="headerlink" title="设置dba密码"></a>设置dba密码</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> alter user sys identified by 123456;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用Oracle客户端，创建表空间"><a href="#使用Oracle客户端，创建表空间" class="headerlink" title="使用Oracle客户端，创建表空间"></a>使用Oracle客户端，创建表空间</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create tablespace ccmp_app 						-表空间名称</span><br><span class="line">logging </span><br><span class="line">datafile &#x27;/oracle/ccmp-databases/ccmp_app&#x27; 		-表空间存储位置</span><br><span class="line">size 10m </span><br><span class="line">autoextend on </span><br><span class="line">next 10m maxsize 20480m </span><br><span class="line">extent management local; </span><br></pre></td></tr></table></figure>

<h5 id="使用Oracle客户端，创建临时表空间"><a href="#使用Oracle客户端，创建临时表空间" class="headerlink" title="使用Oracle客户端，创建临时表空间"></a>使用Oracle客户端，创建临时表空间</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create temporary tablespace ccmp_app_temp 			-表空间名称</span><br><span class="line">tempfile &#x27;/oracle/ccmp-databases/ccmp_app_temp&#x27; 	-表空间存储位置</span><br><span class="line">size 10m </span><br><span class="line">autoextend on </span><br><span class="line">next 10m maxsize 20480m </span><br><span class="line">extent management local; </span><br></pre></td></tr></table></figure>

<h5 id="创建用户和指定表空间"><a href="#创建用户和指定表空间" class="headerlink" title="创建用户和指定表空间"></a>创建用户和指定表空间</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> create user ccmp_app identified by 123456;</span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> default tablespace ccmp_app;</span></span><br><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> temporary tablespace ccmp_app_temp;</span> </span><br></pre></td></tr></table></figure>

<h5 id="赋予用户权限"><a href="#赋予用户权限" class="headerlink" title="赋予用户权限"></a>赋予用户权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">SQL&gt;</span><span class="bash"> grant connect,resource,dba to ccmp_app;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Rsync + Sersync 实现文件实时同步</title>
    <url>/2020/07/21/software/rsync-1/</url>
    <content><![CDATA[<h2 id="Rsync-Sersync-实现文件实时同步"><a href="#Rsync-Sersync-实现文件实时同步" class="headerlink" title="Rsync + Sersync 实现文件实时同步"></a>Rsync + Sersync 实现文件实时同步</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>sersync主要用于服务器同步，web镜像等功能。基于boost1.43.0,inotify api,rsync command.开发。目前使用的比较多的同步解决方案是inotify-tools+rsync ，另外一个是google开源项目Openduckbill（依赖于inotify- tools），这两个都是基于脚本语言编写的。相比较上面两个项目，本项目优点是：</p>
<ul>
<li>sersync是使用c++编写，而且对linux系统文件系统产生的临时文件和重复的文件操作进行过滤，所以在结合rsync同步的时候，节省了运行时耗和网络资源。因此更快。</li>
<li>sersync配置起来很简单，其中bin目录下已经有基本上静态编译的2进制文件，配合bin目录下的xml配置文件直接使用即可。</li>
<li>使用多线程进行同步，尤其在同步较大文件时，能够保证多个服务器实时保持同步状态。</li>
<li>有出错处理机制，通过失败队列对出错的文件重新同步，如果仍旧失败，则按设定时长对同步失败的文件重新同步。</li>
<li>自带crontab功能，只需在xml配置文件中开启，即可按要求隔一段时间整体同步一次。无需再额外配置crontab功能。</li>
<li>能够实现socket与http插件扩展。</li>
</ul>
<span id="more"></span>


<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>步骤原理：</p>
<ul>
<li>在同步服务器（Master）上开启sersync服务，sersync负载监控配置路径中的文件系统事件变化；</li>
<li>调用rsync命令把更新的文件同步到目标服务器（S1 和 S2）；</li>
<li>需要在主服务器配置sersync，在同步目标服务器配置rsync server（注意：是rsync服务）</li>
</ul>
<p>同步原理：</p>
<ul>
<li>用户实时的往sersync服务器（M）上写入更新文件数据；</li>
<li>此时需要在同步主服务器（M）上配置sersync服务；</li>
<li>在S1 和S2上开启rsync守护进程服务，以同步拉取来自sersync服务器（M）上的数据；</li>
</ul>
<p>通过rsync的守护进程服务后可以发现，实际上sersync就是监控本地的数据写入或更新事件；然后，在调用rsync客户端的命令，将写入或更新事件对应的文件通过rsync推送到目标服务器（S1 和S2）</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>服务器拓扑图：</p>
<table>
<thead>
<tr>
<th>IP</th>
<th>说明</th>
<th>主机名</th>
</tr>
</thead>
<tbody><tr>
<td>172.24.2.71</td>
<td>文件存储服务器</td>
<td>node1</td>
</tr>
<tr>
<td>172.24.2.70</td>
<td>文件存储服务器</td>
<td>node2</td>
</tr>
<tr>
<td>172.24.2.62</td>
<td>备份服务器</td>
<td>backup</td>
</tr>
</tbody></table>
<p>node1与node2配置相同，下面仅配置node1，有配置不同的地址会指出</p>
<h4 id="安装部署rsync"><a href="#安装部署rsync" class="headerlink" title="安装部署rsync"></a>安装部署rsync</h4><p>进入<code>backup</code>服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建备份文件夹</span></span></span><br><span class="line">[root@backup ~]# mkdir -p /backup/nfs/71</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装rsync</span></span></span><br><span class="line">[root@backup ~]# yum install rsync</span><br></pre></td></tr></table></figure>

<h5 id="配置rsyncd-conf"><a href="#配置rsyncd-conf" class="headerlink" title="配置rsyncd.conf"></a>配置rsyncd.conf</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@backup ~]# vi /etc/rsyncd/rsyncd.conf</span><br><span class="line"></span><br><span class="line">port = 873</span><br><span class="line">pid file = /etc/rsyncd/rsyncd.pid</span><br><span class="line">motd file= /etc/rsyncd/welcome.msg</span><br><span class="line">lock file = /etc/rsyncd/rsyncd.lock</span><br><span class="line">log file = /etc/rsyncd/rsyncd.log</span><br><span class="line">timeout = 900</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置某些格式不压缩</span></span><br><span class="line">dont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class="line"></span><br><span class="line">[71]</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器读写目录</span></span><br><span class="line">path = /backup/nfs/71</span><br><span class="line">use chroot = no</span><br><span class="line"><span class="meta">#</span><span class="bash">只写选择，只让客户端到服务器上写入</span></span><br><span class="line">write only = yes</span><br><span class="line"><span class="meta">#</span><span class="bash">只读选择，只让客户端从服务器上读取文件</span></span><br><span class="line">read only = no</span><br><span class="line">max connections = 5</span><br><span class="line">list = yes</span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 账号密码存放位置</span></span><br><span class="line">secrets file = /etc/rsyncd/rsyncd.secrets</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许客户端连接IP地址</span></span><br><span class="line">hosts allow = 172.24.2.71</span><br><span class="line">hosts deny = *</span><br><span class="line">ignore errors = yes</span><br><span class="line">transfer logging = yes</span><br><span class="line">log format = %t %a %m %f %b</span><br><span class="line">auth users = root</span><br></pre></td></tr></table></figure>

<h5 id="配置rsyncd-secrets"><a href="#配置rsyncd-secrets" class="headerlink" title="配置rsyncd.secrets"></a>配置rsyncd.secrets</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@backup ~]# vi /etc/rsyncd/rsyncd.secrets</span><br><span class="line"></span><br><span class="line">root:71</span><br><span class="line"></span><br><span class="line">[root@backup ~]# chmod 600 /etc/rsyncd/rsyncd.secrets</span><br></pre></td></tr></table></figure>

<h5 id="启动rsync"><a href="#启动rsync" class="headerlink" title="启动rsync"></a>启动rsync</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@backup ~]# rsync --daemon --config=/etc/rsyncd/rsyncd.conf</span><br></pre></td></tr></table></figure>

<p>进入<code>node1</code>服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装rsync</span></span></span><br><span class="line">[root@node1 ~]# yum install rsync</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 配置密码</span></span></span><br><span class="line">[root@node1 ~]# vi /etc/rsync.password</span><br><span class="line">71</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 配置文件权限</span></span></span><br><span class="line">[root@node1 ~]# chmod 600 /etc/rsync.password</span><br></pre></td></tr></table></figure>



<h4 id="安装部署sersync"><a href="#安装部署sersync" class="headerlink" title="安装部署sersync"></a>安装部署sersync</h4><p>进入<code>node1</code>服务器，配置系统参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看系统是否支持</span></span></span><br><span class="line">[root@node1 ~]# ll /proc/sys/fs/inotify</span><br><span class="line"></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 21 10:47 max_queued_events</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 21 11:18 max_user_instances</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 21 10:47 max_user_watches</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看系统默认参数值</span></span></span><br><span class="line">[root@node1 ~]# sysctl -a | grep max_queued_events</span><br><span class="line">fs.inotify.max_queued_events = 16384</span><br><span class="line"></span><br><span class="line">[root@node1 ~]# sysctl -a | grep max_user_instances</span><br><span class="line">fs.inotify.max_user_instances = 128</span><br><span class="line"></span><br><span class="line">[root@node1 ~]# sysctl -a | grep max_user_watches</span><br><span class="line">fs.inotify.max_user_watches = 8192</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改参数，如果修改过以下参数则不用再次修改</span></span></span><br><span class="line">[root@node1 ~]# echo &quot;fs.inotify.max_queued_events = 99999999&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">[root@node1 ~]# echo &quot;fs.inotify.max_user_watches = 99999999&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">[root@node1 ~]# echo &quot;fs.inotify.max_user_instances = 65535&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">[root@node1 ~]# sysctl -p</span><br></pre></td></tr></table></figure>

<p><code>inotify</code>参数说明：</p>
<ul>
<li>max_queued_events：inotify队列最大长度，如果值太小，会出现”** Event Queue Overflow **”错误，导致监控文件不准确</li>
<li>max_user_watches：要同步的文件包含多少目录，可以用：find /home/wwwroot/ -type d | wc -l 统计，必须保证max_user_watches值大于统计结果（这里/home/wwwroot/为同步文件目录）</li>
<li>max_user_instances：每个用户创建inotify实例最大值</li>
</ul>
<h5 id="下载sersync"><a href="#下载sersync" class="headerlink" title="下载sersync"></a>下载sersync</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# wget --no-check-certificate https://raw.githubusercontent.com/orangle/sersync/master/release/sersync2.5.4_64bit_binary_stable_final.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="配置sersync"><a href="#配置sersync" class="headerlink" title="配置sersync"></a>配置sersync</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# tar xf sersync2.5.4_64bit_binary_stable_final.tar.gz </span><br><span class="line">[root@node1 ~]# mv GNU-Linux-x86/ /usr/local/sersync</span><br><span class="line">[root@node1 ~]# cd /usr/local/sersync/</span><br><span class="line">[root@node1 ~]# cp confxml.xml confxml.xml_bak</span><br></pre></td></tr></table></figure>

<p>修改配置文件如果有多个同步模块，则按下面格式依次去写，仅更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# vi /usr/local/sersync/confxml.xml</span><br><span class="line"></span><br><span class="line">&lt;localpath watch=&quot;/nfs/data/&quot;&gt;			## 需要同步的目录</span><br><span class="line">	&lt;remote ip=&quot;172.24.2.62&quot; name=&quot;71&quot;/&gt;	## 备份服务器IP</span><br><span class="line">&lt;/localpath&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># rsync认证的账号和密码，start-true打开校验</span></span></span><br><span class="line">&lt;auth start=&quot;true&quot; users=&quot;root&quot; passwordfile=&quot;/etc/rsync.password&quot;/&gt;  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 错误日志存放位置和触发时间60秒</span></span></span><br><span class="line">&lt;failLog path=&quot;/usr/local/sersync/logs/rsync_fail_log.sh&quot; timeToExecute=&quot;60&quot;/&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建日志目录</span></span></span><br><span class="line">[root@node1 ~]#  mkdir -p /usr/local/sersync/logs/</span><br><span class="line">[root@node1 ~]#  touch /usr/local/sersync/logs/rsync_fail_log.sh</span><br></pre></td></tr></table></figure>

<h5 id="启动sersync"><a href="#启动sersync" class="headerlink" title="启动sersync"></a>启动sersync</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]#  echo &quot;PATH=$PATH:/usr/local/sersync/&quot; &gt;&gt; /etc/profile</span><br><span class="line">[root@node1 ~]#  source /etc/profile</span><br><span class="line">[root@node1 ~]#  /usr/local/sersync/sersync2 -d -r -o /usr/local/sersync/confxml.xml</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>software</category>
        <category>rsync</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Shadowsocks服务</title>
    <url>/2019/10/13/software/ss-1/</url>
    <content><![CDATA[<h3 id="搭建Shadowsocks服务"><a href="#搭建Shadowsocks服务" class="headerlink" title="搭建Shadowsocks服务"></a>搭建Shadowsocks服务</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p> shadowsocks可以指一种SOCKS5的加密传输协议，也可以指基于这种加密协议的各种数据传输包。 </p>
<p><strong>shadowsocks实现科学上网原理？</strong>shadowsocks正常工作需要服务器端和客户端两端合作实现，首先，客户端（本机）通过ss（shadowsocks）对正常的访问请求进行SOCK5加密，将加密后的访问请求传输给ss服务器端，服务器端接收到客户端的加密请求后，解密得到原始的访问请求，根据请求内容访问指定的网站（例如Google，YouTube，Facebook，instagram等），得到网站的返回结果后，再利用SOCKS5加密并返回给客户端，客户端通过ss解密后得到正常的访问结果，于是就可以实现你直接访问该网站的“假象”。</p>
<p><strong>为什么选择shadowsocks？</strong>不限终端（安卓，苹果，Windows，Mac都可用），流量便宜（服务器500G只要15元），方便（一键脚本，不需要专业知识）。</p>
<span id="more"></span>

<p><strong>为什么要自己搭建ss/ssr？</strong>你也许会觉得买ss服务也很方便，但是你得要考虑以下几个问题。首先，买的ss服务，限制很多，终端可能只能同时在线2个，每个月就一点点流量可能价格却不便宜，有时候还被别人做手脚，流量跑的贼快；其次，别人收钱跑路怎么办？很多这种情况的；更重要的是，如第一个问题中描述的shadowsocks原理，如果有心人做了一点手脚，是可以得到你的访问记录的；而自己搭建ss/ssr服务，一键脚本也就10来分钟就可以搞定。</p>
<h4 id="代理服务器购买"><a href="#代理服务器购买" class="headerlink" title="代理服务器购买"></a>代理服务器购买</h4><p>作为跳板的代理服务器推荐Vultr和搬瓦工，一是因为本脚本在这两家的所有VPS都做了测试，二是因为都是老牌VPS服务商，不怕跑路。</p>
<p>Vultr和搬瓦工比较：</p>
<ol>
<li>Vultr月付，3.5美元/月起步，搬瓦工年付，年付46.87美元起步；</li>
<li>搬瓦工线路好，提供CN2 GT/CN2 GIA多条线路，并且保证开到的IP绝对可用；</li>
</ol>
<p>如果你是长期使用，那么推荐你使用搬瓦工，线路比Vultr要好的，尤其是联通和电信用户，所谓线路好就是速度快的意思。</p>
<p>搬瓦工提供CN2和CN2 GIA多种优化线路：</p>
<ol>
<li>速度自然是CN2 GIA &gt; CN2 &gt; KVM，相应的价格最贵的是CN2 GIA（包括CN2 GIA-E），但是CN2和KVM的价格却一样，所以如果不买CN2 GIA，则买CN2，不要考虑KVM；</li>
<li>CN2 GIA的意思是三网CN2直连的意思，优势就是晚高峰也快，价格是最便宜的119.99美元/年，贵但是值。</li>
</ol>
<p>对于搬瓦工的推荐：</p>
<ol>
<li>不是很在乎120美元/年和50美元/年之间的差距，一年也就差500元其实，那么直接选择CN2 GIA-E，用过的都说好；</li>
<li>如果不是很宽裕，则选择50美元/年的搬瓦工CN2。</li>
</ol>
<p> 搬瓦工购买与优惠码使用： <a href="https://www.vultr.com/?ref=8289861">https://www.vultr.com/?ref=8289861</a></p>
<h4 id="一键搭建Shadowsocks"><a href="#一键搭建Shadowsocks" class="headerlink" title="一键搭建Shadowsocks"></a>一键搭建Shadowsocks</h4><p> 连上购买的VPS后（以Xshell为例），你将看到如下图所示的界面 </p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/software/ss/1.png" alt="1"></p>
<p> 如红框中所示，root@vult（root@ubuntu）说明已经连接成功了，之后你只需要<strong>在绿色光标处直接复制以下代码并回车</strong>就可以了（直接复制即可，如每段代码下方截图中所示）。 </p>
<p>1、安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure>

<p>2、将代码clone到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/flyzy2005/ss-fly</span><br></pre></td></tr></table></figure>

<p>3、运行搭建ss脚本代码 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -i 密码 端口号</span><br></pre></td></tr></table></figure>

<p>界面如下就表示一键搭建ss成功了：</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/software/ss/2.png" alt="2"></p>
<p>4、 相关ss操作 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改配置文件：vim /etc/shadowsocks.json</span><br><span class="line">停止ss服务：ssserver -c /etc/shadowsocks.json -d stop</span><br><span class="line">启动ss服务：ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">重启ss服务：ssserver -c /etc/shadowsocks.json -d restart</span><br></pre></td></tr></table></figure>

<p>5、 卸载ss服务 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sss -fly/ss-fly.sh -uninstall</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>software</category>
        <category>ss</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 IPsec VPN 服务</title>
    <url>/2020/02/05/software/vpn-1/</url>
    <content><![CDATA[<h3 id="搭建-IPsec-VPN-服务"><a href="#搭建-IPsec-VPN-服务" class="headerlink" title="搭建 IPsec VPN 服务"></a>搭建 IPsec VPN 服务</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>我们在开发的时候经常遇见启动服务过多，内存消耗过大，安全问题，等，让我们非常头痛，特别是对Spring Cloud微服务的开发。在这里有同学会说把这些都部署到局域网的服务器上就行了，但如果资源有限的时候，我们对资源的利用率应该有所考虑。</p>
<p>将部分资源部署到云服务器，搭建一个的VPN服务，并隔离外网，这样做能让我们很好的解决上面的问题。</p>
<span id="more"></span>


<h4 id="搭建-amp-运行"><a href="#搭建-amp-运行" class="headerlink" title="搭建&amp;运行"></a>搭建&amp;运行</h4><p><strong>下载ipsec-vpn-server</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hwdsl2/ipsec-vpn-server</span><br></pre></td></tr></table></figure>

<p><strong>配置环境变量</strong></p>
<p>这个 Docker 镜像使用以下几个变量，可以在一个 <code>vpn.env</code> 文件中定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VPN_IPSEC_PSK=your_ipsec_pre_shared_key</span><br><span class="line">VPN_USER=your_vpn_username</span><br><span class="line">VPN_PASSWORD=your_vpn_password</span><br></pre></td></tr></table></figure>

<p>这将创建一个用于 VPN 登录的用户账户，它可以在你的多个设备上使用<a href="https://github.com/hwdsl2/docker-ipsec-vpn-server/blob/master/README-zh.md#%E9%87%8D%E8%A6%81%E6%8F%90%E7%A4%BA">*</a>。 IPsec PSK (预共享密钥) 由 <code>VPN_IPSEC_PSK</code> 环境变量指定。 VPN 用户名和密码分别在 <code>VPN_USER</code> 和 <code>VPN_PASSWORD</code> 中定义。</p>
<p>支持创建额外的 VPN 用户，如果需要，可以像下面这样在你的 <code>env</code> 文件中定义。用户名和密码必须分别使用空格进行分隔，并且用户名不能有重复。所有的 VPN 用户将共享同一个 IPsec PSK。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VPN_ADDL_USERS=additional_username_1 additional_username_2</span><br><span class="line">VPN_ADDL_PASSWORDS=additional_password_1 additional_password_2</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> 在你的 <code>env</code> 文件中，<strong>不要</strong>为变量值添加 <code>&quot;&quot;</code> 或者 <code>&#39;&#39;</code>，或在 <code>=</code> 两边添加空格。<strong>不要</strong>在值中使用这些字符： <code>\ &quot; &#39;</code>。一个安全的 IPsec PSK 应该至少包含 20 个随机字符。</p>
<p>所有这些环境变量对于本镜像都是可选的，也就是说无需定义它们就可以搭建 IPsec VPN 服务器。详情请参见以下部分。</p>
<p><strong>运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --name ipsec-vpn-server \</span><br><span class="line">    --env-file ./vpn.env \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -p 500:500/udp \</span><br><span class="line">    -p 4500:4500/udp \</span><br><span class="line">    -d --privileged \</span><br><span class="line">    hwdsl2/ipsec-vpn-server</span><br></pre></td></tr></table></figure>

<p>端口是固定的，建议不做修改，阿里云安全组中必须要增加UDP（500和4500）端口。</p>
<h4 id="配置-IPsec-L2TP-VPN-客户端"><a href="#配置-IPsec-L2TP-VPN-客户端" class="headerlink" title="配置 IPsec/L2TP VPN 客户端"></a>配置 IPsec/L2TP VPN 客户端</h4><h5 id="Win10"><a href="#Win10" class="headerlink" title="Win10"></a>Win10</h5><ol>
<li>右键单击系统托盘中的无线/网络图标。</li>
<li>选择 <strong>打开网络和共享中心</strong>。或者，如果你使用 Windows 10 版本 1709 或以上，选择 <strong>打开”网络和 Internet”设置</strong>，然后在打开的页面中单击 <strong>网络和共享中心</strong>。</li>
<li>单击 <strong>设置新的连接或网络</strong>。</li>
<li>选择 <strong>连接到工作区</strong>，然后单击 <strong>下一步</strong>。</li>
<li>单击 **使用我的Internet连接 (VPN)**。</li>
<li>在 <strong>Internet地址</strong> 字段中输入<code>你的 VPN 服务器 IP</code>。</li>
<li>在 <strong>目标名称</strong> 字段中输入任意内容。单击 <strong>创建</strong>。</li>
<li>返回 <strong>网络和共享中心</strong>。单击左侧的 <strong>更改适配器设置</strong>。</li>
<li>右键单击新创建的 VPN 连接，并选择 <strong>属性</strong>。</li>
<li>单击 <strong>安全</strong> 选项卡，从 <strong>VPN 类型</strong> 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。</li>
<li>单击 <strong>允许使用这些协议</strong>。选中 “质询握手身份验证协议 (CHAP)” 和 “Microsoft CHAP 版本 2 (MS-CHAP v2)” 复选框。</li>
<li>单击 <strong>高级设置</strong> 按钮。</li>
<li>单击 <strong>使用预共享密钥作身份验证</strong> 并在 <strong>密钥</strong> 字段中输入<code>你的 VPN IPsec PSK</code>。</li>
<li>单击 <strong>确定</strong> 关闭 <strong>高级设置</strong>。</li>
<li>单击 <strong>确定</strong> 保存 VPN 连接的详细信息。</li>
</ol>
<p><strong>注：</strong> 在首次连接之前需要<strong>修改一次注册表</strong>。请参见下面的说明。</p>
<p>另外，除了按照以上步骤操作，你也可以运行下面的 Windows PowerShell 命令来创建 VPN 连接。将 <code>你的 VPN 服务器 IP</code> 和 <code>你的 VPN IPsec PSK</code> 换成你自己的值，用单引号括起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不保存命令行历史记录</span><br><span class="line">Set-PSReadlineOption –HistorySaveStyle SaveNothing</span><br><span class="line"># 创建 VPN 连接</span><br><span class="line">Add-VpnConnection -Name &#x27;My IPsec VPN&#x27; -ServerAddress &#x27;你的 VPN 服务器 IP&#x27; -L2tpPsk &#x27;你的 VPN IPsec PSK&#x27; -TunnelType L2tp -EncryptionLevel Required -AuthenticationMethod Chap,MSChapv2 -Force -RememberCredential -PassThru</span><br><span class="line"># 忽略 data encryption 警告（数据在 IPsec 隧道中已被加密）</span><br></pre></td></tr></table></figure>

<h5 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h5><p><strong>Windows 错误 809</strong></p>
<blockquote>
<p>错误 809：无法建立计算机与 VPN 服务器之间的网络连接，因为远程服务器未响应。这可能是因为未将计算机与远程服务器之间的某种网络设备(如防火墙、NAT、路由器等)配置为允许 VPN 连接。请与管理员或服务提供商联系以确定哪种设备可能产生此问题。</p>
</blockquote>
<p>要解决此错误，在首次连接之前需要修改一次注册表，以解决 VPN 服务器 和/或 客户端与 NAT （比如家用路由器）的兼容问题。运行以下命令。<strong>完成后必须重启计算机。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Services\PolicyAgent /v AssumeUDPEncapsulationContextOnSendRule /t REG_DWORD /d 0x2 /f</span><br></pre></td></tr></table></figure>

<p>另外，某些个别的 Windows 系统配置禁用了 IPsec 加密，此时也会导致连接失败。要重新启用它，可以运行以下命令并重启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Services\RasMan\Parameters /v ProhibitIpSec /t REG_DWORD /d 0x0 /f</span><br></pre></td></tr></table></figure>

<p><strong>Windows 错误 628 或 766</strong></p>
<blockquote>
<p>错误 628：在连接完成前，连接被远程计算机终止。</p>
</blockquote>
<blockquote>
<p>错误 766：找不到证书。使用通过 IPSec 的 L2TP 协议的连接要求安装一个机器证书。它也叫做计算机证书。</p>
</blockquote>
<p>要解决这些错误，请按以下步骤操作：</p>
<ol>
<li>右键单击系统托盘中的无线/网络图标。</li>
<li>选择 <strong>打开网络和共享中心</strong>。或者，如果你使用 Windows 10 版本 1709 或以上，选择 <strong>打开”网络和 Internet”设置</strong>，然后在打开的页面中单击 <strong>网络和共享中心</strong>。</li>
<li>单击左侧的 <strong>更改适配器设置</strong>。右键单击新的 VPN 连接，并选择 <strong>属性</strong>。</li>
<li>单击 <strong>安全</strong> 选项卡，从 <strong>VPN 类型</strong> 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。</li>
<li>单击 <strong>允许使用这些协议</strong>。选中 “质询握手身份验证协议 (CHAP)” 和 “Microsoft CHAP 版本 2 (MS-CHAP v2)” 复选框。</li>
<li>单击 <strong>高级设置</strong> 按钮。</li>
<li>单击 <strong>使用预共享密钥作身份验证</strong> 并在 <strong>密钥</strong> 字段中输入<code>你的 VPN IPsec PSK</code>。</li>
<li>单击 <strong>确定</strong> 关闭 <strong>高级设置</strong>。</li>
<li>单击 <strong>确定</strong> 保存 VPN 连接的详细信息。</li>
</ol>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/software/vpn/image-20200205172131332.png" alt="image-20200205172131332" style="zoom: 67%;" />

<p>参考文献：</p>
<ul>
<li><a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md</a></li>
<li><a href="https://github.com/hwdsl2/setup-ipsec-vpn">https://github.com/hwdsl2/setup-ipsec-vpn</a></li>
</ul>
]]></content>
      <categories>
        <category>software</category>
        <category>vpn</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis客户端选择</title>
    <url>/2019/09/06/spring/redis-1/</url>
    <content><![CDATA[<h3 id="Redis-客户端的选择"><a href="#Redis-客户端的选择" class="headerlink" title="Redis 客户端的选择"></a>Redis 客户端的选择</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>Jedis：是老牌的Redis的Java实现客户端，提供了比较全面的Redis命令的支持，</p>
</li>
<li><p>Redisson：实现了分布式和可扩展的Java数据结构。</p>
</li>
<li><p>Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。</p>
</li>
</ul>
<span id="more"></span>


<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p>Jedis：比较全面的提供了Redis的操作特性</p>
</li>
<li><p>Redisson：促使使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列</p>
</li>
<li><p>Lettuce：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作</p>
</li>
</ul>
<h4 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h4><ul>
<li><p>Jedis：使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p>
</li>
<li><p>Redisson：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Redisson的API是线程安全的，所以可以操作单个Redisson连接来完成各种操作</p>
</li>
<li><p>Lettuce：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作，lettuce能够支持redis4，需要java8及以上。lettuce是基于netty实现的与redis进行同步和异步的通信。</p>
</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul>
<li>jedis使直接连接redis server,如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个jedis实例增加物理连接 ；</li>
<li>lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，StatefulRedisConnection是线程安全的，所以一个连接实例可以满足多线程环境下的并发访问，当然这也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。</li>
<li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>优先使用Lettuce，如果需要分布式锁，分布式集合等分布式的高级特性，添加Redisson结合使用，因为Redisson本身对字符串的操作支持很差。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring OAuth2基础</title>
    <url>/2019/05/04/spring/spring-oauth2/</url>
    <content><![CDATA[<h3 id="Spring-OAuth2-0-提供者实现原理"><a href="#Spring-OAuth2-0-提供者实现原理" class="headerlink" title="Spring OAuth2.0 提供者实现原理"></a>Spring OAuth2.0 提供者实现原理</h3><p>Spring OAuth2.0提供者实际上分为</p>
<ul>
<li>授权服务 Authorization Service.</li>
<li>资源服务 Resource Service.</li>
</ul>
<p>虽然这两个提供者有时候可能存在同一个应用程序中，但在Spring Security OAuth中你可以把他它们各自放在不同的应用上，而且你可以有多个资源服务，它们共享同一个中央授权服务。</p>
<p>配置一个授权服务必须要实现的endpoints：</p>
<ul>
<li>AuthorizationEndpoint：用来作为请求者获得授权的服务，默认的URL是/oauth/authorize.</li>
<li>TokenEndpoint：用来作为请求者获得令牌（Token）的服务，默认的URL是/oauth/token.</li>
</ul>
<p>配置一个资源服务必须要实现的过滤器：</p>
<ul>
<li>OAuth2AuthenticationProcessingFilter：用来作为认证令牌（Token）的一个处理流程过滤器。只有当过滤器通过之后，请求者才能获得受保护的资源</li>
</ul>
<span id="more"></span>

<h3 id="授权服务配置"><a href="#授权服务配置" class="headerlink" title="授权服务配置"></a>授权服务配置</h3><p>配置一个授权服务，你需要考虑几种授权类型（Grant Type），不同的授权类型为客户端（Client）提供了不同的获取令牌（Token）方式，为了实现并确定这几种授权，需要配置使用 ClientDetailsService 和 TokenService 来开启或者禁用这几种授权机制。到这里就请注意了，不管你使用什么样的授权类型（Grant Type），每一个客户端（Client）都能够通过明确的配置以及权限来实现不同的授权访问机制。这也就是说，假如你提供了一个支持”client_credentials”的授权方式，并不意味着客户端就需要使用这种方式来获得授权。</p>
<ul>
<li>authorization_code：授权码类型。</li>
<li>implicit：隐式授权类型。</li>
<li>password：资源所有者（即用户）密码类型。</li>
<li>client_credentials：客户端凭据（客户端ID以及Key）类型。</li>
<li>refresh_token：通过以上授权获得的刷新令牌来获取新的令牌。</li>
</ul>
<h4 id="配置客户端详情信息"><a href="#配置客户端详情信息" class="headerlink" title="配置客户端详情信息"></a>配置客户端详情信息</h4><p>ClientDetailsServiceConfigurer (AuthorizationServerConfigurer 的一个回调配置项，见上的概述) 能够使用内存或者JDBC来实现客户端详情服务（ClientDetailsService），有几个重要的属性如下列表：</p>
<ul>
<li>clientId：（必须的）用来标识客户的Id。</li>
<li>secret：（需要值得信任的客户端）客户端安全码，如果有的话。</li>
<li>scope：用来限制客户端的访问范围，如果为空（默认）的话，那么客户端拥有全部的访问范围。</li>
<li>authorizedGrantTypes：此客户端可以使用的授权类型，默认为空。</li>
<li>authorities：此客户端可以使用的权限（基于Spring Security authorities）。</li>
</ul>
<h4 id="配置授权类型"><a href="#配置授权类型" class="headerlink" title="配置授权类型"></a>配置授权类型</h4><p>授权是使用 AuthorizationEndpoint 这个端点来进行控制的，你能够使用 AuthorizationServerEndpointsConfigurer 这个对象的实例来进行配置(AuthorizationServerConfigurer 的一个回调配置项，见上的概述) ，如果你不进行设置的话，默认是除了资源所有者密码（password）授权类型以外，支持其余所有标准授权类型的（RFC6749），我们来看一下这个配置对象有哪些属性可以设置吧，如下列表：</p>
<ul>
<li>authenticationManager：认证管理器，当你选择了资源所有者密码（password）授权类型的时候，请设置这个属性注入一个 AuthenticationManager 对象。</li>
<li>userDetailsService：如果啊，你设置了这个属性的话，那说明你有一个自己的 UserDetailsService 接口的实现，或者你可以把这个东西设置到全局域上面去（例如 GlobalAuthenticationManagerConfigurer 这个配置对象），当你设置了这个之后，那么 “refresh_token” 即刷新令牌授权类型模式的流程中就会包含一个检查，用来确保这个账号是否仍然有效，假如说你禁用了这个账户的话。</li>
<li>authorizationCodeServices：这个属性是用来设置授权码服务的（即 AuthorizationCodeServices 的实例对象），主要用于 “authorization_code” 授权码类型模式。</li>
<li>implicitGrantService：这个属性用于设置隐式授权模式，用来管理隐式授权模式的状态。</li>
<li>tokenGranter：这个属性就很牛B了，当你设置了这个东西（即 TokenGranter 接口实现），那么授权将会交由你来完全掌控，并且会忽略掉上面的这几个属性，这个属性一般是用作拓展用途的，即标准的四种授权模式已经满足不了你的需求的时候，才会考虑使用这个。</li>
</ul>
<h4 id="配置授权端点的URL"><a href="#配置授权端点的URL" class="headerlink" title="配置授权端点的URL"></a>配置授权端点的URL</h4><p>AuthorizationServerEndpointsConfigurer 这个配置对象(AuthorizationServerConfigurer 的一个回调配置项，见上的概述) 有一个叫做 pathMapping() 的方法用来配置端点URL链接，它有两个参数：</p>
<ul>
<li>第一个参数：String 类型的，这个端点URL的默认链接。</li>
<li>第二个参数：String 类型的，你要进行替代的URL链接。</li>
</ul>
<p>以上的参数都将以 “/“ 字符为开始的字符串，框架的默认URL链接如下列表，可以作为这个 pathMapping() 方法的第一个参数：</p>
<ul>
<li>/oauth/authorize：授权端点。</li>
<li>/oauth/token：令牌端点。</li>
<li>/oauth/confirm_access：用户确认授权提交端点。</li>
<li>/oauth/error：授权服务错误信息端点。</li>
<li>/oauth/check_token：用于资源服务访问的令牌解析端点。</li>
</ul>
<h3 id="资源服务配置"><a href="#资源服务配置" class="headerlink" title="资源服务配置"></a>资源服务配置</h3><p>一个资源服务（可以和授权服务在同一个应用中，当然也可以分离开成为两个不同的应用程序）提供一些受token令牌保护的资源，Spring OAuth提供者是通过Spring Security authentication filter 即验证过滤器来实现的保护，你可以通过 @EnableResourceServer 注解到一个 @Configuration 配置类上，并且必须使用 ResourceServerConfigurer 这个配置对象来进行配置（可以选择继承自 ResourceServerConfigurerAdapter 然后覆写其中的方法，参数就是这个对象的实例），下面是一些可以配置的属性：</p>
<ul>
<li>tokenServices：ResourceServerTokenServices 类的实例，用来实现令牌服务。</li>
<li>resourceId：这个资源服务的ID，这个属性是可选的，但是推荐设置并在授权服务中进行验证。</li>
<li>其他的拓展属性例如 tokenExtractor 令牌提取器用来提取请求中的令牌。</li>
<li>请求匹配器，用来设置需要进行保护的资源路径，默认的情况下是受保护资源服务的全部路径。</li>
<li>受保护资源的访问规则，默认的规则是简单的身份验证（plain authenticated）。</li>
<li>其他的自定义权限保护规则通过 HttpSecurity 来进行配置。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security基础</title>
    <url>/2019/05/04/spring/spring-security-1/</url>
    <content><![CDATA[<p>最近公司项目使用了Spring Security，下面整理一下基础知识</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个能够为基于Spring的企业应用系统提供声明式的安全訪问控制解决方式的安全框架（简单说是对访问权限进行控制嘛），应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。   </p>
<p>spring security的主要核心功能为 认证和授权，所有的架构也是基于这两个核心功能去实现的。</p>
<span id="more"></span>

<h3 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h3><p>众所周知 想要对对Web资源进行保护，最好的办法莫过于Filter，要想对方法调用进行保护，最好的办法莫过于AOP。所以springSecurity在我们进行用户认证以及授予权限的时候，通过各种各样的拦截器来控制权限的访问，从而实现安全。</p>
<p>如下为其主要过滤器 </p>
<p>| 名称 | 功能<br>|–|<br>|ChannelProcessingFilter|可根据配置进行协议的重定向（HTTP与HTTPS）|<br>|SecurityContextPersistenceFilter|针对每个web请求开始时加载SecurityContext，并在web请求结束时将SecurityContext保存到HttpSession中|<br>|ConcurrentSessionFilter|功能一，刷新session中最后更新时间；功能二，取session信息看是否过期，如果过期执行登出操作。|<br>|UsernamePasswordAuthenticationFilter、CasAuthenticationFilter、BasicAuthenticationFilter、其他|根据需要选择一个合适的认证过滤器|<br>|SecurityContextHolderAwareRequestFilter|servlet相关实现的过滤器|<br>|JaasApiIntegrationFilter|Jaas相关过滤器|<br>|RememberMeAuthenticationFilter|提供“记住我”功能的过滤器|<br>|AnonymousAuthenticationFilter|匿名授权过滤器|<br>|ExceptionTranslationFilter|捕获（Spring Security）产生的异常|<br>|FilterSecurityInterceptor|URL的控制及访问拒绝时产生异常|</p>
<p>框架的核心组件</p>
<p>|名称| 功能|<br>|–|<br>|SecurityContextHolder|提供对SecurityContext的访问|<br>|SecurityContext|持有Authentication对象和其他可能需要的信息|<br>|AuthenticationManager|其中可以包含多个AuthenticationProvider|<br>|ProviderManager|对象为AuthenticationManager接口的实现类|<br>|AuthenticationProvider|主要用来进行认证操作的类 调用其中的authenticate()方法去进行认证操作|<br>|Authentication|Spring Security方式的认证主体|<br>|GrantedAuthority|对认证主题的应用层面的授权，含当前用户的权限信息，通常使用角色表示|<br>|UserDetails|构建Authentication对象必须的信息，可以自定义，可能需要访问DB得到|<br>|UserDetailsService|通过username构建UserDetails对象，通过loadUserByUsername根据userName获取UserDetail对象 （可以在这里基于自身业务进行自定义的实现  如通过数据库，xml,缓存获取等）|</p>
<p>HttpSecurity使用</p>
<p>|名称| 功能|<br>|–|<br>|antMatchers(“/resources/<strong>“, “/signup”, “/about”).permitAll()|任何用户都可以访问以”/resources/“,”/signup”, 或者 “/about”开头的URL。|<br>|antMatchers(“/admin/</strong>“).hasRole(“ADMIN”)|以 “/admin/“ 开头的URL只能让拥有 “ROLE_ADMIN”角色的用户访问。|<br>|antMatchers(“/db/<strong>“).access(“hasRole(‘ADMIN’) and hasRole(‘DBA’)”)     |任何以”/db/“ 开头的URL需要同时具有 “ROLE_ADMIN” 和 “ROLE_DBA”权限的用户才可以访问。|<br>|antMatchers(“/db/</strong>“).hasAnyRole(“ADMIN”, “DBA”)   |任何以”/db/“ 开头的URL只需要拥有 “ROLE_ADMIN” 和 “ROLE_DBA”其中一个权限的用户才可以访问。|<br>|anyRequest().authenticated()|尚未匹配的任何URL都要求用户进行身份验证|<br>|logout().logoutUrl(“/api/user/logout”)|指定登出的url|<br>|defaultSuccessUrl(“/index”)|指定登录成功后跳转到/index页面|<br>|failureUrl(“/login?error”)|指定登录失败后跳转到/login?error页面|<br>|rememberMe().tokenValiditySeconds(1209600).key(“mykey”)|开启cookie储存用户信息，并设置有效期为14天，指定cookie中的密钥|<br>|formLogin().loginPage(“/api/user/login”)|通过formlogin方法登录，并设置登录url为/api/user/login|</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈系统高可用几个9</title>
    <url>/2020/04/09/system/1/</url>
    <content><![CDATA[<h3 id="浅谈系统高可用几个9"><a href="#浅谈系统高可用几个9" class="headerlink" title="浅谈系统高可用几个9"></a>浅谈系统高可用几个9</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>经常看到各种技术文章或者分布式系统介绍说系统的可用性达到了多少个9，那么所谓”几个9“到底是怎么计算的？又意味着什么？我们简单计算分析下看看。所谓”1个9“是指90%，”2个9“是指99%，”3个9“是指99.9%，依次类推。</p>
<p>可用性的反面是故障时间，网站或者分布式系统会因为很多原因导致不可用，比如：程序bug；运维更新错误；环境配置升级变化；机器硬件故障；被恶意攻击；网关不小心踢掉了网线/电源插座；市政施工挖断了光纤；程序猿删库跑路；地震海啸自然灾害等等。</p>
<h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p>如果按照年为单位计算系统的故障时间，公式如下：</p>
<blockquote>
<p>故障时间秒数=(1-可用性) * 365 * 24 * 3600</p>
</blockquote>
<p>计算6个9以内的情况得到如下结果：  </p>
<table>
<thead>
<tr>
<th>可用性指标</th>
<th>计算公式</th>
<th>不可用时间</th>
</tr>
</thead>
<tbody><tr>
<td>99.9%</td>
<td>0.1% * 365 * 24 * 60</td>
<td>525.6分钟</td>
</tr>
<tr>
<td>99.99%</td>
<td>0.01% * 365 * 24 * 60</td>
<td>52.56分钟</td>
</tr>
<tr>
<td>99.999%</td>
<td>0.001% * 365 * 24 * 60</td>
<td>5.256分钟</td>
</tr>
<tr>
<td>99.9999%</td>
<td>0.0001% * 365 * 24 * 60 * 60</td>
<td>31.536秒</td>
</tr>
</tbody></table>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>可见，如果只有1个9的可用性，体验是极其糟糕的，1年下来有1个多月不能使用。一些大型网站号称能过做到4个9，那么1年有52分钟故障时间，其实已经是不错的情况了。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出UML类图（一）</title>
    <url>/2018/03/06/uml/1/</url>
    <content><![CDATA[<p>在UML 2.0的13种图形中，类图是使用频率最高的UML图之一。Martin Fowler在其著作《UML Distilled: A Brief Guide to the Standard Object Modeling Language, Third Edition》（《UML精粹：标准对象建模语言简明指南（第3版）》）中有这么一段：“If someone were to come up to you in a dark alley and say, ‘Psst, wanna see a UML diagram?’ that diagram would probably be a class diagram. The majority of UML diagrams I see are class diagrams.”（“如果有人在黑暗的小巷中向你走来并对你说：‘嘿，想不想看一张UML图？’那么这张图很有可能就是一张类图，我所见过的大部分的UML图都是类图”），由此可见类图的重要性。</p>
<blockquote>
<p>类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</p>
</blockquote>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责。在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。类的属性即类的数据职责，类的操作即类的行为职责。设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。</p>
<p>在软件系统运行时，类将被实例化成对象(Object)，对象对应于某个具体的事物，是类的实例(Instance)。</p>
<p>类图(Class Diagram)使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。</p>
<blockquote>
<p>在系统分析与设计阶段，类通常可以分为三种，分别是实体类(Entity Class)、控制类(Control Class)和边界类(Boundary Class)，下面对这三种类加以简要说明：</p>
</blockquote>
<ul>
<li>实体类：实体类对应系统需求中的每个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，如学生、商品等。</li>
<li>控制类：控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类一般是由动宾结构的短语（动词+名词）转化来的名词，如增加商品对应有一个商品增加类，注册对应有一个用户注册类等。</li>
<li>边界类：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。</li>
</ul>
<p>在面向对象分析和设计的初级阶段，通常首先识别出实体类，绘制初始类图，此时的类图也可称为领域模型，包括实体类及其它们之间的相互关系。</p>
<span id="more"></span>

<h4 id="类的UML图示"><a href="#类的UML图示" class="headerlink" title="类的UML图示"></a>类的UML图示</h4><p>在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，如定义一个Employee类，它包含属性name、age和email，以及操作modifyInfo()，在UML类图中该类如图1所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/1.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图1对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String email;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyInfo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在UML类图中，类一般由三部分组成：</p>
<ol>
<li>第一部分是类名：每个类都必须有一个名字，类名是一个字符串。</li>
<li>第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。<blockquote>
<p>UML规定属性的表示方式为：(可见性  名称:类型 [ = 缺省值 ])<br>其中：</p>
</blockquote>
</li>
</ol>
<ul>
<li>可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。</li>
<li>“名称”表示属性名，用一个字符串表示。</li>
<li>“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。</li>
<li>“缺省值”是一个可选项，即属性的初始值。</li>
</ul>
<ol start="3">
<li>第三部分是类的操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。<blockquote>
<p>UML规定操作的表示方式为：(可见性  名称(参数列表) [ : 返回类型])<br>其中：</p>
</blockquote>
</li>
</ol>
<ul>
<li>“可见性”的定义与属性的可见性定义相同。</li>
<li>“名称”即方法名，用一个字符串表示。</li>
<li>“参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。</li>
<li>“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型。</li>
</ul>
<p>在类图2中，操作method1的可见性为public(+)，带入了一个Object类型的参数par，返回值为空(void)；操作method2的可见性为protected(#)，无参数，返回值为String类型；操作method3的可见性为private(-)，包含两个参数，其中一个参数为int类型，另一个为int[]类型，返回值为int类型。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/2.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>由于在Java语言中允许出现内部类，因此可能会出现包含四个部分的类图，如图3所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/3.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出UML类图（二）</title>
    <url>/2018/03/06/uml/2/</url>
    <content><![CDATA[<h4 id="类与类之间的关系（1）"><a href="#类与类之间的关系（1）" class="headerlink" title="类与类之间的关系（1）"></a>类与类之间的关系（1）</h4><p>在软件系统中，类并不是孤立存在的，类与类之间存在各种关系，对于不同类型的关系，UML提供了不同的表示方式。</p>
<h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等等。在UML类图中，用实线连接有关联关系的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必须的，可以根据需要增加，其目的是使类之间的关系更加明确。</p>
<p>如在一个登录界面类LoginForm中包含一个JButton类型的注册按钮loginButton，它们之间可以表示为关联关系，代码实现时可以在LoginForm中定义一个名为loginButton的属性对象，其类型为JButton。如图1所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/4.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图1对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> JButton loginButton; <span class="comment">//定义为成员变量  </span></span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JButton</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在UML中，关联关系通常又包含如下几种形式：</p>
<h5 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h5><p>默认情况下，关联是双向的。例如：顾客(Customer)购买商品(Product)并拥有商品，反之，卖出的商品总有某个顾客与之相关联。因此，Customer类和Product类之间具有双向关联关系，如图2所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/5.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图2对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> Product[] products;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> Customer customer;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h5><p>类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客(Customer)拥有地址(Address)，则Customer类与Address类具有单向关联关系，如图3所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/6.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图3对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> Address address;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h5><p>在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象，如图4所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/7.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图4对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> Node subNode;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="多重性关联"><a href="#多重性关联" class="headerlink" title="多重性关联"></a>多重性关联</h5><p>多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。</p>
<p>对象之间可以存在多种多重性关联关系，常见的多重性表示方式如表1所示：</p>
<table>
<thead>
<tr>
<th align="left">表示方式</th>
<th align="left">多重性说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1..1</td>
<td align="left">表示另一个类的一个对象只与该类的一个对象有关系</td>
</tr>
<tr>
<td align="left">0..*</td>
<td align="left">表示另一个类的一个对象与该类的零个或多个对象有关系</td>
</tr>
<tr>
<td align="left">1..*</td>
<td align="left">表示另一个类的一个对象与该类的一个或多个对象有关系</td>
</tr>
<tr>
<td align="left">0..1</td>
<td align="left">表示另一个类的一个对象没有或只与该类的一个对象有关系</td>
</tr>
<tr>
<td align="left">m..n</td>
<td align="left">表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</td>
</tr>
</tbody></table>
<p>例如：一个界面(Form)可以拥有零个或多个按钮(Button)，但是一个按钮只能属于一个界面，因此，一个Form类的对象可以与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联，如图5所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/8.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图5对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Form</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> Button[] buttons; <span class="comment">//定义一个集合对象  </span></span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><p>聚合(Aggregation)关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如：汽车发动机(Engine)是汽车(Car)的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系，如图6所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/9.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在代码实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中，图6对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Engine engine;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//构造注入  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.engine = engine;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//设值注入  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.engine = engine;  </span><br><span class="line">&#125;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h5><p>组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如：人的头(Head)与嘴巴(Mouth)，嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，如图7所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/10.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类，图7对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Mouth mouth;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        mouth = <span class="keyword">new</span> Mouth(); <span class="comment">//实例化成员类  </span></span><br><span class="line">    &#125;  </span><br><span class="line">……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouth</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出UML类图（三）</title>
    <url>/2018/03/06/uml/3/</url>
    <content><![CDATA[<h4 id="类与类之间的关系（2）"><a href="#类与类之间的关系（2）" class="headerlink" title="类与类之间的关系（2）"></a>类与类之间的关系（2）</h4><h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>依赖(Dependency)关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如：驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此类Driver依赖类Car，如图1所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/11.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在系统实施阶段，依赖关系通常通过三种方式来实现，第一种也是最常用的一种方式是如图1所示的将一个类的对象作为另一个类中方法的参数，第二种方式是在一个类的方法中将另一个类的对象作为其局部变量，第三种方式是在一个类的方法中调用另一个类的静态方法。图1对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123;  </span><br><span class="line">        car.move();  </span><br><span class="line">    &#125;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>泛化(Generalization)关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。在代码实现时，我们使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字、在C++/C#中使用冒号“：”来实现。例如：Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名(name)和年龄(age)，每一个Student和Teacher也都具有这两个属性，另外Student类增加了属性学号(studentNo)，Teacher类增加了属性教师编号(teacherNo)，Person类的方法包括行走move()和说话say()，Student类和Teacher类继承了这两个方法，而且Student类还新增方法study()，Teacher类还新增方法teach()。如图2所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/12.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>图2对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line"><span class="keyword">protected</span> String name;  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> age;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ……  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//子类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> String studentNo;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//子类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> String teacherNo;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h5><p>在很多面向对象语言中都引入了接口的概念，如Java、C#等，在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。UML中用与类的表示法类似的方式表示接口，如图3所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/13.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如：定义了一个交通工具接口Vehicle，包含一个抽象操作move()，在类Ship和类Car中都实现了该move()操作，不过具体的实现细节将会不一样，如图4所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/14.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>实现关系在编程实现时，不同的面向对象语言也提供了不同的语法，如在Java语言中使用implements关键字，而在C++/C#中使用冒号“：”来实现。图4对应的Java代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ship</span> <span class="keyword">implements</span> <span class="title">Vehicle</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ……  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出UML类图（四）</title>
    <url>/2018/03/06/uml/4/</url>
    <content><![CDATA[<h3 id="实例分析1——登录模块"><a href="#实例分析1——登录模块" class="headerlink" title="实例分析1——登录模块"></a>实例分析1——登录模块</h3><p>某基于C/S的即时聊天系统登录模块功能描述如下：</p>
<blockquote>
<p>用户通过登录界面(LoginForm)输入账号和密码，系统将输入的账号和密码与存储在数据库(User)表中的用户信息进行比较，验证用户输入是否正确，如果输入正确则进入主界面(MainForm)，否则提示“输入错误”。</p>
</blockquote>
<p>根据以上描述绘制初始类图。</p>
<h4 id="参考解决方案："><a href="#参考解决方案：" class="headerlink" title="参考解决方案："></a>参考解决方案：</h4><p>参考类图如下：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/15.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<span id="more"></span>

<p>考虑到系统扩展性，在本实例中引入了抽象数据访问接口IUserDAO，再将具体数据访问对象注入到业务逻辑对象中，可通过配置文件（如XML文件）等方式来实现，将具体的数据访问类类名存储在配置文件中，如果需要更换新的具体数据访问对象，只需修改配置文件即可，原有程序代码无须做任何修改。</p>
<h5 id="类说明"><a href="#类说明" class="headerlink" title="类说明"></a>类说明</h5><table>
<thead>
<tr>
<th align="left">类  名</th>
<th align="left">说  明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoginForm</td>
<td align="left">登录窗口，省略界面组件和按钮事件处理方法（边界类）</td>
</tr>
<tr>
<td align="left">LoginBO</td>
<td align="left">登录业务逻辑类，封装实现登录功能的业务逻辑（控制类）</td>
</tr>
<tr>
<td align="left">IUserDAO</td>
<td align="left">抽象数据访问类接口，声明对User表的数据操作方法，省略除查询外的其他方法（实体类）</td>
</tr>
<tr>
<td align="left">UserDAO</td>
<td align="left">具体数据访问类，实现对User表的数据操作方法，省略除查询外的其他方法（实体类）</td>
</tr>
<tr>
<td align="left">MainForm</td>
<td align="left">主窗口（边界类）</td>
</tr>
</tbody></table>
<h5 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h5><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说  明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoginForm类的LoginForm()方法</td>
<td align="left">LoginForm构造函数，初始化实例成员</td>
</tr>
<tr>
<td align="left">LoginForm类的validate()方法</td>
<td align="left">界面类的验证方法，通过调用业务逻辑类LoginBO的validate()方法实现对用户输入信息的验证</td>
</tr>
<tr>
<td align="left">LoginBO类的validate()方法</td>
<td align="left">业务逻辑类的验证方法，通过调用数据访问类的findUserByAccAndPwd()方法验证用户输入信息的合法性</td>
</tr>
<tr>
<td align="left">LoginBO类的setIUserDAO()方法</td>
<td align="left">Setter方法，在业务逻辑对象中注入数据访问对象（注意：此处针对抽象数据访问类编程）</td>
</tr>
<tr>
<td align="left">IUserDAO接口的findUserByAccAndPwd()方法</td>
<td align="left">业务方法声明，通过用户账号和密码在数据库中查询用户信息，判断该用户身份的合法性</td>
</tr>
<tr>
<td align="left">UserDAO类的findUserByAccAndPwd()方法</td>
<td align="left">业务方法实现，实现在IUserDAO接口中声明的数据访问方法</td>
</tr>
</tbody></table>
<h3 id="实例分析2——注册模块"><a href="#实例分析2——注册模块" class="headerlink" title="实例分析2——注册模块"></a>实例分析2——注册模块</h3><p>某基于Java语言的C/S软件需要提供注册功能，该功能简要描述如下：</p>
<blockquote>
<p>用户通过注册界面(RegisterForm)输入个人信息，用户点击“注册”按钮后将输入的信息通过一个封装用户输入数据的对象(UserDTO)传递给操作数据库的数据访问类，为了提高系统的扩展性，针对不同的数据库可能需要提供不同的数据访问类，因此提供了数据访问类接口，如IUserDAO，每一个具体数据访问类都是某一个数据访问类接口的实现类，如OracleUserDAO就是一个专门用于访问Oracle数据库的数据访问类。</p>
</blockquote>
<p>根据以上描述绘制类图。为了简化类图，个人信息仅包括账号(userAccount)和密码(userPassword)，且界面类无需涉及界面细节元素。</p>
<h4 id="参考解决方案"><a href="#参考解决方案" class="headerlink" title="参考解决方案"></a>参考解决方案</h4><p>在以上功能说明中，可以分析出该系统包括三个类和一个接口，这三个类分别是注册界面类RegisterForm、用户数据传输类UserDTO、Oracle用户数据访问类OracleUserDAO，接口是抽象用户数据访问接口IUserDAO。它们之间的关系如下：</p>
<blockquote>
</blockquote>
<ul>
<li>在RegisterForm中需要使用UserDTO类传输数据且需要使用数据访问类来操作数据库，因此RegisterForm与UserDTO和IUserDAO之间存在关联关系，在RegisterForm中可以直接实例化UserDTO，因此它们之间可以使用组合关联。</li>
<li>由于数据库类型需要灵活更换，因此在RegisterForm中不能直接实例化IUserDAO的子类，可以针对接口IUserDAO编程，再通过注入的方式传入一个IUserDAO接口的子类对象（在本书后续章节中将学习如何具体实现），因此RegisterForm和IUserDAO之间具有聚合关联关系。</li>
<li>OracleUserDAO是实现了IUserDAO接口的子类，因此它们之间具有类与接口的实现关系。</li>
<li>在声明IUserDAO接口的增加用户信息方法addUser()时，需要将在界面类中实例化的UserDTO对象作为参数传递进来，然后取出封装在UserDTO对象中的数据插入数据库，因此addUser()方法的函数原型可以定义为：public boolean addUser(UserDTO user)，在IUserDAO的方法addUser()中将UserDTO类型的对象作为参数，故IUserDAO与UserDTO存在依赖关系。</li>
</ul>
<p>通过以上分析，该实例参考类图如图1所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/16.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意：在绘制类图或其他UML图形时，可以通过注释(Comment)来对图中的符号或元素进行一些附加说明，如果需要详细说明类图中的某一方法的功能或者实现过程，可以使用如图2所示表示方式：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/17.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出UML类图（五）</title>
    <url>/2018/03/06/uml/5/</url>
    <content><![CDATA[<h3 id="实例分析3——售票机控制程序"><a href="#实例分析3——售票机控制程序" class="headerlink" title="实例分析3——售票机控制程序"></a>实例分析3——售票机控制程序</h3><p>某运输公司决定为新的售票机开发车票销售的控制软件。图I给出了售票机的面板示意图以及相关的控制部件。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/18.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>售票机相关部件的作用如下所述：</p>
<ol>
<li>目的地键盘用来输入行程目的地的代码（例如，200表示总站）。</li>
<li>乘客可以通过车票键盘选择车票种类（单程票、多次往返票和座席种类）。</li>
<li>继续/取消键盘上的取消按钮用于取消购票过程，继续按钮允许乘客连续购买多张票。</li>
<li>显示屏显示所有的系统输出和用户提示信息。</li>
<li>插卡口接受MCard（现金卡），硬币口和纸币槽接受现金。</li>
<li>打印机用于输出车票。</li>
<li>所有部件均可实现自检并恢复到初始状态。</li>
<li>现采用面向对象方法开发该系统，使用UML进行建模，绘制该系统的初始类图。</li>
</ol>
<span id="more"></span>

<h4 id="参考解决方案"><a href="#参考解决方案" class="headerlink" title="参考解决方案"></a>参考解决方案</h4><p>参考类图如下：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/uml/19.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>类说明：</p>
<table>
<thead>
<tr>
<th align="left">类  名</th>
<th align="left">说  明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Component</td>
<td align="left">抽象部件类，所有部件类的父类</td>
</tr>
<tr>
<td align="left">Keyboard</td>
<td align="left">抽象键盘类</td>
</tr>
<tr>
<td align="left">ActionKeyboard</td>
<td align="left">继续/取消键盘类</td>
</tr>
<tr>
<td align="left">TicketKindKeyboard</td>
<td align="left">车票种类键盘类</td>
</tr>
<tr>
<td align="left">DestinationKeyboard</td>
<td align="left">目的地键盘类</td>
</tr>
<tr>
<td align="left">Screen</td>
<td align="left">显示屏类</td>
</tr>
<tr>
<td align="left">CardDriver</td>
<td align="left">卡驱动器类</td>
</tr>
<tr>
<td align="left">CashSlot</td>
<td align="left">现金（硬币/纸币）槽类</td>
</tr>
<tr>
<td align="left">Printer</td>
<td align="left">打印机类</td>
</tr>
<tr>
<td align="left">TicketSoldSystem</td>
<td align="left">售票系统类</td>
</tr>
</tbody></table>
<p>方法说明：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说  明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Component 的init()方法</td>
<td align="left">初始化部件</td>
</tr>
<tr>
<td align="left">Component 的doSeltTest()方法</td>
<td align="left">自检</td>
</tr>
<tr>
<td align="left">Keyboard的getSelectedKey()方法</td>
<td align="left">获取按键值</td>
</tr>
<tr>
<td align="left">ActionKeyboard的getAction()方法</td>
<td align="left">继续/取消键盘事件处理</td>
</tr>
<tr>
<td align="left">TicketKindKeyboard的getTicketKind()方法</td>
<td align="left">车票种类键盘事件处理</td>
</tr>
<tr>
<td align="left">DestinationKeyboard的getDestinationCode()方法</td>
<td align="left">目的地键盘事件处理</td>
</tr>
<tr>
<td align="left">Screen的showText()方法</td>
<td align="left">显示信息</td>
</tr>
<tr>
<td align="left">CardDriver的getCredit()方法</td>
<td align="left">获取金额</td>
</tr>
<tr>
<td align="left">CardDriver的debitFare()方法</td>
<td align="left">更新卡余额</td>
</tr>
<tr>
<td align="left">CardDriver的ejectMCard()方法</td>
<td align="left">退卡</td>
</tr>
<tr>
<td align="left">CashSlot的getCredit()方法</td>
<td align="left">获取金额</td>
</tr>
<tr>
<td align="left">Printer的printTicket()方法</td>
<td align="left">打印车票</td>
</tr>
<tr>
<td align="left">Printer的ejectTicket()方法</td>
<td align="left">出票</td>
</tr>
<tr>
<td align="left">TicketSoldSystem的verifyCredit()方法</td>
<td align="left">验证金额</td>
</tr>
<tr>
<td align="left">TicketSoldSystem的calculateFare()方法</td>
<td align="left">计算费用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox建立软链接</title>
    <url>/2018/02/05/virtualbox/1/</url>
    <content><![CDATA[<h4 id="VirtualBox共享目录，建立软链接"><a href="#VirtualBox共享目录，建立软链接" class="headerlink" title="VirtualBox共享目录，建立软链接"></a>VirtualBox共享目录，建立软链接</h4><ol>
<li><p>关闭 VirtualBox。</p>
</li>
<li><p>将VirtualBox安装目录的路径加入系统环境变量PATH中。</p>
</li>
<li><p>打开命令行窗口，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VBoxManage setextradata &#123;YOURVMNAME&#125;</span><br><span class="line">VBoxInternal2/SharedFoldersEnableSymlinksCreate/&#123;YOURSHAREFOLDERNAME&#125; 1  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明<br>YOURVMNAME：为虚拟机中ubuntu系统的名<br>YOURSHAREFOLDERNAME：为共享的目录名称</p>
</blockquote>
</li>
<li><p>“以管理者身份运行” VirtualBox　即可！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>VirtualBox</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s安装</title>
    <url>/2019/06/18/docker/k8s/1/</url>
    <content><![CDATA[<h2 id="K8S安装"><a href="#K8S安装" class="headerlink" title="K8S安装"></a>K8S安装</h2><p>Kubernetes支持在物理服务器或虚拟机中运行，本次使用虚拟机准备测试环境，硬件配置信息如表所示</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th>节点角色</th>
<th>Hostname</th>
</tr>
</thead>
<tbody><tr>
<td>172.24.2.69</td>
<td>master</td>
<td>k8s-master</td>
</tr>
<tr>
<td>172.24.2.71</td>
<td>worker</td>
<td>k8s-node-1</td>
</tr>
<tr>
<td>172.24.2.70</td>
<td>worker</td>
<td>k8s-node-2</td>
</tr>
</tbody></table>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1、设置主机名hostname，管理节点设置主机名为 k8s-master 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname k8s-master</span><br></pre></td></tr></table></figure>


<p>2、关闭防火墙、selinux和swap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &quot;s/^SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>

<p>3、配置内核参数，将桥接的IPv4流量传递到iptables的链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>4、配置国内yum源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br><span class="line"></span><br><span class="line">mkdir /etc/yum.repos.d/bak &amp;&amp; mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line"></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure>

<p>5、配置国内Kubernetes源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>6、配置 docker 源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>



<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>1、安装docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-18.06.1.ce-3.el7</span><br><span class="line"></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line"></span><br><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<p>2、安装kubeadm、kubelet、kubectl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install kubelet-1.14.3-0 kubeadm-1.14.3-0 kubectl-1.14.3-0</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>



<h3 id="部署启动"><a href="#部署启动" class="headerlink" title="部署启动"></a>部署启动</h3><p>1、在master进行Kubernetes集群初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=1.14.3 --image-repository registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<p>2、配置kubectl工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/.kube</span><br><span class="line">cp /etc/kubernetes/admin.conf /root/.kube/config</span><br><span class="line"></span><br><span class="line">kubectl get nodes</span><br><span class="line">kubectl get cs</span><br></pre></td></tr></table></figure>

<p>3、部署flannel网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>



<h3 id="子节点部署"><a href="#子节点部署" class="headerlink" title="子节点部署"></a>子节点部署</h3><p>1、设置子节点的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname k8s-node-1</span><br></pre></td></tr></table></figure>



<p>2、子节点可以继续执行主节点中（环境准备、软件安装）</p>
<p>3、将子节点加入到主节点中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.24.2.69:6443 --token 94zry6.lzob4h452am02f0d \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:bf8e4fcdbf4001cafe5ab5325e429dcb3f8a52a836d0a6b80f683db506611043</span><br></pre></td></tr></table></figure>

<p>4、如果当token过期了，可以使用下面命令重新生成token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token create</span><br></pre></td></tr></table></figure>


<h3 id="集群状态检查"><a href="#集群状态检查" class="headerlink" title="集群状态检查"></a>集群状态检查</h3><p>在master节点输入命令检查集群状态，返回如下结果则集群状态正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-master   Ready    master   7d6h   v1.14.3</span><br><span class="line">k8s-node-1   Ready    &lt;none&gt;   7d5h   v1.14.3</span><br><span class="line">k8s-node-2   Ready    &lt;none&gt;   100s   v1.14.3</span><br></pre></td></tr></table></figure>

<p>参考文献：<a href="https://www.kubernetes.org.cn/5462.html">https://www.kubernetes.org.cn/5462.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下访问K8S集群中的POD</title>
    <url>/2019/11/13/docker/k8s/2/</url>
    <content><![CDATA[<h3 id="Windows下访问K8S集群中的POD"><a href="#Windows下访问K8S集群中的POD" class="headerlink" title="Windows下访问K8S集群中的POD"></a>Windows下访问K8S集群中的POD</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>近期在公司搭建了一个K8s集群，有一个项目使用了spring cloud框架做开发，在部署的时候发现一个问题。所有的微服务打包后运行在集群上，互相是可以通过feign进行访问的，这点没问题。但如果需要在本地调试，发现在集群中部署的应用无法反向访问本地应用，下面是我解决的具体方法。</p>
<span id="more"></span>

<h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h4><p>K8s的安装和配置就不在这里具体说明了，将master中的k8s代理启动好，执行下面脚本。</p>
<p>启动脚本：<code>proxy-start.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /bin/sh</span></span><br><span class="line"></span><br><span class="line">kubectl proxy --address 0.0.0.0 --accept-hosts &#x27;.*&#x27;</span><br></pre></td></tr></table></figure>

<p>停止脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /bin/sh</span></span><br><span class="line"></span><br><span class="line">pid=$(ps -ef|grep &#x27;kubectl proxy --address 0.0.0.0 --accept-hosts .*&#x27; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">kill -9 $pid</span><br></pre></td></tr></table></figure>

<p>测试地址：<code>http://&#123;IP地址&#125;:8001/api/v1/namespaces/default/services</code></p>
<h4 id="应用部署说明"><a href="#应用部署说明" class="headerlink" title="应用部署说明"></a>应用部署说明</h4><table>
<thead>
<tr>
<th>应用名称</th>
<th>部署位置</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>k8s</td>
</tr>
<tr>
<td>Api-Gateway</td>
<td>k8s</td>
</tr>
<tr>
<td>SSO-Login</td>
<td>k8s</td>
</tr>
<tr>
<td>Auth-Service</td>
<td>本地</td>
</tr>
</tbody></table>
<h4 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h4><p><strong>准备工作</strong></p>
<p>在本地环境中我们先下载<a href="https://storage.googleapis.com/kubernetes-release/release/v1.16.0/bin/windows/amd64/kubectl.exe">kubectl</a>和<a href="https://github.com/txn2/kubefwd/releases/download/1.9.6/kubefwd_windows_amd64.zip">kubefwd</a>工具，并在当前windows用户下创建一个<code>.kube</code>文件，我这里的地址是<code>C:\Users\13966\.kube</code></p>
<p><strong>配置kubectl</strong></p>
<p>在windows的cmd中使用命令配置k8s远程环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl config set-cluster &#123;cluster_name&#125; --server=https://master_ip:8001 --insecure-skip-tls-verify=true</span><br><span class="line">kubectl config set-context &#123;cluster_name&#125;-context --cluster=&#123;cluster_name&#125;</span><br><span class="line">kubectl config set-credentials &#123;cluster_name&#125;-user --token=&#123;token&#125;</span><br><span class="line">kubectl config set-context &#123;cluster_name&#125;-context --user=&#123;cluster_name&#125;-user --namespace=default</span><br><span class="line">kubectl config use-context &#123;cluster_name&#125;-context</span><br></pre></td></tr></table></figure>

<p>配置好后会在<code>C:\Users\13966\.kube</code>下生成一个config文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">insecure-skip-tls-verify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">server:</span> &#123;<span class="string">远程K8S代理API地址</span>&#125;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">neusoft-cluster</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">neusoft-cluster</span></span><br><span class="line">    <span class="attr">namespace:</span> &#123;<span class="string">访问的命名空间</span>&#125;</span><br><span class="line">    <span class="attr">user:</span> <span class="string">neusoft-cluster-user</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">neusoft-cluster-context</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">neusoft-cluster-context</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">neusoft-cluster-user</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">token:</span> &#123;<span class="string">自己的Token</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里我们就可以使用k8s的命令来验证是否能连上远程代理</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191113165954.png" alt="微信截图_20191113165954"></p>
<p>这只是将windows和k8s打通了，还不能直接访问pod。我们还需要使用kubefwd软件，执行命令。</p>
<p><strong>配置kubefwd</strong></p>
<p>使用官方给的命令<code>.\kubefwd.exe services -n default</code>，这时就会看到下图，就说明我们本地能进行访问pods了</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/微信截图_20191113170256.png" alt="微信截图_20191113170256" style="zoom:60%;" />

<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/微信截图_20191113170443.png" alt="微信截图_20191113170443" style="zoom:60%;" />

<p>使用<code>curl -i </code>来验证是否本地能访问，到这里windows中访问k8s集群的pod就完成了</p>
<h4 id="Eureka本地远程互相访问"><a href="#Eureka本地远程互相访问" class="headerlink" title="Eureka本地远程互相访问"></a>Eureka本地远程互相访问</h4><p>有了之前的一些配置后，只是打通了本地访问pod的问题，如果通过eureka进行转发还是会存在无法访问的情况，那么我们还需要在各个工程中设置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭IP注册方式</span></span><br><span class="line"><span class="string">eureka.instance.prefer-ip-address</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个微服务设置hostname</span></span><br><span class="line"><span class="string">eureka.instance.hostname</span> <span class="string">=</span> <span class="string">hype-auth-service-svc</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：hostname的名称必须要和k8s中<code>Service.metadata.name</code>一致，本地需要调试的工程无需进行设置，将ip注册方式打开就可以了。</strong></p>
<p><strong>参考文献</strong></p>
<ul>
<li>github：<a href="txn2/kubefwd">https://github.com/txn2/kubefwd</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/SSBS6K_3.1.0/manage_cluster/cfc_cli.html">IBM的从Kubectl Cli访问集群</a></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S-证书过期问题</title>
    <url>/2020/06/17/docker/k8s/3/</url>
    <content><![CDATA[<h2 id="K8S-证书过期问题"><a href="#K8S-证书过期问题" class="headerlink" title="K8S-证书过期问题"></a>K8S-证书过期问题</h2><p>最近在开发环境中，在<code>master</code>使用<code>kubectl get pods</code>命令，发现报<code>The connection to the server 172.24.2.69:6443 was refused - did you specify the right host or port?</code>经过不断的百度和google终于把问题解决了，但网上的文章都很片面，没有具体说明处理的整个过程，下面说明一下我在整个解决问题的过程，我使用的k8s版本是1.14.1。</p>
<span id="more"></span>


<h3 id="找到问题"><a href="#找到问题" class="headerlink" title="找到问题"></a>找到问题</h3><p>1、执行<code>systemctl status kubelet</code>，看一下<code>kuberntes</code>是否启动正常，这个时候如果显示<code>Unit kubelet.service entered failed state.</code>句话，说明服务没有启动，有错误。</p>
<p>2、执行<code>journalctl -xefu kubelet</code>，查看<code>kubernets</code>中具体报错原因，在我这里显示的是<code>Part of the existing bootstrap client certificate is expired: 2020-06-16 05:56:48 +0000 UTC</code>，证书已经过期了。</p>
<p>3、使用以下命令，查看所有证书过期时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for item in `find /etc/kubernetes/pki -maxdepth 2 -name &quot;*.crt&quot;`;do openssl x509 -in $item -text -noout| grep Not;echo ======================$item===============;done</span><br></pre></td></tr></table></figure>

<p>or 也可以单独查看某一个证书过期时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -noout -dates -in /etc/kubernetes/pki/apiserver.crt</span><br></pre></td></tr></table></figure>



<p><strong>注意巨坑</strong>：<code>Kuberntes</code>里面有很多证书，其中有些证书失效时间是10年，有些证书是1年，我安装的正好到了时间，所以爆出了证书过期，现在看一下如何解决</p>
<h3 id="解决证书问题"><a href="#解决证书问题" class="headerlink" title="解决证书问题"></a>解决证书问题</h3><p><strong>修改源码，调整过期时间</strong></p>
<p>1、克隆源码，切换到对应的分支，并修改源码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/kubernetes/kubernetes.git</span><br><span class="line">git checkout -b remotes/origin/release-1.14.1  v1.14.1</span><br><span class="line">vi kubernetes/cmd/kubeadm/app/util/pkiutil/pki_helpers.go</span><br></pre></td></tr></table></figure>

<p>将<code>NotAfter:     time.Now().Add(duration365d).UTC(),</code>修改为<code>NotAfter:     time.Now().Add(duration365d * 10).UTC(),</code></p>
<p>2、下载go语言编译环境，并编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -v &#123;源码路径&#125;:/go/src/k8s.io/kubernetes -it icyboy/k8s_build:v1.14.1 bash</span><br><span class="line">cd /go/src/k8s.io/kubernetes</span><br><span class="line">make all WHAT=cmd/kubeadm GOFLAGS=-v</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>



<p>3、替换本地的<code>kubeadm</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/bin/kubeadm /usr/bin/kubeadm-bak</span><br><span class="line">ln -s kubernetes/_output/local/bin/linux/amd64/kubeadm /usr/bin/kubeadm</span><br></pre></td></tr></table></figure>



<p>4、查看是否替换成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm version</span><br><span class="line"></span><br><span class="line">新的</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;14+&quot;, GitVersion:&quot;v1.14.1-dirty&quot;, GitCommit:&quot;b7394102d6ef778017f2ca4046abbaa23b88c290&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2020-06-17T08:02:51Z&quot;, GoVersion:&quot;go1.12.1&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line"></span><br><span class="line">旧的</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;14+&quot;, GitVersion:&quot;v1.14.1&quot;, GitCommit:&quot;b7394102d6ef778017f2ca4046abbaa23b88c290&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2020-06-17T08:02:51Z&quot;, GoVersion:&quot;go1.12.1&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建新证书，重新载入</strong></p>
<p>1、创建<code>kubeadm.conf</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch kubeadm.conf</span><br><span class="line"></span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta1</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.14.3			## 注意：这个是你k8s的版本号</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>

<p>2、生成证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r /etc/kubernetes /etc/kubernetes-bak</span><br><span class="line">rm -rf /etc/kubernetes/pki</span><br><span class="line">kubeadm alpha certs renew all --config=~/kubeadm.conf</span><br></pre></td></tr></table></figure>

<p>3、查看证书过期时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for item in `find /etc/kubernetes/pki -maxdepth 2 -name &quot;*.crt&quot;`;do openssl x509 -in $item -text -noout| grep Not;echo ======================$item===============;done</span><br></pre></td></tr></table></figure>

<p>4、重新载入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面这几个文件，必须删了（后面会自动生成），不然会显示已存在，无法载入</span></span><br><span class="line">rm -rf /etc/kubernetes/admin.conf</span><br><span class="line">rm -rf /etc/kubernetes/kubelet.conf</span><br><span class="line">rm -rf /etc/kubernetes/controller-manager.conf</span><br><span class="line">rm -rf /etc/kubernetes/scheduler.conf</span><br><span class="line"></span><br><span class="line">kubeadm init phase kubeconfig all</span><br></pre></td></tr></table></figure>

<p>5、重启<code>kuberntes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<p>每一个版本解决思路不太一样，其他版本可以参考文献：<a href="http://team.jiunile.com/blog/2018/12/k8s-kubeadm-ca-upgdate.html">http://team.jiunile.com/blog/2018/12/k8s-kubeadm-ca-upgdate.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S部署ELK管理集群日志（一）</title>
    <url>/2021/01/15/docker/k8s/K8S%E9%83%A8%E7%BD%B2ELK%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97-1/</url>
    <content><![CDATA[<blockquote>
<p>前言：ELK是目前主流的日志解决方案，尤其是容器化集群的今天，ELK几乎是集群必备的一部分能力；ELK在K8S落地有多种组合模式：<br>比如：fluentd+ELK或filebeat+ELK或log-pilot+ELK<br>而本文采用的是功能更强大的后者：filebeat 采集—&gt;logstash过滤加工—&gt;ES存储与索引—&gt;Kibana展示的方案。</p>
</blockquote>
<h3 id="ElasticSearch-集群安装"><a href="#ElasticSearch-集群安装" class="headerlink" title="ElasticSearch 集群安装"></a>ElasticSearch 集群安装</h3><p>要建立一个 Elastic 技术的监控栈，当然首先我们需要部署 ElasticSearch，它是用来存储所有的指标、日志和追踪的数据库，这里我们通过3个不同角色的可扩展的节点组成一个集群。</p>
<span id="more"></span>

<h4 id="安装-ElasticSearch-主节点"><a href="#安装-ElasticSearch-主节点" class="headerlink" title="安装 ElasticSearch 主节点"></a>安装 ElasticSearch 主节点</h4><p>设置集群的第一个节点为 Master 主节点，来负责控制整个集群。首先创建一个 ConfigMap 对象，用来描述集群的一些配置信息，以方便将 ElasticSearch 的主节点配置到集群中并开启安全认证功能。对应的资源清单文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-master.configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-master-config</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">elasticsearch.yml:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    cluster.name: $&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="string">    node.name: $&#123;NODE_NAME&#125;</span></span><br><span class="line"><span class="string">    discovery.seed_hosts: $&#123;NODE_LIST&#125;</span></span><br><span class="line"><span class="string">    cluster.initial_master_nodes: $&#123;MASTER_NODES&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">node:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">data:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">ingest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 是否开启验证</span></span><br><span class="line">    <span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xpack.monitoring.collection.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后创建一个 Service 对象，在 Master 节点下，我们只需要通过用于集群通信的 9300 端口进行通信。资源清单文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-master.service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9300</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">transport</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>最后使用一个 Deployment 对象来定义 Master 节点应用，资源清单文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-master.deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-chengdu.aliyuncs.com/zhouqi-kubernetes/es:7.6.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CLUSTER_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_LIST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master,elasticsearch-data,elasticsearch-client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MASTER_NODES</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ES_JAVA_OPTS&quot;</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;-Xms512m -Xmx512m&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9300</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">transport</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">elasticsearch.yml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">elasticsearch-master-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;storage&quot;</span></span><br><span class="line">        <span class="attr">emptyDir:</span></span><br><span class="line">          <span class="attr">medium:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="安装-ElasticSearch-数据节点"><a href="#安装-ElasticSearch-数据节点" class="headerlink" title="安装 ElasticSearch 数据节点"></a>安装 ElasticSearch 数据节点</h4><p>现在我们需要安装的是集群的数据节点，它主要来负责集群的数据托管和执行查询。和 master 节点一样，我们使用一个 ConfigMap 对象来配置我们的数据节点：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-data.configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-data-config</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">elasticsearch.yml:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    cluster.name: $&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="string">    node.name: $&#123;NODE_NAME&#125;</span></span><br><span class="line"><span class="string">    discovery.seed_hosts: $&#123;NODE_LIST&#125;</span></span><br><span class="line"><span class="string">    cluster.initial_master_nodes: $&#123;MASTER_NODES&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">node:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">data:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">ingest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 是否开启验证</span></span><br><span class="line">    <span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xpack.monitoring.collection.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到和上面的 master 配置非常类似，不过需要注意的是属性 node.data=true。</p>
<p>同样只需要通过 9300 端口和其他节点进行通信：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-data.service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9300</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">transport</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">data</span></span><br></pre></td></tr></table></figure>

<p>最后创建一个 StatefulSet 的控制器，因为可能会有多个数据节点，每一个节点的数据不是一样的，需要单独存储，所以也使用了一个 volumeClaimTemplates 来分别创建存储卷，对应的资源清单文件如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NFS挂载</span></span><br><span class="line"><span class="comment">#kind: PersistentVolumeClaim</span></span><br><span class="line"><span class="comment">#apiVersion: v1</span></span><br><span class="line"><span class="comment">#metadata:</span></span><br><span class="line"><span class="comment">#  name: elasticsearch-data-claim</span></span><br><span class="line"><span class="comment">#  namespace: kube-system</span></span><br><span class="line"><span class="comment">#  annotations:</span></span><br><span class="line"><span class="comment">#    volume.beta.kubernetes.io/storage-class: &quot;managed-nfs-storage&quot;</span></span><br><span class="line"><span class="comment">#spec:</span></span><br><span class="line"><span class="comment">#  storageClassName: managed-nfs-storage</span></span><br><span class="line"><span class="comment">#  accessModes:</span></span><br><span class="line"><span class="comment">#    - ReadWriteMany</span></span><br><span class="line"><span class="comment">#  resources:</span></span><br><span class="line"><span class="comment">#    requests:</span></span><br><span class="line"><span class="comment">#      storage: 1G</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;elasticsearch-data&quot;</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-chengdu.aliyuncs.com/zhouqi-kubernetes/es:7.6.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CLUSTER_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-data</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_LIST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master,elasticsearch-data,elasticsearch-client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MASTER_NODES</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ES_JAVA_OPTS&quot;</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;-Xms1024m -Xmx1024m&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9300</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">transport</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">elasticsearch.yml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch-data-persistent-storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data/db</span>          </span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">elasticsearch-data-config</span></span><br><span class="line"><span class="comment"># NFS挂载          </span></span><br><span class="line"><span class="comment">#      - name: elasticsearch-data-persistent-storage</span></span><br><span class="line"><span class="comment">#        persistentVolumeClaim:</span></span><br><span class="line"><span class="comment">#          claimName: elasticsearch-data-claim</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">elasticsearch-data-persistent-storage</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">volume.beta.kubernetes.io/storage-class:</span> <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span>   </span><br></pre></td></tr></table></figure>

<h4 id="安装-ElasticSearch-客户端节点"><a href="#安装-ElasticSearch-客户端节点" class="headerlink" title="安装 ElasticSearch 客户端节点"></a>安装 ElasticSearch 客户端节点</h4><p>最后来安装配置 ElasticSearch 的客户端节点，该节点主要负责暴露一个 HTTP 接口将查询数据传递给数据节点获取数据。同样使用一个 ConfigMap 对象来配置该节点：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-client.configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-client-config</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">elasticsearch.yml:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    cluster.name: $&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="string">    node.name: $&#123;NODE_NAME&#125;</span></span><br><span class="line"><span class="string">    discovery.seed_hosts: $&#123;NODE_LIST&#125;</span></span><br><span class="line"><span class="string">    cluster.initial_master_nodes: $&#123;MASTER_NODES&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">node:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">data:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">ingest:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xpack.monitoring.collection.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>客户端节点需要暴露两个端口，9300端口用于与集群的其他节点进行通信，9200端口用于 HTTP API。对应的 Service 对象如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-client.service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-client</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30008</span>   <span class="comment"># NodePort     </span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9300</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">transport</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>       </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">client</span></span><br></pre></td></tr></table></figure>

<p>使用一个 Deployment 对象来描述客户端节点：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch-client.deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elasticsearch-client</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">client</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch-client</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-chengdu.aliyuncs.com/zhouqi-kubernetes/es:7.6.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CLUSTER_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_LIST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master,elasticsearch-data,elasticsearch-client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MASTER_NODES</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">elasticsearch-master</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ES_JAVA_OPTS&quot;</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;-Xms256m -Xmx256m&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9200</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9300</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">transport</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">elasticsearch.yml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">elasticsearch-client-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;storage&quot;</span></span><br><span class="line">        <span class="attr">emptyDir:</span></span><br><span class="line">          <span class="attr">medium:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h4><p>我们启用了 xpack 安全模块来保护我们的集群，所以我们需要一个初始化的密码。我们可以执行如下所示的命令，在客户端节点容器内运行 <code>bin/elasticsearch-setup-passwords</code> 命令来生成默认的用户名和密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> $(kubectl get pods -n kube-system | grep elasticsearch-client | sed -n 1p | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>) \</span></span><br><span class="line"><span class="bash">    -n elastic \</span></span><br><span class="line"><span class="bash">    -- bin/elasticsearch-setup-passwords auto -b</span></span><br><span class="line"></span><br><span class="line">Changed password for user apm_system</span><br><span class="line">PASSWORD apm_system = 3Lhx61s6woNLvoL5Bb7t</span><br><span class="line"></span><br><span class="line">Changed password for user kibana_system</span><br><span class="line">PASSWORD kibana_system = NpZv9Cvhq4roFCMzpja3</span><br><span class="line"></span><br><span class="line">Changed password for user kibana</span><br><span class="line">PASSWORD kibana = NpZv9Cvhq4roFCMzpja3</span><br><span class="line"></span><br><span class="line">Changed password for user logstash_system</span><br><span class="line">PASSWORD logstash_system = nNnGnwxu08xxbsiRGk2C</span><br><span class="line"></span><br><span class="line">Changed password for user beats_system</span><br><span class="line">PASSWORD beats_system = fen759y5qxyeJmqj6UPp</span><br><span class="line"></span><br><span class="line">Changed password for user remote_monitoring_user</span><br><span class="line">PASSWORD remote_monitoring_user = mCP77zjCATGmbcTFFgOX</span><br><span class="line"></span><br><span class="line">Changed password for user elastic</span><br><span class="line">PASSWORD elastic = wmxhvsJFeti2dSjbQEAH</span><br></pre></td></tr></table></figure>

<p>注意需要将 elastic 用户名和密码也添加到 Kubernetes 的 Secret 对象中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret generic elasticsearch-pw-elastic \</span></span><br><span class="line"><span class="bash">    -n kube-system \</span></span><br><span class="line"><span class="bash">    --from-literal password=wmxhvsJFeti2dSjbQEAH</span></span><br><span class="line">secret/elasticsearch-pw-elastic created</span><br></pre></td></tr></table></figure>
<h4 id="常用查询"><a href="#常用查询" class="headerlink" title="常用查询"></a>常用查询</h4><ul>
<li><p>校验节点是否正常<code>http://ip:9200/_cat/nodes?pretty</code><br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/es/1.png"></p>
</li>
<li><p>查看ES信息`<a href="http://ip:9200/">http://ip:9200</a><br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/es/2.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
        <category>elk</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S部署ELK管理集群日志（二）</title>
    <url>/2021/01/15/docker/k8s/K8S%E9%83%A8%E7%BD%B2ELK%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97-2/</url>
    <content><![CDATA[<blockquote>
<p>上一篇文章讲述了k8s安装ES集群的方式，本章接着讲解K8S安装Kibana</p>
</blockquote>
<h3 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h3><p>ElasticSearch 集群安装完成后，接着我们可以来部署 Kibana，这是 ElasticSearch 的数据可视化工具，它提供了管理 ElasticSearch 集群和可视化数据的各种功能。</p>
<p>同样首先我们使用 ConfigMap 对象来提供一个文件文件，其中包括对 ElasticSearch 的访问（主机、用户名和密码），这些都是通过环境变量配置的。对应的资源清单文件如下所示：</p>
<span id="more"></span>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kibana.configmap.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana-config</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">kibana.yml:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    server.host: 0.0.0.0</span></span><br><span class="line"><span class="string"></span><span class="comment"># 中文</span></span><br><span class="line"><span class="comment">#    i18n.locale: &quot;zh-CN&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">hosts:</span> <span class="string">$&#123;ELASTICSEARCH_HOSTS&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">$&#123;ELASTICSEARCH_USER&#125;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;ELASTICSEARCH_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后通过一个 NodePort 类型的服务来暴露 Kibana 服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kibana.service.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">webinterface</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br></pre></td></tr></table></figure>

<p>最后通过 Deployment 来部署 Kibana 服务，由于需要通过环境变量提供密码，这里我们使用上面创建的 Secret 对象来引用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kibana.deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-chengdu.aliyuncs.com/zhouqi-kubernetes/kibana:7.6.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5601</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">webinterface</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_HOSTS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;http://elasticsearch-client.kube-system.svc.cluster.local:9200&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_USER</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;elastic&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">elasticsearch-pw-elastic</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">kibana.yml</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kibana-config</span></span><br></pre></td></tr></table></figure>

<p>如下图所示，使用上面我们创建的 Secret 对象的 elastic 用户和生成的密码即可登录：<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/1.png"></p>
<p>登录成功后会自动跳转到 Kibana 首页：<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/2.png"></p>
<p>同样也可以自己创建一个新的超级用户，Management → Stack Management → Create User：<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/3.png"></p>
<p>使用新的用户名和密码，选择 superuser 这个角色来创建新的用户：<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/4.png"></p>
<p>创建成功后就可以使用上面新建的用户登录 Kibana，最后还可以通过 Management → Stack Monitoring 页面查看整个集群的健康状态：<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/5.png"></p>
<p>到这里我们就安装成功了 ElasticSearch 与 Kibana，它们将为我们来存储和可视化我们的应用数据（监控指标、日志和追踪）服务。</p>
<p>在下一篇文章中，我们将来学习如何安装和配置Logstash与Filebeat，通过 Filebeat 来收集指标监控 Spring Boot中的日志。</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
        <category>elk</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S部署ELK管理集群日志（三）</title>
    <url>/2021/01/15/docker/k8s/K8S%E9%83%A8%E7%BD%B2ELK%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97-3/</url>
    <content><![CDATA[<blockquote>
<p>上一篇文章讲述了k8s安装Kibana，本章接着讲解K8S安装Logstash与Filebeat</p>
</blockquote>
<h3 id="Logstash和Filebeat安装"><a href="#Logstash和Filebeat安装" class="headerlink" title="Logstash和Filebeat安装"></a>Logstash和Filebeat安装</h3><p>在使用k8s安装Logstash时，先在本地做测试配置，如果已经非常熟悉的，就可以将这个步骤省略</p>
<h4 id="Windows安装Logstash"><a href="#Windows安装Logstash" class="headerlink" title="Windows安装Logstash"></a>Windows安装Logstash</h4><ol>
<li>去官方下载Windows版本的<a href="https://www.elastic.co/cn/downloads/past-releases/logstash-7-6-1">Logstash</a>，将ZIP文件解压，变成下面的目录结构</li>
</ol>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/logstash/1.png" style="zoom: 67%;" />

<span id="more"></span>

<ol start="2">
<li>进入bin文件夹中新建一个logstash.conf配置文件，并进行编辑，内容如下</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考官方文档：https://www.elastic.co/guide/en/logstash/current/plugins-inputs-beats.html</span></span><br><span class="line"><span class="comment"># 输入</span></span><br><span class="line"><span class="string">input</span> &#123;	</span><br><span class="line">    <span class="string">beats</span>&#123;</span><br><span class="line">		<span class="comment"># 接受数据端口</span></span><br><span class="line">		<span class="string">port</span> <span class="string">=&gt;</span> <span class="string">&quot;5044&quot;</span></span><br><span class="line">		<span class="comment"># 主要用于筛选器激活，字符串</span></span><br><span class="line">		<span class="comment"># type =&gt; &quot;logs&quot;</span></span><br><span class="line">		<span class="comment"># 额外添加字段，这里是为了区分来自哪一个插件</span></span><br><span class="line">		<span class="comment"># add_field =&gt; &#123;&quot;[fields][class]&quot; =&gt; &quot;beats&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">#这个插件需要和filebeat进行配很这里不做多讲，到时候结合起来一起介绍。</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">    <span class="string">stdout</span>&#123;</span><br><span class="line">		<span class="comment"># 使用 ruby &quot;awesome_print&quot; 库输出事件数据这是 stdout 的默认编解码器。</span></span><br><span class="line">		<span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="string">elasticsearch</span> &#123;</span><br><span class="line">		<span class="comment"># 要用于查询的elasticsearch主机的列表</span></span><br><span class="line">		<span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">&quot;elasticsearch-client客户端IP:elasticsearch-client端口&quot;</span> </span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 要搜索的索引名称的逗号列表;使用 或空字符串对所有索引执行操作。</span></span><br><span class="line">		<span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;log-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行logstash</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logstash.bat -f logstash.conf</span><br></pre></td></tr></table></figure>

<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/logstash/2.png" style="zoom: 67%;" />

<p>可以通过9600端口访问页面，查看是否执行成功<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/logstash/3.png" style="zoom: 67%;" /></p>
<h4 id="Windows安装Filebeat"><a href="#Windows安装Filebeat" class="headerlink" title="Windows安装Filebeat"></a>Windows安装Filebeat</h4><ol>
<li>去官方下载Windows版本的<a href="https://www.elastic.co/cn/downloads/past-releases/filebeat-7-6-1">Filebeat</a>，将ZIP文件解压，变成下面的目录结构</li>
</ol>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/filebeat/1.png" style="zoom: 67%;" />

<ol start="2">
<li>在根目录下编辑<code>filebeat.yml</code>文件，因我们是先将数据传递给Logstash，所以不用配置es的地址信息，注释掉就可以了</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考官方文档： https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 开启监视，不开不采集</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="comment"># 指定需要收集的日志文件的路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">G:\*\info\*.log</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:5044&quot;</span>]    </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">filebeat <span class="literal">-e</span> <span class="literal">-c</span> filebeat.yml <span class="literal">-d</span> <span class="string">&quot;publish&quot;</span></span><br></pre></td></tr></table></figure>

<img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/filebeat/2.png" style="zoom: 67%;" />

<h4 id="Windows测试ELK"><a href="#Windows测试ELK" class="headerlink" title="Windows测试ELK"></a>Windows测试ELK</h4><ol>
<li>在Filebeat监听目录下新增一个*.log文件，并写入内容，并观察</li>
</ol>
<img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/filebeat/3.png" style="zoom: 67%;" />

<p>上面图片中，我们已经能够看见对监听的文件内容变更，进行push到logstash中</p>
<ol start="2">
<li>我们在观察一下logstash的情况</li>
</ol>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/logstash/4.png" style="zoom: 67%;" />

<p>看见已经接收到传过来的信息了，然后将数据提交到ES中了</p>
<ol start="3">
<li>我们在Kibana中查看我们的索引</li>
</ol>
<img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/6.png" style="zoom: 67%;" />

<ol start="4">
<li>创建索引模式</li>
</ol>
<img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/7.png" style="zoom: 67%;" />

<img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/8.png" style="zoom: 67%;" />

<ol start="5">
<li>索引模式创建成功后，我们可以去面板看一下数据了</li>
</ol>
<img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/kibana/9.png" style="zoom: 67%;" />

<p>到这里，ELK的集成就基本结束了。后续是K8S部署Logstash和Spring项目中的使用</p>
<h4 id="K8s安装Logstash安装"><a href="#K8s安装Logstash安装" class="headerlink" title="K8s安装Logstash安装"></a>K8s安装Logstash安装</h4><ol>
<li>在NFS目录下新建一个test.conf文件，并写入内容</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.conf</span></span><br><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">    <span class="string">beats</span>&#123;</span><br><span class="line">                <span class="string">port</span> <span class="string">=&gt;</span> <span class="string">&quot;5044&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">    <span class="string">stdout</span>&#123;</span><br><span class="line">                <span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="string">elasticsearch</span> &#123;</span><br><span class="line">                <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">&quot;&#123;elasticsearch-client IP地址&#125;:9200&quot;</span></span><br><span class="line">                <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;log-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行下面yaml文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># logstash.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">elk:</span> <span class="string">logstash-service</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">logstash-service-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9600</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">web</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5044</span>      </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">tcp</span>        </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">elk:</span> <span class="string">logstash-dep</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">logstash-service-dep</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">elk:</span> <span class="string">logstash-dep</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">logstash</span></span><br><span class="line">        <span class="attr">elk:</span> <span class="string">logstash-dep</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logstash</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">logstash:7.6.1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="number">1</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;200m&quot;</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">9600</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">5044</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logstash-nfs</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/usr/share/logstash/config/conf.d/</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/usr/share/logstash/config/logstash.yml</span></span><br><span class="line">            <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">subPath:</span> <span class="string">logstash.yml</span>            </span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logstash-nfs</span></span><br><span class="line">        <span class="attr">nfs:</span></span><br><span class="line">          <span class="attr">server:</span> <span class="comment">#NFS IP地址</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/nfs/data/logstash</span>    </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">configMap:</span> </span><br><span class="line">          <span class="attr">name:</span> <span class="string">logstash-config</span>          </span><br><span class="line"><span class="meta">---                  </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">logstash-config</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">elk:</span> <span class="string">logstash-service</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">logstash.yml:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    http.host: &quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="string">    xpack.monitoring.elasticsearch.hosts: [ &quot;http://&#123;elasticsearch-client IP地址&#125;:9200&quot; ]</span></span><br><span class="line"><span class="string">    path.config: &quot;/usr/share/logstash/config/conf.d/*.conf&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看启动情况</li>
</ol>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/logstash/5.png" style="zoom: 67%;" />]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
        <category>elk</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s搭建-CoreDns</title>
    <url>/2019/06/28/docker/k8s/coreDns-1/</url>
    <content><![CDATA[<h2 id="CoreDNS简介"><a href="#CoreDNS简介" class="headerlink" title="CoreDNS简介"></a>CoreDNS简介</h2><p>CoreDNS 其实就是一个 DNS 服务，而 DNS 作为一种常见的服务发现手段，所以很多开源项目以及工程师都会使用 CoreDNS 为集群提供服务发现的功能，Kubernetes 就在集群中使用 CoreDNS 解决服务发现的问题。</p>
<p>如果想要在分布式系统实现服务发现的功能，CoreDNS 其实是一个非常好的选择，CoreDNS作为一个已经进入CNCF并且在Kubernetes中作为DNS服务使用的应用，其本身的稳定性和可用性已经得到了证明，同时它基于插件实现的方式非常轻量并且易于使用，插件链的使用也使得第三方插件的定义变得非常的方便。</p>
<h3 id="Coredns-架构"><a href="#Coredns-架构" class="headerlink" title="Coredns 架构"></a>Coredns 架构</h3><p>整个 CoreDNS 服务都建立在一个使用 Go 编写的 HTTP/2 Web 服务器 Caddy 。</p>
<h3 id="Coredns-项目下载"><a href="#Coredns-项目下载" class="headerlink" title="Coredns 项目下载"></a>Coredns 项目下载</h3><p>下载地址1：</p>
<p>wget <a href="https://github.com/coredns/deployment/archive/master.zip">https://github.com/coredns/deployment/archive/master.zip</a><br>unzip master.zip</p>
<p>下载地址2：<br>git clone <a href="https://github.com/coredns/deployment.git">https://github.com/coredns/deployment.git</a></p>
<span id="more"></span>

<h3 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h3><p>确认是否存在已运行dns服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl  get pods -o wide -n=kube-system</span><br></pre></td></tr></table></figure>

<p>删除命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete --namespace=kube-system deployment ****-dns</span><br></pre></td></tr></table></figure>

<p>生成安装配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /workspace/deployment/kubernetes</span><br><span class="line">./deploy.sh -r 10.254.0.0/16 -i 10.254.0.2  -d cluster.local -t coredns.yaml.sed -s &gt;coredns.yaml</span><br></pre></td></tr></table></figure>

<p>验证配置文件核心配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat coredns.yaml</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561709072968.png" alt="1561709072968"></p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561709098483.png" alt="1561709098483"></p>
<p>执行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f coredns.yaml</span><br></pre></td></tr></table></figure>

<p>验证安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get svc -o wide -n=kube-system</span><br><span class="line"></span><br><span class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)               </span><br><span class="line">heapster               ClusterIP   10.109.196.102   &lt;none&gt;        80/TCP                </span><br><span class="line">kube-dns               ClusterIP   10.96.0.2        &lt;none&gt;        53/UDP,53/TCP,9153/TCP</span><br><span class="line">kubernetes-dashboard   NodePort    10.110.231.202   &lt;none&gt;        443:30001/TCP         </span><br><span class="line">monitoring-grafana     NodePort    10.98.242.145    &lt;none&gt;        80:30108/TCP          </span><br><span class="line">monitoring-influxdb    ClusterIP   10.100.60.54     &lt;none&gt;        8086/TCP              </span><br></pre></td></tr></table></figure>

<p>查看coredns详细</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561709283565.png" alt="1561709283565"></p>
<h3 id="设置master和节点DNS"><a href="#设置master和节点DNS" class="headerlink" title="设置master和节点DNS"></a>设置master和节点DNS</h3><p>使用命令查看kubelet配置的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status kubelet -l</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561709534383.png" alt="1561709534383"></p>
<p>修改<code>/var/lib/kubelet/config.yaml</code>文件的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clusterDNS:</span><br><span class="line">- 10.96.0.2</span><br><span class="line">clusterDomain: cluster.local.</span><br></pre></td></tr></table></figure>

<p>重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<h3 id="验证DNS"><a href="#验证DNS" class="headerlink" title="验证DNS"></a>验证DNS</h3><p>1、创建一个curl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl run -it --image=registry.cn-shenzhen.aliyuncs.com/zhouqi-kubernetes/busyboxplus:v1 curl --rm</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561706009470.png" alt="1561706009470"></p>
<p>这个地方如果要验证各节点，可以伸缩多个，会运行在不同的节点中</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561706093086.png" alt="1561706093086"></p>
<p>对节点的验证，只需要进入容器使用<code>nslookup kubernetes</code>命令，就可以显示下图</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561706175310.png" alt="1561706175310"></p>
<p>文献参考：<a href="https://blog.51cto.com/michaelkang/2367800">https://blog.51cto.com/michaelkang/2367800</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s-Dashboard安装</title>
    <url>/2019/06/18/docker/k8s/dashboard-1/</url>
    <content><![CDATA[<h2 id="安装Kubernetes-dashboard"><a href="#安装Kubernetes-dashboard" class="headerlink" title="安装Kubernetes-dashboard"></a>安装Kubernetes-dashboard</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Kubernetes Dashboard是Kubernetes集群的基于Web的通用UI。它允许用户管理在群集中运行的应用程序并对其进行故障排除，以及管理群集本身。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建Dashboard的yaml文件，并设置端口为30001，拉取镜像文件地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class="line">sed -i &#x27;s/k8s.gcr.io/loveone/g&#x27; kubernetes-dashboard.yaml</span><br><span class="line">sed -i &#x27;/targetPort:/a\ \ \ \ \ \ nodePort: 30001\n\ \ type: NodePort&#x27; kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>



<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><h4 id="生成自签证书"><a href="#生成自签证书" class="headerlink" title="生成自签证书"></a>生成自签证书</h4><p>1）生成证书请求的key</p>
<blockquote>
<p>openssl genrsa -out dashboard.key 2048</p>
</blockquote>
<p>2）生成证书请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -days 3650 -new -out dashboard.csr -key dashboard.key -subj &#x27;/CN=**172.24.2.69**&#x27;</span><br></pre></td></tr></table></figure>



<p>3）生成自签证书</p>
<blockquote>
<p>openssl x509 -req -in dashboard.csr -signkey dashboard.key -out dashboard.crt</p>
</blockquote>
<p><strong>以上都是在服务器上执行</strong></p>
<span id="more"></span>



<h4 id="创建Secret"><a href="#创建Secret" class="headerlink" title="创建Secret"></a>创建Secret</h4><p>1）删除之前部署的Dashboard</p>
<blockquote>
<p>kubectl delete -f kubernetes-dashboard.yaml</p>
</blockquote>
<ol start="2">
<li>创建与KubernetesDashboard 部署文件中同名的secret</li>
</ol>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/20200507145738.png?" style="zoom:80%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic kubernetes-dashboard-certs --from-file=./dashboard.key --from-file=./dashboard.crt -n kube-system</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p>命名空间：<code>kube-system</code></p>
</li>
<li><p>删除证书：<code>kubectl delete secret kubernetes-dashboard-certs</code></p>
</li>
</ul>
<p>3)注释 kubernetes-dashboard.yaml文件中关于Dashboard Secret部分</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/20200507150647.png?" style="zoom:80%;" />



<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、部署Dashboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>



<p>2、创建完成后，检查相关服务运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get deployment kubernetes-dashboard -n kube-system</span><br><span class="line"></span><br><span class="line">kubectl get pods -n kube-system -o wide</span><br><span class="line"></span><br><span class="line">kubectl get services -n kube-system</span><br><span class="line"></span><br><span class="line">kubectl describe pod kubernetes-dashboard-fd674d9c5-dp5k6 --namespace=kube-system</span><br><span class="line"></span><br><span class="line">netstat -ntlp|grep 30001</span><br></pre></td></tr></table></figure>



<p>3、查看访问Dashboard的认证令牌</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount  dashboard-admin -n kube-system</span><br><span class="line">kubectl create clusterrolebinding  dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line">kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#x27;/dashboard-admin/&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="问题集合"><a href="#问题集合" class="headerlink" title="问题集合"></a>问题集合</h3><ul>
<li>问题：Chrome无法访问</li>
</ul>
<blockquote>
<p> 解决：chrome.exe” 在快捷方式中增加  –disable-infobars –ignore-certificate-errors</p>
</blockquote>
<ul>
<li>问题：Master的Token过期</li>
</ul>
<blockquote>
<p>使用命令：kubeadm token create重新生成Token在加入</p>
</blockquote>
<ul>
<li>问题：子节点加入后出现NotReady</li>
</ul>
<blockquote>
<p>在master中重启docker，方可解决</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s搭建-YAPI</title>
    <url>/2019/07/18/docker/k8s/yapi-1/</url>
    <content><![CDATA[<h2 id="YAPI搭建"><a href="#YAPI搭建" class="headerlink" title="YAPI搭建"></a>YAPI搭建</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1、准备Yapi镜像</p>
<p>2、准备Mongo镜像</p>
<p>3、创建NFS共享文件</p>
<p>这些准备工作，都在我的博客中有写道，有疑问可以去找一下 <a href="http://blog.appydm.com/">http://blog.appydm.com</a></p>
<span id="more"></span>


<h3 id="安装-启动-Mongo"><a href="#安装-启动-Mongo" class="headerlink" title="安装/启动(Mongo)"></a>安装/启动(Mongo)</h3><h4 id="Mongo-K8S配置"><a href="#Mongo-K8S配置" class="headerlink" title="Mongo-K8S配置"></a>Mongo-K8S配置</h4><p>mongo-nfs-pv.yaml文件内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-nfs-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/mongo</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.24</span><span class="number">.2</span><span class="number">.70</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo-nfs-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span>    </span><br></pre></td></tr></table></figure>

<p>mongo.yaml文件内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">19098</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;busyboxplus&#x27;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/zhouqi-kubernetes/busyboxplus:v1</span></span><br><span class="line">        <span class="attr">command:</span> [</span><br><span class="line">          <span class="string">&quot;sh&quot;</span>, </span><br><span class="line">          <span class="string">&quot;-c&quot;</span>, </span><br><span class="line">          <span class="string">&quot;nslookup mysql-system.default.svc.cluster.local&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span>      </span><br><span class="line">        <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;200m&quot;</span>            </span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;MONGO_INITDB_ROOT_USERNAME&quot;</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;MONGO_INITDB_ROOT_PASSWORD&quot;</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;48660960&quot;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">datadir</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">datadir</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">mongo-nfs-pvc</span></span><br></pre></td></tr></table></figure>

<h4 id="Mongo-启动"><a href="#Mongo-启动" class="headerlink" title="Mongo-启动"></a>Mongo-启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f mongo-nfs-pv.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f mongo.yaml</span><br></pre></td></tr></table></figure>



<h3 id="安装-启动-YAPI"><a href="#安装-启动-YAPI" class="headerlink" title="安装/启动(YAPI)"></a>安装/启动(YAPI)</h3><h4 id="创建YAPI用户和数据库"><a href="#创建YAPI用户和数据库" class="headerlink" title="创建YAPI用户和数据库"></a>创建YAPI用户和数据库</h4><p>进入mongo容器中，执行下面命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@mongo-69f8cbc957-xw47b:/# mongo</span><br><span class="line">MongoDB shell version v4.0.10</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;d333ace7-d3e7-40bd-9d41-81a72b12771d&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.10</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> use admin</span></span><br><span class="line">switched to db admin</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.auth(<span class="string">&quot;root&quot;</span>, <span class="string">&quot;48660960&quot;</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> use yapi</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createUser(&#123;user:<span class="string">&quot;yapi&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;yapi&quot;</span>,roles:[&#123;<span class="string">&quot;role&quot;</span>:<span class="string">&quot;readWrite&quot;</span>,<span class="string">&quot;db&quot;</span>:<span class="string">&quot;yapi&quot;</span>&#125;]&#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="创建YAPI的config-json配置"><a href="#创建YAPI的config-json配置" class="headerlink" title="创建YAPI的config.json配置"></a>创建YAPI的config.json配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; config.json</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;port&quot;: &quot;3000&quot;,</span><br><span class="line">  &quot;adminAccount&quot;: &quot;admin@admin.com&quot;,</span><br><span class="line">  &quot;db&quot;: &#123;</span><br><span class="line">    &quot;servername&quot;: &quot;mongo.default.svc.cluster.local&quot;,</span><br><span class="line">    &quot;DATABASE&quot;:  &quot;yapi&quot;,</span><br><span class="line">    &quot;port&quot;: 19098,</span><br><span class="line">    &quot;user&quot;: &quot;yapi&quot;,</span><br><span class="line">    &quot;pass&quot;: &quot;yapi&quot;,</span><br><span class="line">    &quot;authSource&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mail&quot;: &#123;</span><br><span class="line">    &quot;enable&quot;: true,</span><br><span class="line">    &quot;host&quot;: &quot;smtp.163.com&quot;,</span><br><span class="line">    &quot;port&quot;: 465,</span><br><span class="line">    &quot;from&quot;: &quot;***@163.com&quot;,</span><br><span class="line">    &quot;auth&quot;: &#123;</span><br><span class="line">        &quot;user&quot;: &quot;***@163.com&quot;,</span><br><span class="line">        &quot;pass&quot;: &quot;*****&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="YAPI-K8S配置"><a href="#YAPI-K8S配置" class="headerlink" title="YAPI-K8S配置"></a>YAPI-K8S配置</h4><p>yapi.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">yapi</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">yapi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">19080</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">yapi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">yapi</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">yapi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">yapi</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;busyboxplus&#x27;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/zhouqi-kubernetes/busyboxplus:v1</span></span><br><span class="line">        <span class="attr">command:</span> [</span><br><span class="line">          <span class="string">&quot;sh&quot;</span>, </span><br><span class="line">          <span class="string">&quot;-c&quot;</span>, </span><br><span class="line">          <span class="string">&quot;nslookup mongo.default.svc.cluster.local&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      <span class="attr">containers:</span>           </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">yapi</span>      </span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/zhouqi-kubernetes/yapi:v1.7.2</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;200m&quot;</span>            </span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">        <span class="attr">command:</span> [</span><br><span class="line">          <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">          <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;[ ! -e /home/yapi/log/init.lock ] &amp;&amp; npm run install-server &amp;&amp; touch /home/yapi/log/init.lock; npm run start&quot;</span>          </span><br><span class="line">        ]</span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">yapi-nfs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/home/yapi/config.json</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">config.json</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">yapi-nfs</span></span><br><span class="line">        <span class="attr">nfs:</span></span><br><span class="line">          <span class="attr">server:</span> <span class="number">172.24</span><span class="number">.2</span><span class="number">.71</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/nfs/data/yapi</span>   </span><br></pre></td></tr></table></figure>

<h4 id="YAPI-启动"><a href="#YAPI-启动" class="headerlink" title="YAPI-启动"></a>YAPI-启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f yapi.yaml</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s搭建-Zookeeper集群</title>
    <url>/2019/06/28/docker/k8s/zookeeper-1/</url>
    <content><![CDATA[<h2 id="K8S搭建Zookeeper集群"><a href="#K8S搭建Zookeeper集群" class="headerlink" title="K8S搭建Zookeeper集群"></a>K8S搭建Zookeeper集群</h2><h3 id="服务器资源"><a href="#服务器资源" class="headerlink" title="服务器资源"></a>服务器资源</h3><table>
<thead>
<tr>
<th>服务器地址</th>
<th>k8s</th>
<th>NFS</th>
</tr>
</thead>
<tbody><tr>
<td>172.24.2.67</td>
<td>k8s-node-3</td>
<td>service</td>
</tr>
<tr>
<td>172.24.2.69</td>
<td>k8s-master</td>
<td>client</td>
</tr>
<tr>
<td>172.24.2.70</td>
<td>k8s-node-2</td>
<td>client</td>
</tr>
<tr>
<td>172.24.2.71</td>
<td>k8s-node-1</td>
<td>client</td>
</tr>
</tbody></table>
<h3 id="安装NFS"><a href="#安装NFS" class="headerlink" title="安装NFS"></a>安装NFS</h3><p>1、在67服务器中安装NFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">master节点安装nfs</span></span><br><span class="line">yum -y install nfs-utils</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建nfs目录</span></span><br><span class="line">mkdir -p /nfs/data/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改权限</span></span><br><span class="line">chmod -R 777 /nfs/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑<span class="built_in">export</span>文件,这个文件就是nfs默认的配置文件</span></span><br><span class="line">vi /etc/exports</span><br><span class="line">/nfs/data *(rw,no_root_squash,sync)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置生效</span></span><br><span class="line">exportfs -r</span><br><span class="line"><span class="meta">#</span><span class="bash">查看生效</span></span><br><span class="line">exportfs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动rpcbind、nfs服务</span></span><br><span class="line">systemctl restart rpcbind &amp;&amp; systemctl enable rpcbind</span><br><span class="line">systemctl restart nfs &amp;&amp; systemctl enable nfs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看 RPC 服务的注册状况</span></span><br><span class="line">rpcinfo -p localhost</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">showmount测试</span></span><br><span class="line">showmount -e 172.24.2.67</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561700173921.png" alt="1561700173921"></p>
<p>2、所有node节点安装客户端，开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils</span><br><span class="line">systemctl start nfs &amp;&amp; systemctl enable nfs</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="部署NSF-Zookeeper-PV"><a href="#部署NSF-Zookeeper-PV" class="headerlink" title="部署NSF-Zookeeper-PV"></a>部署NSF-Zookeeper-PV</h3><p>1、新建一个<code>zk-nfs-pv.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-nfs-pv-01</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">pv:</span> <span class="string">zk-nfs-pv-01</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">zk-nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/zookeeper/pv-01</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.24</span><span class="number">.2</span><span class="number">.67</span></span><br><span class="line"><span class="meta">---    </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-nfs-pv-02</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">pv:</span> <span class="string">zk-nfs-pv-02</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">zk-nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/zookeeper/pv-02</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.24</span><span class="number">.2</span><span class="number">.67</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-nfs-pv-03</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">pv:</span> <span class="string">zk-nfs-pv-03</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">zk-nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/zookeeper/pv-03</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.24</span><span class="number">.2</span><span class="number">.67</span></span><br></pre></td></tr></table></figure>

<p>2、启动zk-nfs-pv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f zk-nfs-pv.yaml</span><br></pre></td></tr></table></figure>

<p>3、查看状态</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561700126674.png" alt="1561700126674"></p>
<h3 id="部署Zookeeper集群"><a href="#部署Zookeeper集群" class="headerlink" title="部署Zookeeper集群"></a>部署Zookeeper集群</h3><p>1、新建文件<code>zookeeper.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-headless</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">zk-headless</span>  </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2888</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3888</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">leader-election</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">zk</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-cs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">zk</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2181</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">zk</span>    </span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">ensemble:</span> <span class="string">&quot;zk-0;zk-1;zk-2&quot;</span></span><br><span class="line">  <span class="attr">jvm.heap:</span> <span class="string">&quot;2G&quot;</span></span><br><span class="line">  <span class="attr">tick:</span> <span class="string">&quot;2000&quot;</span></span><br><span class="line">  <span class="attr">init:</span> <span class="string">&quot;10&quot;</span></span><br><span class="line">  <span class="attr">sync:</span> <span class="string">&quot;5&quot;</span></span><br><span class="line">  <span class="attr">client.cnxns:</span> <span class="string">&quot;60&quot;</span></span><br><span class="line">  <span class="attr">snap.retain:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">  <span class="attr">purge.interval:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-budget</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zk</span></span><br><span class="line">  <span class="attr">minAvailable:</span> <span class="number">2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zk</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">zk-headless</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">zk</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;app&quot;</span></span><br><span class="line">                    <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                    <span class="attr">values:</span> </span><br><span class="line">                    <span class="bullet">-</span> <span class="string">zk</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">&quot;kubernetes.io/hostname&quot;</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-zookeeper</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&quot;registry.cn-shenzhen.aliyuncs.com/zhouqi-kubernetes/k8szk:v3&quot;</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2181</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">client</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2888</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3888</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">leader-election</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_REPLICAS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_ENSEMBLE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">ensemble</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_HEAP_SIZE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">jvm.heap</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_TICK_TIME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">tick</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_INIT_LIMIT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">init</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_SYNC_LIMIT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">tick</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">ZK_MAX_CLIENT_CNXNS</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">client.cnxns</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ZK_SNAP_RETAIN_COUNT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">snap.retain</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ZK_PURGE_INTERVAL</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">zk-config</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">purge.interval</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ZK_CLIENT_PORT</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;2181&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ZK_SERVER_PORT</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;2888&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ZK_ELECTION_PORT</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;3888&quot;</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">zkGenConfig.sh</span> <span class="string">&amp;&amp;</span> <span class="string">zkServer.sh</span> <span class="string">start-foreground</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;zkOk.sh&quot;</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;zkOk.sh&quot;</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">datadir</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/zookeeper</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">data/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">datadir</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/opt/zookeeper/conf</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">config/</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">datadir</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">volume.beta.kubernetes.io/storage-class:</span> <span class="string">&quot;zk-nfs&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">3Gi</span></span><br></pre></td></tr></table></figure>

<p>2、启动<code>zookeeper.yaml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f zookeeper.yaml</span><br></pre></td></tr></table></figure>

<p>3、查看启动情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561700410724.png" alt="1561700410724"></p>
<p>4、最后来验证Zookeeper集群是否正常，查看集群节点状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in 0 1 2; do kubectl exec zk-$i zkServer.sh status; done</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/k8s/1561700478499.png" alt="1561700478499"></p>
<p>参考文献：<a href="https://www.jianshu.com/p/2633b95c244c">https://www.jianshu.com/p/2633b95c244c</a></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建Redis集群</title>
    <url>/2019/02/12/docker/redis/1/</url>
    <content><![CDATA[<h4 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h4><p>redis是最常用的缓存服务，下面我就使用docker来搭建一套redis的集群。</p>
<h5 id="创建redis容器"><a href="#创建redis容器" class="headerlink" title="创建redis容器"></a>创建redis容器</h5><ol>
<li><p>首先我们需要新建一个redis配置模板，用于批量生成redis配置文件<code>redis-cluster.tmpl</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/docker/redis-cluster;</span><br><span class="line">cd ~/docker/redis-cluster;</span><br><span class="line">touch redis-cluster.tmpl;</span><br></pre></td></tr></table></figure></li>
<li><p>将一下内容写入到<code>redis-cluster.tmpl</code>文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port $&#123;PORT&#125;</span><br><span class="line">protected-mode no</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 192.168.3.60</span><br><span class="line">cluster-announce-port $&#123;PORT&#125;</span><br><span class="line">cluster-announce-bus-port 1$&#123;PORT&#125;</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>注意: cluster-announce-ip 是本机ip，而不是<code>127.0.0.1</code></p>
</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p>在docker中创建一个自定义网络，可以使用<code>docker network create</code>命令来创建，<code>docker network ls</code>命令来查看是否创建成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create redis-net</span><br><span class="line">[root@localhost ~/docker/redis-cluster]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">e98dcf06eec6        bridge              bridge              local</span><br><span class="line">845f1245483b        host                host                local</span><br><span class="line">f72ff3f690a0        none                null                local</span><br><span class="line">72aa0ec39b32        redis-net           bridge              local</span><br></pre></td></tr></table></figure></li>
<li><p>现在我们来批量执行生成配置文件和数据存储目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in `seq 7000 7005`; do \</span><br><span class="line">  mkdir -p ~/docker/redis-cluster/$&#123;port&#125;/conf \</span><br><span class="line">  &amp;&amp; PORT=$&#123;port&#125; envsubst &lt; ~/docker/redis-cluster/redis-cluster.tmpl &gt; ~/docker/redis-cluster/$&#123;port&#125;/conf/redis.conf \</span><br><span class="line">  &amp;&amp; mkdir -p ~/docker/redis-cluster/$&#123;port&#125;/data; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>共生成6个文件夹，从7000到7005，每个文件夹下包含data和conf文件夹，同时conf里面有redis.conf配置文件</p>
</li>
<li><p>创建6个redis容器，并启动<code>registry.cn-shenzhen.aliyuncs.com/zhouqi/redis:4.0</code>是我自己的docker镜像，当然也可以直接使用官方镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in `seq 7000 7005`; do \</span><br><span class="line">  docker run -d -ti -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; \</span><br><span class="line">  -v ~/docker/redis-cluster/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf:z \</span><br><span class="line">  -v ~/docker/redis-cluster/$&#123;port&#125;/data:/data:z \</span><br><span class="line">  --restart always --name redis-$&#123;port&#125; --net redis-net \</span><br><span class="line">  --sysctl net.core.somaxconn=1024 registry.cn-shenzhen.aliyuncs.com/zhouqi/redis:4.0 redis-server /usr/local/etc/redis/redis.conf;  \</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>我们查看一下是否启动成功<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/redis/1.png"></p>
</li>
</ol>
<h5 id="建立Redis集群关系"><a href="#建立Redis集群关系" class="headerlink" title="建立Redis集群关系"></a>建立Redis集群关系</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo yes | docker run -i --rm --net redis-net ruby sh -c &#x27;\</span><br><span class="line">  gem install redis \</span><br><span class="line">  &amp;&amp; wget http://download.redis.io/releases/redis-4.0.10.tar.gz \</span><br><span class="line">  &amp;&amp; tar -xzvf redis-4.0.10.tar.gz \</span><br><span class="line">  &amp;&amp; ruby redis-4.0.10/src/redis-trib.rb create --replicas 1 \</span><br><span class="line">  &#x27;&quot;$(for port in `seq 7000 7005`; do \</span><br><span class="line">    echo -n &quot;$(docker inspect --format &#x27;&#123;&#123; (index .NetworkSettings.Networks &quot;redis-net&quot;).IPAddress &#125;&#125;&#x27; &quot;redis-$&#123;port&#125;&quot;)&quot;:$&#123;port&#125; &#x27; &#x27; ; \</span><br><span class="line">  done)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/redis/2.png"></p>
<p>最后我们在看一下redis的集群信息<br><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/docker/redis/3.png"></p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li><p>centos7创建redis集群一直卡在Waiting for the cluster to join</p>
<blockquote>
<p>问题：<br>机器没有开放redis集群总线端口。</p>
<p>解决方法：<br>开放redis集群总线端口。<br>集群总线端口是redis客户端连接的端口+10000。<br>如：redis客户端端口是7001。<br>则：集群总线端口就是17001。<br>注意、所以redis集群机器都要放开对应的redis客户端端口和集群总线端口。<br>如果你是在虚拟机上搭建redis集群、那么你直接关闭防火墙即可解决</p>
</blockquote>
</li>
<li><p>centos7创建redis集群一直卡在Waiting for the cluster to join</p>
<blockquote>
<p>问题:<br>也许你的redis集群的ip设置成了127.0.0.1或loclahost</p>
<p>解决方法：<br>将redis-cluster.tmpl中的ip设置成本机ip</p>
</blockquote>
</li>
<li><p>WARNING: redis-trib.rb is not longer available!</p>
<blockquote>
<p>问题：<br>只有redis 5.0以下的版本才支持</p>
<p>解决方法：<br>去<code>http://download.redis.io/releases</code>中下载你对应的版本号</p>
</blockquote>
</li>
</ol>
<h5 id="批量处理命令"><a href="#批量处理命令" class="headerlink" title="批量处理命令"></a>批量处理命令</h5><ol>
<li><p>Redis停止</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in `seq 7000 7005`; do \</span><br><span class="line">docker stop redis-$&#123;port&#125;; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>Redis删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in `seq 7000 7005`; do \</span><br><span class="line">docker stop redis-$&#123;port&#125;; \</span><br><span class="line">docker rm redis-$&#123;port&#125;; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>Redis启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for port in `seq 7000 7005`; do \</span><br><span class="line">docker start redis-$&#123;port&#125;; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign真正正确的使用方法</title>
    <url>/2018/03/07/java/feign/1/</url>
    <content><![CDATA[<p>Feign是spring cloud中服务消费端的调用框架,通常与ribbon,hystrix等组合使用。</p>
<p>但是在某些项目中，由于遗留原因，整个系统并不是spring cloud项目，甚至不是spring项目，而使用者关注的重点仅仅是简化http调用代码的编写。</p>
<p>如果采用httpclient或者okhttp这样相对较重的框架，对初学者来说编码量与学习曲线都会是一个挑战，而使用spring中RestTemplate，又没有配置化的解决方案，由此想到是否可以脱离spring cloud，独立使用Feign。</p>
<h4 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">8.18</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Param;</span><br><span class="line"><span class="keyword">import</span> feign.RequestLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /users/list?name=&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">getOwner</span><span class="params">(<span class="meta">@Param(value = &quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>@RequestLine</code>指定HTTP协议及URL地址</p>
<h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemoteService service = Feign.builder()</span><br><span class="line">            .options(<span class="keyword">new</span> Options(<span class="number">1000</span>, <span class="number">3500</span>))</span><br><span class="line">            .retryer(<span class="keyword">new</span> Retryer.Default(<span class="number">5000</span>, <span class="number">5000</span>, <span class="number">3</span>))</span><br><span class="line">            .target(RemoteService.class, <span class="string">&quot;http://127.0.0.1:8085&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>options方法指定连接超时时长及响应超时时长，retryer方法指定重试策略,target方法绑定接口与服务端地址。返回类型为绑定的接口类型。</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result = service.getOwner(<span class="string">&quot;scott&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>与调用本地方法相同的方式调用feign包装的接口，直接获取远程服务提供的返回值。</p>
<h4 id="附：服务生产者"><a href="#附：服务生产者" class="headerlink" title="附：服务生产者"></a>附：服务生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/list&quot;,method=&#123;RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>在项目中，服务消费端与生产端之间交换的数据往往是一或多个对象，feign同样提供基于json的对象转换工具，方便我们直接以对象形式交互。</p>
<h4 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Headers(&#123;&quot;Content-Type: application/json&quot;,&quot;Accept: application/json&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@RequestLine(&quot;POST /users/list&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getOwner</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入@Headers注解，指定Content-Type为json</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemoteService service = Feign.builder()</span><br><span class="line">                .encoder(<span class="keyword">new</span> JacksonEncoder())</span><br><span class="line">                .decoder(<span class="keyword">new</span> JacksonDecoder())</span><br><span class="line">                .options(<span class="keyword">new</span> Options(<span class="number">1000</span>, <span class="number">3500</span>))</span><br><span class="line">                .retryer(<span class="keyword">new</span> Retryer.Default(<span class="number">5000</span>, <span class="number">5000</span>, <span class="number">3</span>))</span><br><span class="line">                .target(RemoteService.class, <span class="string">&quot;http://127.0.0.1:8085&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>encoder指定对象编码方式，decoder指定对象解码方式。这里用的是基于Jackson的编、解码方式，需要在pom.xml中添加Jackson的依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-jackson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">8.18</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User result = service.getOwner(u);</span><br></pre></td></tr></table></figure>

<h4 id="附：服务生产者-1"><a href="#附：服务生产者-1" class="headerlink" title="附：服务生产者"></a>附：服务生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/list&quot;,method=&#123;RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">list</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        System.out.println(user.getUsername());</span><br><span class="line">        user.setId(<span class="number">100L</span>);</span><br><span class="line">        user.setUsername(user.getUsername().toUpperCase());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的变化就是使用了@RequestBody来接收json格式的数据。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA调优之JVM-GC</title>
    <url>/2018/08/02/java/jvm/1/</url>
    <content><![CDATA[<h4 id="JAVA调优之JVM-GC"><a href="#JAVA调优之JVM-GC" class="headerlink" title="JAVA调优之JVM-GC"></a>JAVA调优之JVM-GC</h4><p>在分享之前需要给大家说一下，JVM的堆一般分为<code>新生代</code>,<code>老年代</code>，<code>永久代</code>这三个区间，下面我们就来说明根据各种情况来进行排查，并对这三个区进行分配合理的区间。</p>
<p><strong>服务器</strong></p>
<ul>
<li>应用：dal-service-5.1.4.0-SNAPSHOT.jar</li>
<li>CPU：24核</li>
<li>内存：125G</li>
<li>JDK：8.144</li>
</ul>
<span id="more"></span>

<h5 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ./dal-service-5.1.4.0-SNAPSHOT.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure>
<p>使用上面的命令，我们的应用就启动完成来，然后我们来看一下应用的各种数据。</p>
<ol>
<li><p>查看应用的PID进程号，使用<code>JPS</code><br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/12.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
</li>
<li><p>查看CPU和内存情况，可以使用<code>TOP</code>，并按下<code>1</code><br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/13.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
</li>
</ol>
<p>现在应用的基本情况就知道来，但这只是一个基础的信息，怎样能看详细的资源，比如GC怎么回收的，GC触发时间，GC频率等。现在我们把应用停了，加载GC的一些参数和GC的日志，再次启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java \</span><br><span class="line">-verbose:gc \</span><br><span class="line">-XX:+PrintGCDetails \</span><br><span class="line">-XX:+PrintGCTimeStamps \</span><br><span class="line">-XX:+PrintHeapAtGC \</span><br><span class="line">-Xloggc:/home/iot/dal-service-gc.log \</span><br><span class="line">-jar /home/iot/portal/dal-service-5.1.4.0-SNAPSHOT.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure>

<h5 id="查看GC情况"><a href="#查看GC情况" class="headerlink" title="查看GC情况"></a>查看GC情况</h5><p>查看GC情况，有2种方法可以查看</p>
<p>1、直接查看dal-service-gc.log日志文件<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/14.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>2、使用<code>jstatd</code>进行监听，然后通过<code>jvisualvm</code>来查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstatd -J-Djava.security.policy=/home/iot/jdk1.8.0_131/bin/jstatd.all.policy -J-Djava.rmi.server.hostname=192.168.156.22 -p 1099 -J-Djava.rmi.server.logCalls=true</span><br></pre></td></tr></table></figure>

<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/15.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>其实，我们在日志中就看见当应用启动的时候执行来3次FULL GC。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/16.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>新生代情况：</p>
<ul>
<li>PSYoungGen      total 3185152K, used 3185120K</li>
<li>eden space 3150848K, 100% used</li>
<li>from space 34304K, 99% used</li>
</ul>
<p>老年代情况：</p>
<ul>
<li>ParOldGen       total 1429504K, used 56198K</li>
<li>object space 1429504K, 3% used</li>
</ul>
<p>持久代情况：</p>
<ul>
<li>Metaspace       used 74104K, capacity 74936K, committed 75544K, reserved 1116160K</li>
<li>class space    used 8951K, capacity 9137K, committed 9256K, reserved 1048576K</li>
</ul>
<h5 id="优化JVM"><a href="#优化JVM" class="headerlink" title="优化JVM"></a>优化JVM</h5><p>大家都知道FULL GC一次，将会降低TPS，并且会暂用线程时间。本次优化让应用尽量启动后不再产生FULL GC，我们调整一下启动命令。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/17.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>调整后，我们虽然进行来GC，但是没有再次执行FULL GC了，这也算调整完成了。</p>
<h5 id="启动命令参数"><a href="#启动命令参数" class="headerlink" title="启动命令参数"></a>启动命令参数</h5><p>–  GC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails    		GC内容</span><br><span class="line">-XX:+PrintGCTimeStamps 		输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintHeapAtGC 			在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 		日志文件的输出路径</span><br></pre></td></tr></table></figure>

<p>– JVM</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xmn						新生代空间大小，此处的大小是(eden+2 survivor space) </span><br><span class="line">-XX:NewSize 				新生代空间大小初始值</span><br><span class="line">-XX:MaxNewSize 				新生代空间大小最大值</span><br><span class="line">-XX:MetaspaceSize			持久代初始值</span><br><span class="line">-XX:MaxMetaspaceSize		最大持久代值</span><br></pre></td></tr></table></figure>

<h5 id="Linux调优"><a href="#Linux调优" class="headerlink" title="Linux调优"></a>Linux调优</h5><p>修改<code>/etc/sysctl.conf</code>文件，增加</p>
<ul>
<li>net.ipv4.tcp_tw_reuse = 1</li>
<li>net.ipv4.tcp_tw_recycle = 1</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行原理</title>
    <url>/2018/08/02/java/jvm/2/</url>
    <content><![CDATA[<h4 id="JVM运行原理详解"><a href="#JVM运行原理详解" class="headerlink" title="JVM运行原理详解"></a>JVM运行原理详解</h4><h5 id="JVM简析"><a href="#JVM简析" class="headerlink" title="JVM简析"></a>JVM简析</h5><p>作为一名Java使用者，掌握JVM的体系结构也是很有必要的。<br>说起Java，我们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/1.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>Java平台由Java虚拟机和Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示： 运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/2.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。 在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>
<p>下面我们从JVM的基本概念和运过程程这两个方面入手来对它进行深入的研究。</p>
<span id="more"></span>

<h5 id="JVM基本概念"><a href="#JVM基本概念" class="headerlink" title="JVM基本概念"></a>JVM基本概念</h5><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><p>JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<h6 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h6><p>我们都知道Java源文件，通过编译器，能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：</p>
<ul>
<li>Java源文件—&gt;编译器—&gt;字节码文件</li>
<li>字节码文件-&gt;JVM—&gt;机器码</li>
</ul>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p>
<h6 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h6><ul>
<li>Sun公司的HotSpot</li>
<li>BEA公司的JRockit</li>
<li>IBM公司的J9 JVM</li>
</ul>
<p>在JDK1.7及其以前我们所使用的都是Sun公司的HotSpot，但由于Sun公司和BEA公司都被oracle收购，jdk1.8将采用Sun公司的HotSpot和BEA公司的JRockit两个JVM中精华形成jdk1.8的JVM。</p>
<h5 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/3.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h6 id="Class-Loader类加载器"><a href="#Class-Loader类加载器" class="headerlink" title="Class Loader类加载器"></a>Class Loader类加载器</h6><p>负责加载 .class文件，class文件在文件开头有特定的文件标示，并且ClassLoader负责class文件的加载等，至于它是否可以运行，则由Execution Engine决定。</p>
<ul>
<li>定位和导入二进制class文件</li>
<li>验证导入类的正确性</li>
<li>为类分配初始化内存</li>
<li>帮助解析符号引用</li>
</ul>
<h6 id="Native-Interface本地接口"><a href="#Native-Interface本地接口" class="headerlink" title="Native Interface本地接口"></a>Native Interface本地接口</h6><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体作法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。</p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见。</p>
<p>因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等。</p>
<h6 id="Execution-Engine-执行引擎：执行包在装载类的方法中的指令，也就是方法"><a href="#Execution-Engine-执行引擎：执行包在装载类的方法中的指令，也就是方法" class="headerlink" title="Execution Engine 执行引擎：执行包在装载类的方法中的指令，也就是方法"></a>Execution Engine 执行引擎：执行包在装载类的方法中的指令，也就是方法</h6><h6 id="Runtime-data-area-运行数据区"><a href="#Runtime-data-area-运行数据区" class="headerlink" title="Runtime data area 运行数据区"></a>Runtime data area 运行数据区</h6><p>虚拟机内存或者Jvm内存，冲整个计算机内存中开辟一块内存存储Jvm需要用到的对象，变量等，运行区数据有分很多小区，分别为：方法区，虚拟机栈，本地方法栈，堆，程序计数器</p>
<h5 id="JVM数据运行区详解（栈管运行，堆管存储）"><a href="#JVM数据运行区详解（栈管运行，堆管存储）" class="headerlink" title="JVM数据运行区详解（栈管运行，堆管存储）"></a>JVM数据运行区详解（栈管运行，堆管存储）</h5><p>JVM调优主要就是优化 Heap堆 和 Method Area 方法区</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/4.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h6 id="Native-Method-Stack本地方法栈"><a href="#Native-Method-Stack本地方法栈" class="headerlink" title="Native Method Stack本地方法栈"></a>Native Method Stack本地方法栈</h6><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies</p>
<h6 id="PC-Register程序计数器"><a href="#PC-Register程序计数器" class="headerlink" title="PC Register程序计数器"></a>PC Register程序计数器</h6><p>每个线程都有一个程序计算器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记</p>
<h6 id="Method-Area方法区"><a href="#Method-Area方法区" class="headerlink" title="Method Area方法区"></a>Method Area方法区</h6><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间</p>
<p><strong>静态变量+常量+类信息+运行时常量池存在方法区中，实例变量存在堆内存中</strong></p>
<h6 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h6><ul>
<li>栈是什么</li>
</ul>
<p> 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。</p>
<p> <strong>基本类型的变量和对象的引用变量都是在函数的栈内存中分配</strong></p>
<ul>
<li>栈存储什么？</li>
</ul>
<p> 栈帧中主要保存3类数据</p>
<blockquote>
</blockquote>
<ul>
<li><p>本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；</p>
</li>
<li><p>栈操作（Operand Stack）：记录出栈、入栈的操作；</p>
</li>
<li><p>栈帧数据（Frame Data）：包括类文件、方法等等；</p>
</li>
<li><p>栈运行原理</p>
</li>
</ul>
<p> 栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3也被压入栈…… 依次执行完毕后，先弹出后进……F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p>
<p> <strong>遵循“先进后出”/“后进先出”原则</strong></p>
<h6 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h6><p>堆这块区域是JVM中最大的，应用的对象和数据都是存在这个区域，这块区域也是线程共享的，也是gc主要的回收区，一个 JVM 实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/5.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<ul>
<li>新生区</li>
</ul>
<p> 新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden space）和幸存者区（Survivor pace），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园进行垃圾回收（Minor GC）,将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1去也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（FullGCC），进行养老区的内存清理。若养老区执行Full GC 之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</p>
<p> <strong>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。</strong></p>
<p> 原因有二</p>
<ul>
<li><p>Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整</p>
</li>
<li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
</li>
<li><p>养老区</p>
</li>
</ul>
<p> 养老区用于保存从新生区筛选出来的 JAVA 对象，一般池对象都在这个区域活跃</p>
<ul>
<li>永久区</li>
</ul>
<p> 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存</p>
<p> <strong>如果出现java.lang.OutOfMemoryError: PermGen space，说明是Java虚拟机对永久代Perm内存设置不够。</strong></p>
<p> 原因有二</p>
<ul>
<li>程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用</li>
<li>大量动态反射生成的类不断被加载，最终导致Perm区被占满</li>
</ul>
<p> 说明：</p>
<ul>
<li>Jdk1.6及之前：常量池分配在永久代 。</li>
<li>Jdk1.7：有，但已经逐步“去永久代” 。</li>
<li>Jdk1.8及之后：无(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)。</li>
</ul>
<p> <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/6.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p> 说明：</p>
<p> 方法区和堆内存的异议，实际而言，方法区和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>
<p> 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”,但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。</p>
<p> 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h5 id="堆内存调优简介"><a href="#堆内存调优简介" class="headerlink" title="堆内存调优简介"></a>堆内存调优简介</h5><p> <img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/7.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p> 代码测试：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> public class JVMTest &#123;  </span><br><span class="line">     public static void main(String[] args)&#123;  </span><br><span class="line">          long maxMemory = Runtime.getRuntime().maxMemory();//返回Java虚拟机试图使用的最大内存量。  </span><br><span class="line">          Long totalMemory = Runtime. getRuntime().totalMemory();//返回Java虚拟机中的内存总量。  </span><br><span class="line">          System.out.println(&quot;MAX_MEMORY =&quot;+maxMemory +&quot;(字节)、&quot;+(maxMemory/(double)1024/1024) + &quot;MB&quot;);  </span><br><span class="line">          System.out.println(&quot;TOTAL_ MEMORY = &quot;+totalMemory +&quot;(字节)&quot;+(totalMemory/(double)1024/1024) + &quot;MB&quot;);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Run as -&gt;Run Configurations中输入”-XX:+PrintGCDetails”可以查看堆内存运行原理图</p>
<p><strong>在jdk1.7中</strong></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/8.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><strong>在jdk1.8中</strong></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/9.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h5 id="通过参数设置自动触发垃圾回收"><a href="#通过参数设置自动触发垃圾回收" class="headerlink" title="通过参数设置自动触发垃圾回收"></a>通过参数设置自动触发垃圾回收</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">public class JVMTest &#123;</span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">          long maxMemory = Runtime.getRuntime().maxMemory();//返回Java虚拟机试图使用的最大内存量。</span><br><span class="line">          Long totalMemory = Runtime. getRuntime().totalMemory();//返回Java虚拟机中的内存总量。</span><br><span class="line">          System.out.println(&quot;MAX_MEMORY =&quot;+maxMemory +&quot;(字节)、&quot;+(maxMemory/(double)1024/1024) + &quot;MB&quot;);</span><br><span class="line">          System.out.println(&quot;TOTAL_ MEMORY = &quot;+totalMemory +&quot;(字节)&quot;+(totalMemory/(double)1024/1024) + &quot;MB&quot;);</span><br><span class="line">          String str = &quot;www.baidu.com&quot;;</span><br><span class="line">          while(true)&#123;</span><br><span class="line">              str += str + new Random().nextInt(88888888) + new Random().nextInt(99999999);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Run as -&gt;Run Configurations中输入设置“-Xmx8m –Xms8m –xx:+PrintGCDetails”可以参看垃圾回收机制原理</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/jvm/11.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>MapStruct介绍</title>
    <url>/2018/02/12/java/mapstruct/1/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>MapStruct在一个成熟可维护的工程中，细分模块后，domian工程最好不要被其他工程依赖，但是实体类一般存于domain之中，这样其他工程想获取实体类数据时就需要在各自工程写model，自定义model可以根据自身业务需要而并不需要映射整个实体属性。<br>mapstruct这个插件就是用来处理domin实体类与model类的属性映射，定义mapper接口，mapstruct就会自动的帮我们实现这个映射接口，避免了麻烦复杂的映射实现。</p>
<ul>
<li>Github地址：<a href="https://github.com/mapstruct/mapstruct/">https://github.com/mapstruct/mapstruct/</a></li>
<li>使用例子：<a href="https://github.com/mapstruct/mapstruct-examples">https://github.com/mapstruct/mapstruct-examples</a></li>
<li>MapStrcut与其它工具对比以及使用说明：<a href="http://www.tuicool.com/articles/uiIRjai">http://www.tuicool.com/articles/uiIRjai</a></li>
</ul>
<span id="more"></span>

<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>Mapper基本类：BasicObjectMapper，BasicObjectMapper包含了4个基本方法，单个和集合以及反转的单个和集合。</p>
<p>开发中如需要对象转换操作可直接新建interface并继承BasicObjectMapper，并在新建的接口上加上 @Mapper(componentModel = “spring”)， 如果是属性中包含其它类以及该类已经存在Mapper则注解中加上 users = {类名.class}，具体如何使用以及其他各种用法在此不再赘述（本文的重点是看标题，看标题，看标题），google不行可以找度娘， componentModel = “spring”该配置表示生成的实现类默认加上spring @Component注解，使用时可直接通过@Autowire进行注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ampmind.framework.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.InheritConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.InheritInverseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mappings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasicObjectMapper</span>&lt;<span class="title">SOURCE</span>, <span class="title">TARGET</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings(&#123;&#125;)</span></span><br><span class="line">    <span class="meta">@InheritConfiguration</span></span><br><span class="line">    <span class="function">TARGET <span class="title">to</span><span class="params">(SOURCE var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InheritConfiguration</span></span><br><span class="line">    <span class="function">List&lt;TARGET&gt; <span class="title">to</span><span class="params">(List&lt;SOURCE&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InheritInverseConfiguration</span></span><br><span class="line">    <span class="function">SOURCE <span class="title">from</span><span class="params">(TARGET var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InheritInverseConfiguration</span></span><br><span class="line">    <span class="function">List&lt;SOURCE&gt; <span class="title">from</span><span class="params">(List&lt;TARGET&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是两个不同的例子：<br>先贴一下两个Model类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ampmind.service.skumng.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类别编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String categoryCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类别名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategoryCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categoryCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategoryCode</span><span class="params">(String categoryCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.categoryCode = categoryCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategoryName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categoryName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategoryName</span><span class="params">(String categoryName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.categoryName = categoryName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CategoryVo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ampmind.service.api.protocol.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getParentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> parentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParentId</span><span class="params">(Integer parentId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentId = parentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.如何与Spring配合<br>CategoryMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ampmind.service.skumng.api.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ampmind.framework.api.base.BasicObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.ampmind.service.api.protocol.vo.CategoryVo;</span><br><span class="line"><span class="keyword">import</span> com.ampmind.service.domain.ProductCategory;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mappings;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> <span class="keyword">extends</span> <span class="title">BasicObjectMapper</span>&lt;<span class="title">CategoryVo</span>, <span class="title">ProductCategory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(source = &quot;code&quot;, target = &quot;categoryCode&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(source = &quot;name&quot;, target = &quot;categoryName&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">ProductCategory <span class="title">to</span><span class="params">(CategoryVo source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面重写了to方法，注意如果属性名一样可以不用重写。保持接口空的就行，有不一样的需要重写to方法，并在方法上加上 @Mappings注解和子注解<br>spring注入并使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryMapper categoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CategoryVo vo = <span class="keyword">new</span> CategoryVo;</span><br><span class="line">        vo.setCategoryCode(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        vo.setCategoryName(<span class="string">&quot;属性名称&quot;</span>);</span><br><span class="line">        ProductCategory pc = categoryMapper.to(vo);<span class="comment">// 通过to方法得到 ProductCategory</span></span><br><span class="line"></span><br><span class="line">        CategoryVo vo1 = categoryMapper.form(pc);<span class="comment">// 通过from方法得到CategoryVo，既反转to方法。</span></span><br><span class="line"></span><br><span class="line">        List&lt;ProductCategory&gt; pcList = categoryMapper.to(Arrays.asList(vo, vo1));<span class="comment">// 通过to方法从集合得到转换后的集合</span></span><br><span class="line"></span><br><span class="line">        List&lt;CategoryVo&gt; voList = categoryMapper.from(pcList); <span class="comment">// 反转集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.如何直接使用<br>CategoryMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ampmind.service.skumng.api.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ampmind.framework.api.base.BasicObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.ampmind.service.skumng.api.protocol.vo.CategoryVo;</span><br><span class="line"><span class="keyword">import</span> com.ampmind.service.skumng.domain.ProductCategory;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mapping;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.Mappings;</span><br><span class="line"><span class="keyword">import</span> org.mapstruct.factory.Mappers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> <span class="keyword">extends</span> <span class="title">BasicObjectMapper</span>&lt;<span class="title">CategoryVo</span>, <span class="title">ProductCategory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    CategoryMapper MAPPER = Mappers.getMapper(CategoryMapper.class);</span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(source = &quot;code&quot;, target = &quot;categoryCode&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(source = &quot;name&quot;, target = &quot;categoryName&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">ProductCategory <span class="title">to</span><span class="params">(CategoryVo source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接可以通过main方法进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CategoryVo vo = <span class="keyword">new</span> CategoryVo;</span><br><span class="line">        vo.setCategoryCode(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        vo.setCategoryName(<span class="string">&quot;属性名称&quot;</span>);</span><br><span class="line">        ProductCategory pc = CategoryMapper.MAPPER.to(vo);<span class="comment">// 通过to方法得到 ProductCategory</span></span><br><span class="line"></span><br><span class="line">        CategoryVo vo1 = CategoryMapper.MAPPER.form(pc);<span class="comment">// 通过from方法得到CategoryVo，既反转to方法。</span></span><br><span class="line"></span><br><span class="line">        List&lt;ProductCategory&gt; pcList = CategoryMapper.MAPPER.to(Arrays.asList(vo, vo1));<span class="comment">// 通过to方法从集合得到转换后的集合</span></span><br><span class="line"></span><br><span class="line">        List&lt;CategoryVo&gt; voList = CategoryMapper.MAPPER.from(pcList); <span class="comment">// 反转集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MapStruct转换list的问题</title>
    <url>/2018/02/13/java/mapstruct/2/</url>
    <content><![CDATA[<p>mapstruct在转换list之前必须有一个前置转换，即他们的实体之间的转换 </p>
<p>错误的转换方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;EggVo&gt; <span class="title">listpoTovo</span><span class="params">(List&lt;Egg&gt; po)</span></span>;</span><br></pre></td></tr></table></figure>

<p>正确的转换方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapping(source = &quot;id&quot;, target = &quot;lid&quot;)</span></span><br><span class="line"><span class="function">EggVo <span class="title">poTovo</span><span class="params">(Egg po)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;EggVo&gt; <span class="title">listpoTovo</span><span class="params">(List&lt;Egg&gt; po)</span></span>;</span><br></pre></td></tr></table></figure>

<p>添加了实体转换之后，就可以正常的进行list转换了，同理把属性映射直接加在list转换上也是不行的，要加在实体转换上，然后list的转换也会继承这和属性的映射。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title>sonarqube和mvn整合</title>
    <url>/2018/03/02/java/sonarqube/1/</url>
    <content><![CDATA[<p>SonarQube(Sonar)是一个用于管理代码质量的开源平台。SonarQube目前已支持超过20种主流编程语言，它管理的代码质量主要涉及7个维度:架构与设计、重复、单元测试、复杂度、潜在的bug、代码标准、注释。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/4.png"></p>
<p>  本文，笔者将围绕搭建SonarQube这样的代码质量管理平台这个主题展开，结合java代码实例一步步讲述具体的过程，其中涉及Sonar的下载安装、创建对应Mysql数据库以及运行和管理，并对实践过程中出现的一些问题进行了分析和解决。</p>
<p>  注：本文中所有的实践都是在Docker虚拟机下进行，但目测同样适用于各个平台。</p>
  <span id="more"></span>
<ol>
<li><strong>安装postgres数据库</strong><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postgres:</span><br><span class="line">	image:</span><br><span class="line">		registry.cn-shenzhen.aliyuncs.com/zhouqi/postgres:1.0</span><br><span class="line">	environment:</span><br><span class="line">		- POSTGRES_USER=root</span><br><span class="line">		- POSTGRES_PASSWORD=000000</span><br><span class="line">	ports:</span><br><span class="line">		- &quot;5432:5432&quot;</span><br><span class="line">	container_name:</span><br><span class="line">		postgres</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p><strong>安装sonarqube</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sonarqube:</span><br><span class="line">	image:</span><br><span class="line">		registry.cn-shenzhen.aliyuncs.com/zhouqi/sonarqube:2.0</span><br><span class="line">	depends_on:</span><br><span class="line">		- postgres</span><br><span class="line">	environment:</span><br><span class="line">		- SONARQUBE_JDBC_USERNAME=root</span><br><span class="line">		- SONARQUBE_JDBC_PASSWORD=000000</span><br><span class="line">		- SONARQUBE_JDBC_URL=jdbc:postgresql://192.168.137.60/sonar</span><br><span class="line">	ports:</span><br><span class="line">		- &quot;9000:9000&quot;</span><br><span class="line">		- &quot;9092:9092&quot;</span><br><span class="line">	container_name:</span><br><span class="line">		sonarqube</span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置maven</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;pluginGroups&gt;</span><br><span class="line">        &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt;</span><br><span class="line">    &lt;/pluginGroups&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;sonar&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;!-- Optional URL to server. Default value is http://localhost:9000 --&gt;</span><br><span class="line">                &lt;sonar.host.url&gt;</span><br><span class="line">                  http://myserver:9000</span><br><span class="line">                &lt;/sonar.host.url&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">     &lt;/profiles&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>idea运行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install</span><br><span class="line">mvn sonar:sonar</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sonar</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读Spring IOC原理（一）</title>
    <url>/2018/05/09/java/spring/1/</url>
    <content><![CDATA[<h4 id="源码解读Spring-IOC原理（一）"><a href="#源码解读Spring-IOC原理（一）" class="headerlink" title="源码解读Spring IOC原理（一）"></a>源码解读Spring IOC原理（一）</h4><h5 id="什么是IOC-DI？"><a href="#什么是IOC-DI？" class="headerlink" title="什么是IOC/DI？"></a>什么是IOC/DI？</h5><p>IoC 容器：最主要是完成了完成对象的创建和依赖的管理注入等等。</p>
<p>先从我们自己设计这样一个视角来考虑：</p>
<p>所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。<br>XmlXmlXml<br>对象和对象关系怎么表示？</p>
<p>可以用 xml ， properties 文件等语义化配置文件表示。</p>
<p>描述对象关系的文件存放在哪里？</p>
<p>可能是 classpath ， filesystem ，或者是 URL 网络资源， servletContext 等。</p>
<p>回到正题，有了配置文件，还需要对配置文件解析。</p>
<p>不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？ 在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。</p>
<p>如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器</p>
<span id="more"></span>

<h5 id="Spring-IOC体系结构？"><a href="#Spring-IOC体系结构？" class="headerlink" title="Spring IOC体系结构？"></a>Spring IOC体系结构？</h5><h6 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h6><p>Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，其相互关系<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/1.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"><br>其中BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范，BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为.</p>
<p>最基本的IOC容器接口BeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;    </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，    </span></span><br><span class="line">     <span class="comment">//如果需要得到工厂本身，需要转义           </span></span><br><span class="line">     String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>; </span><br><span class="line">        </span><br><span class="line">     <span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例    </span></span><br><span class="line">     <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。    </span></span><br><span class="line">     <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean    </span></span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例    </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到bean实例的Class类型    </span></span><br><span class="line">    <span class="function">Class <span class="title">getType</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来    </span></span><br><span class="line">   String[] getAliases(String name);    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</p>
<p>而要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。其中XmlBeanFactory就是针对最基本的ioc容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述）,如果说XmlBeanFactory是容器中的屌丝，ApplicationContext应该算容器中的高帅富.<br>ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。</p>
<blockquote>
<p>从ApplicationContext接口的实现，我们看出其特点：</p>
</blockquote>
<ol>
<li>支持信息源，可以实现国际化。（实现MessageSource接口）</li>
<li>访问资源。(实现ResourcePatternResolver接口，这个后面要讲)</li>
<li>支持应用事件。(实现ApplicationEventPublisher接口)</li>
</ol>
<h6 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h6><p>SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/2.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。<br>Bean 的解析主要就是对Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/3.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 阅读源码笔记</title>
    <url>/2018/05/24/java/spring/5/</url>
    <content><![CDATA[<h4 id="Spring-阅读源码笔记（原创）"><a href="#Spring-阅读源码笔记（原创）" class="headerlink" title="Spring 阅读源码笔记（原创）"></a>Spring 阅读源码笔记（原创）</h4><h5 id="什么是控制反转"><a href="#什么是控制反转" class="headerlink" title="什么是控制反转"></a>什么是控制反转</h5><p>所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。</p>
<ul>
<li><p>对象和对象关系怎么表示？<br>可以用 xml ， properties 文件等语义化配置文件表示。</p>
</li>
<li><p>描述对象关系的文件存放在哪里？<br>可能是 classpath ， filesystem ，或者是 URL 网络资源， servletContext 等。</p>
</li>
<li><p>有了配置文件，还需要对配置文件解析<br>不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？ 在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器</p>
</li>
</ul>
<span id="more"></span>

<h5 id="IOC容器接口"><a href="#IOC容器接口" class="headerlink" title="IOC容器接口"></a>IOC容器接口</h5><p><strong>BeanFactory</strong></p>
<p>最顶层的一个接口类，它定义了IOC容器的基本功能规范，他下面有三个子类分别是（ListableBeanFactory，HierarchicalBeanFactory，AutowireCapableBeanFactory），这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。</p>
<ul>
<li><p>ListableBeanFactory<br>表示这些 Bean 是可列表的</p>
</li>
<li><p>HierarchicalBeanFactory<br>表示这些 Bean 是有继承关系的</p>
</li>
<li><p>AutowireCapableBeanFactory<br>表示这些 Bean 的自动装配规则</p>
</li>
</ul>
<h5 id="IOC容器实现"><a href="#IOC容器实现" class="headerlink" title="IOC容器实现"></a>IOC容器实现</h5><ul>
<li><p>XmlBeanFactory<br>最基础的容器实现，这个IOC容器可以读取XML文件定义XML文件中对bean的描述（BeanDefinition）</p>
</li>
<li><p>ClasspathXmlApplicationContext<br>高级的IOC容器实现</p>
</li>
<li><p>ApplicationContext<br>高级的IoC容器实现，并附加了（国际化MessageSource，访问资源ResourcePatternResolver，应用事件ApplicationEventPublisher）的实现</p>
</li>
</ul>
<p><strong>SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的</strong></p>
<h5 id="IOC容器初始化"><a href="#IOC容器初始化" class="headerlink" title="IOC容器初始化"></a>IOC容器初始化</h5><ul>
<li>BeanDefinition的Resource定位</li>
<li>BeanDefinition的Resource载入</li>
<li>BeanDefinition的Resource注册</li>
</ul>
<hr>
<h5 id="IOC容器创建过程"><a href="#IOC容器创建过程" class="headerlink" title="IOC容器创建过程"></a>IOC容器创建过程</h5><p>IOC容器创建分为两种</p>
<blockquote>
<p>XmlBeanFactory<br>FileSystemXmlApplicationContext</p>
</blockquote>
<h5 id="XmlBeanFactory创建"><a href="#XmlBeanFactory创建" class="headerlink" title="XmlBeanFactory创建"></a>XmlBeanFactory创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息</span></span><br><span class="line"> ClassPathResource resource =<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;application-context.xml&quot;</span>);</span><br><span class="line"><span class="comment">//创建DefaultListableBeanFactory</span></span><br><span class="line"> DefaultListableBeanFactory factory =<span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory</span></span><br><span class="line"> XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line"><span class="comment">//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用</span></span><br><span class="line"> reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure>
<h5 id="FileSystemXmlApplicationContext创建"><a href="#FileSystemXmlApplicationContext创建" class="headerlink" title="FileSystemXmlApplicationContext创建"></a>FileSystemXmlApplicationContext创建</h5><ul>
<li>执行FileSystemXmlApplicationContext的构造函数</li>
<li>设置资源加载器（父类super）和资源定位（AbstractRefreshableConfigApplicationContext中的setConfigLocations）</li>
<li>AbstractApplicationContext的refresh函数载入Bean</li>
<li>AbstractRefreshableApplicationContext实现载入Bean</li>
<li>AbstractBeanDefinitionReader读取Bean定义资源</li>
<li>资源加载器获取要读入的资源</li>
<li>XmlBeanDefinitionReader加载Bean定义资源</li>
<li>DocumentLoader将Bean定义资源转换为Document对象</li>
<li>XmlBeanDefinitionReader解析载入的Bean定义资源文件</li>
<li>DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析</li>
<li>BeanDefinitionParserDelegate解析&lt;Bean&gt;定义资源文件中的Bean元素</li>
<li>BeanDefinitionParserDelegate解析&lt;property&gt;元素</li>
<li>解析&lt;property&gt;元素的子元素</li>
<li>解析&lt;list&gt;子元素</li>
<li>解析过后的BeanDefinition在IoC容器中的注册</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 配置中心 Github SSH验证（二）</title>
    <url>/2020/02/02/java/spring-cloud/config-server-github-ssh-2/</url>
    <content><![CDATA[<h3 id="Spring-Cloud-配置中心-Github-SSH验证（二）"><a href="#Spring-Cloud-配置中心-Github-SSH验证（二）" class="headerlink" title="Spring Cloud 配置中心 Github SSH验证（二）"></a>Spring Cloud 配置中心 Github SSH验证（二）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在上一章讲解了如何使用Spring Cloud配置中心读取Github SSH的文件后，发现如果将<code>spring.cloud.config.server.git.private-key=</code>配置的值设置为一个环境变量，在JVM:JAVA_OPS是不可行的，在网上找了很多资料国内的解决方案是使用<code>private_key_file</code>，但官方并未提供，最后找到了解决方案，下面将给出干货提供给大家。</p>
<p><strong>注意：前面工作不在叙述，请自行参考，<a href="http://blog.appydm.com/java/spring-cloud/java/spring-cloud/config-server-github-ssh/">Spring Cloud 配置中心 Github SSH验证（一）</a></strong></p>
<span id="more"></span>


<h4 id="校验密钥"><a href="#校验密钥" class="headerlink" title="校验密钥"></a>校验密钥</h4><p>续密钥生成后，执行<code>ssh -vT git@github.com</code>进行连接的身份验证测试，然后在增加到github中，如果服务器要使用，直接将<code>id_rsa</code>，<code>known_hosts</code>，复制到服务器上就可以了。</p>
<p>默认情况下<code>.ssh/id_rsa</code>是在GIT SSH身份验证期间发送的，如果您在下面有另一个名为RSA的文件，那么你可以<code>.ssh</code>下创建一个<code>config</code>配置文件并标识该文件内容如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">	IdentityFile ~/.ssh/mygitid_rsa</span><br></pre></td></tr></table></figure>

<p><strong>生成SSH的时候，一定要输入密码，处于安全考虑</strong></p>
<h4 id="Spring-Cloud-配置中心properties"><a href="#Spring-Cloud-配置中心properties" class="headerlink" title="Spring Cloud 配置中心properties"></a>Spring Cloud 配置中心properties</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">xxxx</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.basedir</span>=<span class="string">./tmp/configv	- 本地保存的配置地址</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.clone-on-start</span>=<span class="string">true		- 启动时就克隆配置缓存到本地</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.force-pull</span>=<span class="string">true		- 本地副本是脏的,强制从远程存储库拉取配置</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">/dev	- GIT搜索目录位置</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.passphrase</span>=<span class="string">123456	- 生成SSH的密码</span></span><br></pre></td></tr></table></figure>

<p>现在可以尝试启动配置中心来获取配置信息了</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 配置中心 Github SSH验证（一）</title>
    <url>/2020/01/30/java/spring-cloud/config-server-github-ssh/</url>
    <content><![CDATA[<h3 id="Spring-Cloud-配置中心-Github-SSH验证"><a href="#Spring-Cloud-配置中心-Github-SSH验证" class="headerlink" title="Spring Cloud 配置中心 Github SSH验证"></a>Spring Cloud 配置中心 Github SSH验证</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，方便部署与运维。</p>
<p>目前有一些用的比较多的开源的配置中心，比如携程的 Apollo、阿里Nacos、百度的 Disconf 等，对比 Spring Cloud Config，这些配置中心功能更加强大。有兴趣的可以拿来试一试。</p>
<p>接下来，我们开始使用Spring Cloud来搭建一个配置中心，并以 github 作为配置存储。除了 git 外，还可以用数据库、svn、本地文件等作为存储。</p>
<span id="more"></span>

<h4 id="Github-SSH配置"><a href="#Github-SSH配置" class="headerlink" title="Github SSH配置"></a>Github SSH配置</h4><h5 id="密匙生成"><a href="#密匙生成" class="headerlink" title="密匙生成"></a>密匙生成</h5><p>Windows下生成密匙，可以直接使用<code>Git Bash</code>工具，执行<code>ssh-keygen -m PEM -t rsa -b 4096</code>命令</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130201553870.png" alt="image-20200130201553870"></p>
<p>在弹出来的选项直接按回车就可以了，密匙生成目录<code>C:\Users\用户\.ssh</code></p>
<ul>
<li>公钥<code>id_rsa.pub</code></li>
<li>私钥<code>id_rsa</code></li>
</ul>
<h5 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h5><p>点击右上角头像，弹出的菜单中，点击<code>Settings</code>进入设置</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130205501744.png" alt="image-20200130205501744" style="zoom:50%;" />

<p>点击<code>SSH and GPG keys</code>，进入SSH的key设置</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130205550957.png" alt="image-20200130205550957" style="zoom:50%;" />

<p>点击<code>New SSH key</code>，进行SSH的添加，记住这里的Title随便填写，Key就是我们的公钥，打开公钥内容全部复制粘贴到Key的输入框中，点击<code>Add SSH key</code>即可！公钥是<code>ssh-rsa </code>开头</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130205705772.png" alt="image-20200130205705772" style="zoom:50%;" />

<p>添加公钥后就会显示</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130205930159.png" alt="image-20200130205930159" style="zoom:50%;" />



<h5 id="校验密匙"><a href="#校验密匙" class="headerlink" title="校验密匙"></a>校验密匙</h5><p>这时我们回到Windows上，打开Git Bash，在执行<code>ssh -vT git@github.com</code>命令</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130210138318.png" alt="image-20200130210138318" style="zoom: 67%;" />

<p>只要出现<code>You&#39;ve successfully authenticated</code>就证明，已经验证成功了。</p>
<blockquote>
<p>如果是内网搭建的Gitlab，可以使用 <code>ssh -vT git@ip -p 端口</code>命令</p>
</blockquote>
<h4 id="Spring-Cloud-配置中心"><a href="#Spring-Cloud-配置中心" class="headerlink" title="Spring Cloud 配置中心"></a>Spring Cloud 配置中心</h4><h5 id="配置文件存放"><a href="#配置文件存放" class="headerlink" title="配置文件存放"></a>配置文件存放</h5><p>在github中新建一个仓库，这个仓库一定要是<strong>干净</strong>的，就是最好不要有其他文件存在，不然会报错。因为我们使用了SSH，所以这是一个<strong>私库</strong>，我存放的位置是<code>local/eureka.properties</code>。</p>
<h5 id="POM依赖"><a href="#POM依赖" class="headerlink" title="POM依赖"></a>POM依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h5><p><strong>properties文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">git@github.com:Figthing/hyper-config-repo.git</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.strict-host-key-checking</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.ignore-local-ssh-settings</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">/local</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.private-key</span>=<span class="string">-----BEGIN RSA PRIVATE KEY-----\n\</span></span><br><span class="line"><span class="string">aaaa\</span></span><br><span class="line"><span class="string">xxxx\n\</span></span><br><span class="line"><span class="string">-----END RSA PRIVATE KEY-----</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>参数说明</strong></p>
<ul>
<li>spring.cloud.config.server.git.uri：配置的Github仓库的ssh地址</li>
<li>spring.cloud.config.server.git.strict-host-key-checking：true-使用用户名密码，false-使用ssh key</li>
<li>spring.cloud.config.server.git.ignore-local-ssh-settings：true-ssh 登陆方式</li>
<li>spring.cloud.config.server.git.search-paths：git仓库地址下的相对地址 多个用逗号”,”分割。</li>
<li>spring.cloud.config.server.git.private-key：私钥内容（可以使用变量代替），这里要注意几点<ul>
<li>第一行使用<code>\n\</code>结尾</li>
<li>内容行使用<code>\</code>结尾</li>
<li>End结束之前使用<code>\n\</code>结尾</li>
</ul>
</li>
</ul>
<p><strong>yaml文件</strong></p>
<p>因我项目使用的<code>properties</code>，至于yaml就自行百度吧，应该相差不大。</p>
<h4 id="启动验证"><a href="#启动验证" class="headerlink" title="启动验证"></a>启动验证</h4><p><strong>main类文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问配置</strong></p>
<p>我们在URL中输入<code>http://localhost:8802/eureka/local</code></p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/spring-cloud/config/image-20200130213543634.png" alt="image-20200130213543634" style="zoom:50%;" />


<p>Spring cloud config 的URL与配置文件的映射关系如下:</p>
<blockquote>
<p>/{application}/{profile}[/{label}]<br>/{application}-{profile}.yml<br>/{label}/{application}-{profile}.yml<br>/{application}-{profile}.properties<br>/{label}/{application}-{profile}.properties</p>
</blockquote>
<p>我这里的application = eureka，profile = local</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>ApiGateway整合Swagger2</title>
    <url>/2019/10/09/java/spring-cloud/spring-cloud-gateway-1/</url>
    <content><![CDATA[<h3 id="ApiGateway整合Swagger2"><a href="#ApiGateway整合Swagger2" class="headerlink" title="ApiGateway整合Swagger2"></a>ApiGateway整合Swagger2</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>最近在项目中尝试使用Spring Cloud.Greenwich版整合Swagger2。发现Swagger并不支持以WebFlux为底层的Gateway，无法集成，运行报错。下面分享我的解决思路，和关键代码。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>	</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><p>配置SwaggerProvider，获取Api-doc，即SwaggerResources。<code>SwaggerProvider.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerProvider</span> <span class="keyword">implements</span> <span class="title">SwaggerResourcesProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_URI = <span class="string">&quot;/v2/api-docs&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RouteLocator routeLocator;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> GatewayProperties gatewayProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;SwaggerResource&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;SwaggerResource&gt; resources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; routes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">//取出gateway的route</span></span><br><span class="line">		routeLocator.getRoutes().subscribe(route -&gt; routes.add(route.getId()));</span><br><span class="line">		<span class="comment">//结合配置的route-路径(Path)，和route过滤，只获取有效的route节点</span></span><br><span class="line">		gatewayProperties.getRoutes()</span><br><span class="line">				.stream()</span><br><span class="line">				.filter(routeDefinition -&gt; routes.contains(routeDefinition.getId()))</span><br><span class="line">				.forEach(routeDefinition -&gt; routeDefinition.getPredicates().stream()</span><br><span class="line">						.filter(predicateDefinition -&gt; (<span class="string">&quot;Path&quot;</span>).equalsIgnoreCase(predicateDefinition.getName()))</span><br><span class="line">						.forEach(predicateDefinition -&gt; &#123;</span><br><span class="line">							resources.add(swaggerResource(</span><br><span class="line">									routeDefinition.getId(),</span><br><span class="line">									predicateDefinition.getArgs().get(NameUtils.GENERATED_NAME_PREFIX + <span class="string">&quot;0&quot;</span>).replace(<span class="string">&quot;/**&quot;</span>, API_URI)</span><br><span class="line">							));</span><br><span class="line">						&#125;));</span><br><span class="line">		<span class="keyword">return</span> resources;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> SwaggerResource <span class="title">swaggerResource</span><span class="params">(String name, String location)</span> </span>&#123;</span><br><span class="line">		SwaggerResource swaggerResource = <span class="keyword">new</span> SwaggerResource();</span><br><span class="line">		swaggerResource.setName(name);</span><br><span class="line">		swaggerResource.setLocation(location);</span><br><span class="line">		swaggerResource.setSwaggerVersion(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> swaggerResource;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Gateway里没有配置SwaggerConfig，而运行Swagger-ui又需要依赖一些接口，所以我的想法是自己建立相应的swagger-resource端点<code>SwaggerHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression(&quot;#&#123;&#x27;true&#x27;.equals(environment[&#x27;neusoft.hype.swagger.enable&#x27;])&#125;&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/swagger-resources&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="keyword">private</span> SecurityConfiguration securityConfiguration;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="keyword">private</span> UiConfiguration uiConfiguration;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SwaggerResourcesProvider swaggerResources;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SwaggerHandler</span><span class="params">(SwaggerResourcesProvider swaggerResources)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.swaggerResources = swaggerResources;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/configuration/security&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Mono&lt;ResponseEntity&lt;SecurityConfiguration&gt;&gt; securityConfiguration() &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.just(<span class="keyword">new</span> ResponseEntity&lt;&gt;(</span><br><span class="line">				Optional.ofNullable(securityConfiguration).orElse(SecurityConfigurationBuilder.builder().build()), HttpStatus.OK));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/configuration/ui&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Mono&lt;ResponseEntity&lt;UiConfiguration&gt;&gt; uiConfiguration() &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.just(<span class="keyword">new</span> ResponseEntity&lt;&gt;(</span><br><span class="line">				Optional.ofNullable(uiConfiguration).orElse(UiConfigurationBuilder.builder().build()), HttpStatus.OK));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ResponseEntity&gt; <span class="title">swaggerResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.just((<span class="keyword">new</span> ResponseEntity&lt;&gt;(swaggerResources.get(), HttpStatus.OK)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>说说分布式事务(一)</title>
    <url>/2018/03/06/java/transaction/1/</url>
    <content><![CDATA[<h4 id="2PC-两阶段事务提交"><a href="#2PC-两阶段事务提交" class="headerlink" title="2PC(两阶段事务提交)"></a>2PC(两阶段事务提交)</h4><p>两阶段事务提交简化图<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/5.jpeg"></p>
<span id="more"></span>

<h4 id="两阶段事务提交异常点"><a href="#两阶段事务提交异常点" class="headerlink" title="两阶段事务提交异常点"></a>两阶段事务提交异常点</h4><ol>
<li>节点本身故障(比如Down机)</li>
<li>节点之间通信故障</li>
</ol>
<h4 id="两阶段事务提交错误点分析"><a href="#两阶段事务提交错误点分析" class="headerlink" title="两阶段事务提交错误点分析"></a>两阶段事务提交错误点分析</h4><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/6.jpeg"></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>图中有问号的条目,是我不确定的地方,但是不影响这个分布式事务的结果</li>
<li>图中的感叹号条目,个人感觉其实也是允许先发消息再记录日志的,但是如果这样子做以后发生Down机,客户端或者TM都需要向其它机器询问结果才能得到结论(而这样子做的话会大大加长分布事务的阻塞时间和事务处理的复杂度,同时这样做会有一个致命的缺陷,抹除了一部分可以自恢复场景。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>说说分布式事务(二)</title>
    <url>/2018/03/06/java/transaction/2/</url>
    <content><![CDATA[<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><blockquote>
<p>以两阶段提交来说，主持人收到一个提案请求，打电话跟每个组员询问是否通过并统计回复，然后将最后决定打电话通知各组员。要是主持人在跟第一位组员通完电话后失忆，而第一位组员在得知结果并执行后老人痴呆，那么即使重新选出主持人，也没人知道最后的提案决定是什么，也许是通过，也许是驳回，不管大家选择哪一种决定，都有可能与第一位组员已执行过的真实决定不一致，老板就会不开心认为决策小组沟通有问题而解雇。三阶段提交即是引入了另一个步骤，主持人打电话跟组员通知请准备通过提案，以避免没人知道真实决定而造成决定不一致的失业危机。为什么能够解决二阶段提交的问题呢？回到刚刚提到的状况，在主持人通知完第一位组员请准备通过后两人意外失忆，即使没人知道全体在第一阶段的决定为何，全体决策组员仍可以重新协调过程或直接否决，不会有不一致决定而失业。那么当主持人通知完全体组员请准备通过并得到大家的再次确定后进入第三阶段，当主持人通知第一位组员请通过提案后两人意外失忆，这时候其他组员再重新选出主持人后，仍可以知道目前至少是处于准备通过提案阶段，表示第一阶段大家都已经决定要通过了，此时便可以直接通过</p>
</blockquote>
<span id="more"></span>

<p>以上资料来自wiki百科,说明在2PC过程中,在第二个阶段当协调者通知第一个客户端A,并且第一个客户端刚好执行完毕以后,这两台机器都Down掉了,而恰好这N-1台机器投的都是Yes票(都处于不确定的状态),这个时候整个事务就会被Block,暂时称之为聋哑事件</p>
<ol>
<li>客户端A投的是Abort票,那么由于协调者和客户端A都Down掉,那么整个事务应该是abort</li>
<li>客户端A投的是commit票,并且协调者决定commit,那么整个事务应该是commit</li>
<li>客户端A投的是commit票,并且协调者由于自身的原因决定abort,那么整个事务应该是abort</li>
</ol>
<p>在3PC中引入了一个预提交的状态</p>
<ol>
<li>当在第二阶段出现聋哑事件,那么这N-1台机器可以根据超时机制直接abort掉,因为客户端A如果提交了事务,只是预提交,当该机器重启以后只要询问周边机器事务状态,简单的将事务回滚或者提交事务,就能保持事务的最终一致性</li>
<li>当进行到第三阶段的时候,如果发生聋哑事件,那么其它处于「不确定状态」的客户端会直接执行commit,而不会像2PC一样导致事务block,但是这样会有一个风险(进入到第三个阶段说明客户端在第一阶段投的都是Yes),因为在聋哑事件中,那台Down掉的机器在第二阶段中给协调者发送的不是prepared,这个时候协调者收到消息给客户端发送的是abort命令.所以3PC只是乐观的认为只要你第一阶段大家投的都是Yes,那么最后成功提交的几率很大</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>说说分布式事务(三)</title>
    <url>/2018/03/06/java/transaction/3/</url>
    <content><![CDATA[<h4 id="最终一致性-一"><a href="#最终一致性-一" class="headerlink" title="最终一致性(一)"></a>最终一致性(一)</h4><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>TCC是由支付宝架构师提供的一种柔性解决分布式事务解决方案,主要包括三个步骤:<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/7.jpeg"></p>
<span id="more"></span>

<h4 id="TCC流程"><a href="#TCC流程" class="headerlink" title="TCC流程"></a>TCC流程</h4><p>TCC的关键流程如下图(以下单和扣减库存为例子)<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/8.jpeg"></p>
<p>Q: 预生成订单失败了,为什么要通过TCC执行预处理数据回滚?<br>A: 可能预生成订单成功,但是接口返回失败(超时失败),所以预处理在某些情况下是有预处理数据,需要清理</p>
<h4 id="TCC异常场景"><a href="#TCC异常场景" class="headerlink" title="TCC异常场景"></a>TCC异常场景</h4><p>在整个流程,我们主要需要关注的是cancel失败和confirm失败引起的数据不一致现象<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/9.jpeg"></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>TCC服务支持接口失败重试,所以对TCC暴露的接口都需要满足幂等性(根据事务Id很好满足)</li>
<li>基于TCC的中心化事务一致性解决方法,各个应用服务器如果需要感知某次事务是否成功的成本很高,所以对于自身而言进行事务补偿成本就会很高.举个例子:<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/10.jpeg"></li>
</ol>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ol>
<li><p>是否一定需要TCC服务器? 不一定,可以让交易链路来充当TCC服务器的角色,但是长期来看,TCC相当于是一个公用的组件,所以其它地方也需要TCC分布式事务,可以公用这一个组件(交易链路可以完成TCC所能完成的一切操作,把TCC单独部署一个服务,仅仅是考虑整个系统的抽象结构和功能复用)</p>
</li>
<li><p>这里说的预处理,指的是什么? 在整个分布式事务中预处理的含义其实很广泛,比如订单,所谓的预处理就是生成订单,但是用户真实是看不到这些订单的,至于具体实现是在一张新表中记录还是在原有的订单表是加上标记位,具体实现方式由自己统筹考虑(当然还需要考虑记录事务Id);像减库存这种预处理,可以直接减少原始库存,再通过另外一张表来记录这次事务Id操作了哪个Sku的库存数量,当然也可以不减少库存只记录操作,但是这种方式在计算实际库存的时候复杂度会提高(需要减掉预处理的那部分)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>说说分布式事务(四)</title>
    <url>/2018/03/06/java/transaction/4/</url>
    <content><![CDATA[<h4 id="最终一致性-二"><a href="#最终一致性-二" class="headerlink" title="最终一致性(二)"></a>最终一致性(二)</h4><h4 id="基于MQ的分布式事务补偿机制"><a href="#基于MQ的分布式事务补偿机制" class="headerlink" title="基于MQ的分布式事务补偿机制"></a>基于MQ的分布式事务补偿机制</h4><h4 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h4><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/11.jpeg"></p>
<span id="more"></span>

<h4 id="异常场景处理"><a href="#异常场景处理" class="headerlink" title="异常场景处理"></a>异常场景处理</h4><ol>
<li>预创建订单失败:如果实际预创建订单成功,订单定时补偿机制,定时删除这部分订单,不影响数据一致性,下单失败</li>
<li>预扣减库存失败:如果预扣减库存真实失败,则下单失败(订单由定时补偿机制定时删除,其它应用参照场景4的处理方式,下单失败;如果实际预扣减库存成功,参照场景4的处理方式,下单失败</li>
<li>实际创建订单失败:如果创建订单真实失败(不需要发送下单失败消息,防止实际创建订单成功场景),订单的预处理数据通过订单的定时补偿机制尝试删除(需要考虑事务处理时间,将超过某个时间范围该事务还处于预处理状态的订单删除),下单失败;如果实际创建订单成功,其它应用参照场景4的处理方式,下单成功(提示用户下单失败)</li>
<li>发送订单创建成功消息失败/库存服务由于各种原因没有接到下单成功消息:库存服务定时轮询处理数据(需要考虑事务处理时间,将超过某个时间范围该事务还处于预处理状态的订单筛选出来),询问订单服务改订单Id对应的订单是否创建成功,根据订单创建成功与否选取相应的事务补偿机制</li>
</ol>
<h4 id="和TCC的比较"><a href="#和TCC的比较" class="headerlink" title="和TCC的比较"></a>和TCC的比较</h4><ol>
<li>TCC是把所有的订单创建步骤平等看待,只要有一个失败,整个下单流程全部失败(比较TCC里面的confirm失败和基于MQ实际创建订单失败的补偿难易程度)</li>
<li>TCC是通过发消息给TCC服务器,然后由TCC服务调用应用服务;基于MQ的分布式事务补偿机制,是通过将消息发送到MQ,然后由应用自己去监听MQ的事件</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>说说分布式事务(五)</title>
    <url>/2018/03/06/java/transaction/5/</url>
    <content><![CDATA[<h4 id="业务回补"><a href="#业务回补" class="headerlink" title="业务回补"></a>业务回补</h4><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>业务对资金进行操作</p>
<h4 id="简化流程"><a href="#简化流程" class="headerlink" title="简化流程"></a>简化流程</h4><p>整个资金平台会和支付宝进行交互(冻结金额,出账金额),对这两个动作支付宝都会返回成功或者失败,当然还有异常流接口超时(实际成功/实际失败).</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/12.png"></p>
<span id="more"></span>

<p>正常流的业务,我们都可以根据实际的返回进行自己业务逻辑的处理,但是异常流对于调用方其实不知道实际结果,这个时候就需要进行业务数据回补,丰富一下调用时序图</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/13.png"></p>
<p>对资金进行操作以后,如果最终是成功的话,都会发送相应的成功消息,业务可以根据实际情况接受消息进行处理,对应的流程图为</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/14.png"></p>
<p>自身业务,需要监听调用方的业务消息,因为会出现接口返回失败(比如说接口超时),但是实际成功的场景,通过监听成功消息进行流程回溯</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/15.png"></p>
<p>涉及异步更新的操作,都会存在短暂的状态不一致的情况,当数据处于中间状态,可能会出现业务重复提交的情况,这个就需要业务上规避类似的问题(比如对于资金会加入审核流程)</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>War包二次开发技巧</title>
    <url>/2019/10/11/java/war/1/</url>
    <content><![CDATA[<h3 id="War包二次开发技巧"><a href="#War包二次开发技巧" class="headerlink" title="War包二次开发技巧"></a>War包二次开发技巧</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>近期拿到一个war包项目，里面没有认证功能，也没有源码。对于系统安全来说，直接能访问里面的数据，并对数据操作，是相当不安全的。所以想在项目里面增加一个简单的Basic认证功能，并且使用idea工具能够快速热部署开发。</p>
<h4 id="Tomcat模式"><a href="#Tomcat模式" class="headerlink" title="Tomcat模式"></a>Tomcat模式</h4><p>使用Tomcat来进行Basic认证控制新增<code>config/tomcat-users.xml</code>内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tomcat.apache.org/xml&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;test&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>修改war中的web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span>protected Resource<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">login-config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">auth-method</span>&gt;</span>BASIC<span class="tag">&lt;/<span class="name">auth-method</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">realm-name</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">realm-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">login-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就简单实现war项目新增Basic认证了</p>
<h4 id="拦截器模式"><a href="#拦截器模式" class="headerlink" title="拦截器模式"></a>拦截器模式</h4><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">report</span><br><span class="line"><span class="params">|- out												# tomcat编译运行目录</span></span><br><span class="line"><span class="params">|</span>   <span class="params">|- artifacts</span></span><br><span class="line"><span class="params">|</span>          <span class="params">|- xx</span></span><br><span class="line"><span class="params">|</span>		   <span class="params">|- xx_war_exploded</span></span><br><span class="line"><span class="params">|</span>- src												<span class="comment"># 二次开发目录</span></span><br><span class="line"><span class="params">|   |</span>- main</span><br><span class="line"><span class="params">|   	|</span>- java</span><br><span class="line"><span class="params">|			|</span>- com.xx.xx.safe.filter</span><br><span class="line"><span class="params">|					|</span>- HttpAuthBasicFilter.java</span><br><span class="line"><span class="params">|		|</span>- resources</span><br><span class="line"><span class="params">|			|</span>- http-auth-basic.properties</span><br><span class="line"><span class="params">|- target											# 二次开发编译目录</span></span><br><span class="line"><span class="params">|</span>- tomcat</span><br><span class="line"><span class="params">|	|</span>- webapps										<span class="comment"># 源码目录</span></span><br><span class="line"><span class="params">|		 |</span>- WEB-INF									 </span><br><span class="line"><span class="params">|				|</span>- web.xml							<span class="comment"># 启动配置</span></span><br><span class="line"><span class="params">|- pom.xml											# 二次开发pom</span></span><br></pre></td></tr></table></figure>



<h5 id="代码调整"><a href="#代码调整" class="headerlink" title="代码调整"></a>代码调整</h5><p>HttpAuthBasicFilter.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAuthBasicFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECURITY_BASIC = <span class="string">&quot;BASIC&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		InputStream in = HttpAuthBasicFilter.class.getClassLoader().getResourceAsStream(<span class="string">&quot;http-auth-basic.properties&quot;</span>);</span><br><span class="line">		properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			properties.load(in);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">		HttpServletResponse resp = (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">		String sessionAuth = (String) req.getSession().getAttribute(<span class="string">&quot;auth&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!Strings.isNullOrEmpty(sessionAuth)) &#123;</span><br><span class="line">			filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!checkHeaderAuth(req)) &#123;</span><br><span class="line">			resp.setStatus(<span class="number">401</span>);</span><br><span class="line">			resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">			resp.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">			resp.setHeader(<span class="string">&quot;WWW-authenticate&quot;</span>, <span class="string">&quot;Basic Realm=\&quot;test\&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		req.getSession().setAttribute(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">		filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 验证Http Header 中的Authorization是否正确</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request HttpServletRequest</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHeaderAuth</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String auth = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Strings.isNullOrEmpty(auth)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!auth.toUpperCase().startsWith(SECURITY_BASIC)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String decodeVal = getFromBASE64(auth.substring(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">		String authBasicFormat = String.format(<span class="string">&quot;%s:%s&quot;</span></span><br><span class="line">				, properties.getProperty(<span class="string">&quot;BASIC_ACCOUNT&quot;</span>)</span><br><span class="line">				, properties.getProperty(<span class="string">&quot;BASIC_PASS&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!decodeVal.startsWith(authBasicFormat)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解析Authorization中的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> s Authorization</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Decode Authorization</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getFromBASE64</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">		<span class="keyword">byte</span>[] b = decoder.decodeBuffer(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>pom.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.eclipse.jetty.orbit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;javax.servlet&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;3.0.0.v201112011016&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;27.0.1-jre&lt;/version&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">			&lt;configuration&gt;</span><br><span class="line">				&lt;outputDirectory&gt;</span><br><span class="line">					tomcat/webapps/WEB-INF/lib/</span><br><span class="line">				&lt;/outputDirectory&gt;</span><br><span class="line">			&lt;/configuration&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">		&lt;!-- 内置打包法 --&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">			&lt;executions&gt;</span><br><span class="line">				&lt;execution&gt;</span><br><span class="line">					&lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">					&lt;goals&gt;</span><br><span class="line">						&lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">					&lt;/goals&gt;</span><br><span class="line">					&lt;configuration&gt;</span><br><span class="line">					&lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;</span><br><span class="line">						&lt;transformers&gt;</span><br><span class="line">							&lt;transformer</span><br><span class="line">									implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">								&lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;</span><br><span class="line">							&lt;/transformer&gt;</span><br><span class="line">							&lt;transformer</span><br><span class="line">									implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">								&lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;</span><br><span class="line">							&lt;/transformer&gt;</span><br><span class="line">						&lt;/transformers&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/execution&gt;</span><br><span class="line">			&lt;/executions&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">	&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>



<p>web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;HttpAuthBasicFilter&lt;/filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;com.xxx.xx.safe.filter.HttpAuthBasicFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;/filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;HttpAuthBasicFilter&lt;/filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h5 id="IDEA设置"><a href="#IDEA设置" class="headerlink" title="IDEA设置"></a>IDEA设置</h5><p>现在代码都准备差不多了，我们开始准备idea的一些配置</p>
<p>1、首先将webapps中的lib包加入到你的项目中</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/war/1.png"></p>
<p>2、配置Artifacts</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/war/2.png"></p>
<p>3、配置tomcat和deployment</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/java/war/3.png"></p>
<p>现在大功告成了，下面进行启动</p>
<ul>
<li>首先启动tomcat为调试模式，因为我们要使用热部署，都懂</li>
<li>在你的二开工程中，进行package就可以打包到tomcat中进行自动依赖了</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>war</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战（一）</title>
    <url>/2018/03/08/mq/rocketmq/1/</url>
    <content><![CDATA[<p>阿里巴巴有2大核心的分布式技术，一个是OceanBase，另一个就是RocketMQ。在实际项目中已经领教过RocketMQ的强大，本人计划写一个RocketMQ实战系列，将涵盖RocketMQ的简介，环境搭建，初步使用、API详解、架构分析、管理员集群操作等知识。</p>
<h4 id="What-is-RocketMQ"><a href="#What-is-RocketMQ" class="headerlink" title="What is RocketMQ?"></a>What is RocketMQ?</h4><p>RocketMQ作为一款分布式的消息中间件（阿里的说法是不遵循任何规范的，所以不能完全用JMS的那一套东西来看它），经历了Metaq1.x、Metaq2.x的发展和淘宝双十一的洗礼，在功能和性能上远超ActiveMQ。</p>
<ul>
<li>要知道RocketMQ原生就是支持分布式的，而ActiveMQ原生存在单点性。</li>
<li>RocketMQ可以保证严格的消息顺序，而ActiveMQ无法保证！</li>
<li>RocketMQ提供亿级消息的堆积能力，这不是重点，重点是堆积了亿级的消息后，依然保持写入低延迟！</li>
<li>丰富的消息拉取模式（Push or Pull）<br>Push好理解，比如在消费者端设置Listener回调；而Pull，控制权在于应用，即应用需要主动的调用拉消息方法从Broker获取消息，这里面存在一个消费位置记录的问题（如果不记录，会导致消息重复消费）。</li>
<li>在Metaq1.x/2.x的版本中，分布式协调采用的是Zookeeper，而RocketMQ自己实现了一个NameServer，更加轻量级，性能更好！</li>
<li>消息失败重试机制、高效的订阅者水平扩展能力、强大的API、事务机制等等（后续详细介绍）</li>
</ul>
<span id="more"></span>

<h4 id="初步理解Producer-Consumer-Group"><a href="#初步理解Producer-Consumer-Group" class="headerlink" title="初步理解Producer/Consumer Group"></a>初步理解Producer/Consumer Group</h4><p>ActiveMQ中并没有Group这个概念，而在RocketMQ中理解Group的机制很重要。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/1.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>想过没有，通过Group机制，让RocketMQ天然的支持消息负载均衡！</p>
<p>比如某个Topic有9条消息，其中一个Consumer Group有3个实例（3个进程 OR 3台机器），那么每个实例将均摊3条消息！（注意RocketMQ只有一种模式，即发布订阅模式。）</p>
<blockquote>
</blockquote>
<p>RocketMQ的Broker集群部署模式还挺多的，比如单Master模式、多Master模式、多Master多Slave模式（异步复制）、多Master多Slave模式（同步双写）等。明确个概念，RocketMQ Slave不可以写，可以读，类似于MySQL的主从机制。</p>
<ul>
<li>单Master模式：<br>无需多言，一旦单个broker重启或宕机，一切都结束了！很显然，线上不可以使用。</li>
<li>多Master模式：<br>全是Master，没有Slave。当然，一个broker宕机了，应用是无影响的，缺点在于宕机的Master上未被消费的消息在Master没有恢复之前不可以订阅。</li>
<li>多Master多Slave模式（异步复制）：<br>多对Master-Slave，高可用！采用异步复制的方式，主备之间短暂延迟，MS级别。Master宕机，消费者可以从Slave上进行消费，不受影响，但是Master的宕机，会导致丢失掉极少量的消息。</li>
<li>多Master多Slave模式（同步双写）：<br>和上面的区别点在于采用的是同步方式，也就是在Master/Slave都写成功的前提下，向应用返回成功，可见不论是数据，还是服务都没有单点，都非常可靠！缺点在于同步的性能比异步稍低。</li>
</ul>
<p>这里我将采用2个Master的方式进行搭建演示，会了双Master，其他的将很简单。（多Master在实际中也是非常常用的，如果并发非常大，考虑多Master多Slave模式）</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/2.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在192.168.99.121/122机器上各一个NameServer、Master进程。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以192.168.99.121为例：</p>
<h5 id="修改-etc-hosts文件"><a href="#修改-etc-hosts文件" class="headerlink" title="修改/etc/hosts文件"></a>修改/etc/hosts文件</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/2.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/3.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/4.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>确保相互之间可以ping通</p>
<h5 id="解压并创建存储路径"><a href="#解压并创建存储路径" class="headerlink" title="解压并创建存储路径"></a>解压并创建存储路径</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf alibaba-rocketmq-3.2.6.tar.gz</span><br><span class="line"></span><br><span class="line">mkdir -p alibaba-rocketmq/store/&#123;commitlog,consumequeue,index&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/5.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/6.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>上面已经将实际中常用的配置项给出来了！</p>
<h5 id="修改日志配置文件"><a href="#修改日志配置文件" class="headerlink" title="修改日志配置文件"></a>修改日志配置文件</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/7.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意到logback.*.xml配置文件中：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/8.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>可以使用sed进行替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s#$&#123;user.home&#125;#/software/alibaba-rocketmq#g&#x27; *.xml</span><br></pre></td></tr></table></figure>

<h5 id="修改启动脚本中的JVM参数"><a href="#修改启动脚本中的JVM参数" class="headerlink" title="修改启动脚本中的JVM参数"></a>修改启动脚本中的JVM参数</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/9.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意，在这里我将JVM的堆的初始化和最大大小统一设置为1G，并将新生代大小设置为512M。主要是考虑到我的虚拟机内存，实际上在线上是可以走默认的4G堆内存的。</p>
<h5 id="第六步，启动NameServer"><a href="#第六步，启动NameServer" class="headerlink" title="第六步，启动NameServer"></a>第六步，启动NameServer</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/10.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/11.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h5 id="启动broker-X"><a href="#启动broker-X" class="headerlink" title="启动broker-X"></a>启动broker-X</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/12.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意观察日志：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/13.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/14.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h5 id="RocketMQ-Console"><a href="#RocketMQ-Console" class="headerlink" title="RocketMQ Console"></a>RocketMQ Console</h5><p>把rocketmq-console.war部署到Tomcat下即可。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/15.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在解压WAR包后的CLASS下更改config.properties</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/16.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/17.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/18.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>这个管控台实际上还是比较简陋的，我们使用比较多的是mqadmin操作命令，后续会介绍。</p>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战（二）</title>
    <url>/2018/03/08/mq/rocketmq/2/</url>
    <content><![CDATA[<h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><p>写一个简单的生产者、消费者，带大家快速体验RocketMQ~</p>
<p>Maven配置：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/19.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>生产者：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/20.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>消费者：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/21.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<blockquote>
<p>无论生产者、消费者都必须给出GroupName，而且具有唯一性！<br>生产到哪个Topic的哪个Tag下，消费者也是从Topic的哪个Tag进行消费，可见这个Tag有点类似于JMS Selector机制，即实现消息的过滤。<br>生产者、消费者需要设置NameServer地址。<br>这里，采用的是Consumer Push的方式，即设置Listener机制回调，相当于开启了一个线程。以后为大家介绍Consumer Pull的方式。</p>
</blockquote>
<span id="more"></span>

<p>我们看一下运行结果：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/22.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>仔细看看生产者结果输出，你会发现，有的消息发往broker-a，有的在broker-b上，自动实现了消息的负载均衡！</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/23.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>这里消费消息是没有什么顺序的，以后我们在来谈消息的顺序性。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/24.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/25.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在多Master模式中，如果某个Master进程挂了，显然这台broker将不可用，上面的消息也将无法消费，要知道开源版本的RocketMQ是没有提供切换程序，来自动恢复故障的，因此在实际开发中，我们一般提供一个监听程序，用于监控Master的状态。</p>
<p>在ActiveMQ中，生产消息的时候会提供是否持久化的选择，但是对于RocketMQ而言，消息是一定会被持久化的！</p>
<blockquote>
<p>上面的消费者采用的是Push Consumer的方式，那么监听的Listener中的消息List到底是多少条呢？虽然提供了API，如consumer.setConsumeMessageBatchMaxSize(10)，实际上即使设置了批量的条数，但是注意了，是最大是10，并不意味着每次batch的都是10，只有在消息有挤压的情况下才有可能。而且Push Consumer的最佳实践方式就是一条条的消费，如果需要batch，可以使用Pull Consumer。</p>
</blockquote>
<p>务必保证先启动消费者进行Topic订阅，然后在启动生产者进行生产（否则极有可能导致消息的重复消费，重复消费，重复消费！重要的事情说三遍！关于消息的重复问题后续给大家介绍~）。而且在实际开发中，有时候不会批量的处理消息，而是原子性的，单线程的去一条一条的处理消息，这样就是实时的在处理消息。（批量的处理海量的消息，可以考虑Kafka）</p>
<h5 id="初步了解消息失败重试机制"><a href="#初步了解消息失败重试机制" class="headerlink" title="初步了解消息失败重试机制"></a>初步了解消息失败重试机制</h5><p>消息失败，无非涉及到2端：从生产者端发往MQ的失败；消费者端从MQ消费消息的失败；</p>
<p><strong>生产者端的失败重试</strong></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/26.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>生产者端的消息失败：比如网络抖动导致生产者发送消息到MQ失败。</p>
<p>上图代码示例的处理手段是：如果该条消息在1S内没有发送成功，那么重试3次。</p>
<p><strong>消费者端的失败重试</strong></p>
<blockquote>
<p>消费者端的失败，分为2种情况，一个是timeout，一个是exception<br>timeout，比如由于网络原因导致消息压根就没有从MQ到消费者上，在RocketMQ内部会不断的尝试发送这条消息，直至发送成功为止！（比如集群中一个broker失败，就尝试另一个broker）<br>exception，消息正常的到了消费者，结果消费者发生异常，处理失败了。这里涉及到一些问题，需要我们思考下，比如，消费者消费消息的状态有哪些定义？如果失败，MQ将采取什么策略进行重试？假设一次性批量PUSH了10条，其中某条数据消费异常，那么消息重试是10条呢，还是1条呢？而且在重试的过程中，需要保证不重复消费吗？</p>
</blockquote>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/27.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>消息消费的状态，有2种，一个是成功（CONSUME_SUCCESS），一个是失败&amp;稍后重试（RECONSUME_LATER）</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/28.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在启动broker的过程中，可以观察下日志，你会发现RECONSUME_LATER的策略。</p>
<p>如果消费失败，那么1S后再次消费，如果失败，那么5S后，再次消费，……直至2H后如果消费还失败，那么该条消息就会终止发送给消费者了！</p>
<p>RocketMQ为我们提供了这么多次数的失败重试，但是在实际中也许我们并不需要这么多重试，比如重试3次，还没有成功，我们希望把这条消息存储起来并采用另一种方式处理，而且希望RocketMQ不要在重试呢，因为重试解决不了问题了！这该如何做呢？</p>
<p>我们先来看一下一条消息MessageExt对象的输出：</p>
<blockquote>
<p>MessageExt [queueId=0, storeSize=137, queueOffset=0, sysFlag=0, bornTimestamp=1492213846916, bornHost=/192.168.99.219:50478, storeTimestamp=1492213846981, storeHost=/192.168.99.121:10911, msgId=C0A8637900002A9F0000000000000000, commitLogOffset=0, bodyCRC=613185359, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties={TAGS=TagA, WAIT=true, MAX_OFFSET=3, MIN_OFFSET=0}, body=16]]</p>
</blockquote>
<p>注意到reconsumeTimes属性，这个属性就代表消息重试的次数！来看一段代码：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/29.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意了，对于消费消息而言，存在2种指定的状态（成功 OR 失败重试），如果一条消息在消费端处理没有返回这2个状态，那么相当于这条消息没有达到消费者，势必会再次发送给消费者！也即是消息的处理必须有返回值，否则就进行重发。</p>
<h5 id="天然的消息负载均衡及高效的水平扩展机制"><a href="#天然的消息负载均衡及高效的水平扩展机制" class="headerlink" title="天然的消息负载均衡及高效的水平扩展机制"></a>天然的消息负载均衡及高效的水平扩展机制</h5><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/30.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>对于RocketMQ而言，通过ConsumeGroup的机制，实现了天然的消息负载均衡！通俗点来说，RocketMQ中的消息通过ConsumeGroup实现了将消息分发到C1/C2/C3/……的机制，这意味着我们将非常方便的通过加机器来实现水平扩展！</p>
<p>我们考虑一下这种情况：比如C2发生了重启，一条消息发往C3进行消费，但是这条消息的处理需要0.1S，而此时C2刚好完成重启，那么C2是否可能会收到这条消息呢？答案是肯定的，也就是consume broker的重启，或者水平扩容，或者不遵守先订阅后生产消息，都可能导致消息的重复消费！关于去重的话题会在后续中予以介绍！</p>
<p>至于消息分发到C1/C2/C3，其实也是可以设置策略的。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/31.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h5 id="集群消费-AND-广播消费"><a href="#集群消费-AND-广播消费" class="headerlink" title="集群消费 AND 广播消费"></a>集群消费 AND 广播消费</h5><blockquote>
<p>RocketMQ的消费方式有2种，在默认情况下，就是集群消费，也就是上面提及的消息的负载均衡消费。另一种消费模式，是广播消费。广播消费，类似于ActiveMQ中的发布订阅模式，消息会发给Consume Group中的每一个消费者进行消费。</p>
</blockquote>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/32.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/33.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战（三）</title>
    <url>/2018/03/08/mq/rocketmq/3/</url>
    <content><![CDATA[<p><strong>关于多Master多Slave的说明</strong></p>
<p>由于在之前的博客中已经搭建了双Master，其实多Master多Slave大同小异，因此这里并不会一步步的演示搭建多Master多Slave，而是从思路上，分析下重点应该注意的配置项。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/34.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<blockquote>
</blockquote>
<ul>
<li>这四台机器，对外是一个统一的整体，是一个rocketmq cluster，因此需要brokerClusterName保持统一</li>
<li>123机器是121的从，124机器是122的从，如何在配置中体现？ 主和从的brokerName需要保持一致，另外brokerId标示了谁是主，谁是从（brokerId=0的就是主，大于0的就是从）</li>
<li>注意namesrvAddr的地址是4台NameServer</li>
<li>配置项中brokerRole需要指明 ASYNC_MASTER（异步复制Master） or SYNC_MASTER（同步双写Master） or SLAVE（从）</li>
<li>和以前的多Master启动方式一致，先启动4台Namesrv，然后用指定配置文件的方式启动Master/Slave即可</li>
<li>多Master多Slave的好处在于，即便集群中某个broker挂了，也可以继续消费，保证了实时性的高可用，但是并不是说某个master挂了，slave就可以升级master，开源版本的rocketmq是不可以的。也就是说，在这种情况下，slave只能提供读的功能，将失去消息负载的能力。</li>
</ul>
<span id="more"></span>

<h4 id="Queue-in-Topic"><a href="#Queue-in-Topic" class="headerlink" title="Queue in Topic"></a>Queue in Topic</h4><p>对于RocketMQ而言，Topic只是一个逻辑上的概念，真正的消息存储其实是在Topic中的Queue中。想一想，为什么RocketMQ要这要设计呢？其实是为了消息的顺序消费，后文中将为大家介绍。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/35.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/36.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/37.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h4 id="初步认识RocketMQ的核心模块"><a href="#初步认识RocketMQ的核心模块" class="headerlink" title="初步认识RocketMQ的核心模块"></a>初步认识RocketMQ的核心模块</h4><p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/38.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<ul>
<li>rocketmq-broker：接受生产者发来的消息并存储（通过调用rocketmq-store），消费者从这里取得消息。</li>
<li>rocketmq-client：提供发送、接受消息的客户端API。</li>
<li>rocketmq-namesrv：NameServer，类似于Zookeeper，这里保存着消息的TopicName，队列等运行时的元信息。（有点NameNode的味道）</li>
<li>rocketmq-common：通用的一些类，方法，数据结构等</li>
<li>rocketmq-remoting：基于Netty4的client/server + fastjson序列化 + 自定义二进制协议</li>
<li>rocketmq-store：消息、索引存储等</li>
<li>rocketmq-filtersrv：消息过滤器Server，需要注意的是，要实现这种过滤，需要上传代码到MQ！【一般而言，我们利用Tag足以满足大部分的过滤需求，如果更灵活更复杂的过滤需求，可以考虑filtersrv组件】</li>
<li>rocketmq-tools：命令行工具</li>
</ul>
<h4 id="Order-Message"><a href="#Order-Message" class="headerlink" title="Order Message"></a>Order Message</h4><p>RocketMQ提供了3种模式的Producer：</p>
<ul>
<li>NormalProducer（普通）</li>
<li>OrderProducer（顺序）</li>
<li>TransactionProducer（事务）</li>
</ul>
<p>在前面的博客当中，涉及的都是NormalProducer，调用传统的send方法，消息是无序的。接下来，我们来看看顺序消费。模拟这样一个场景，如果一个用户完成一个订单需要3条消息，比如订单的创建、订单的支付、订单的发货，很显然，同一个用户的订单消息必须要顺序消费，但是不同用户之间的订单可以并行消费。</p>
<p>生产者端代码示例：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/39.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意，一个Message除了Topic/Tag外，还有Key的概念。上图的send方法不同于以往，有一个MessageQueueSelector，将用于指定特定的消息发往特定的队列当中！</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/40.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>注意，在以前普通消费消息时设置的回调是MessageListenerConcurrently，而顺序消费的回调设置是MessageListenerOrderly。</p>
<p>当我们启动2个Consumer进行消费时，可以观察到：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/41.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>可以观察得到，虽然从全局上来看，消息的消费不是有序的，但是每一个订单下的3条消息是顺序消费的！</p>
<p>其实，如果需要保证消息的顺序消费，那么很简单，首先需要做到一组需要有序消费的消息发往同一个broker的同一个队列上！其次消费者端采用有序Listener即可。</p>
<p>这里，RocketMQ底层是如何做到消息顺序消费的，看一看源码你就能大概了解到，至少来说，在多线程消费场景下，一个线程只去消费一个队列上的消息，那么自然就保证了消息消费的顺序性，同时也保证了多个线程之间的并发性。也就是说其实broker并不能完全保证消息的顺序消费，它仅仅能保证的消息的顺序发送而已！</p>
<p>关于多线程消费这块，RocketMQ早就替我们想好了，这样设置即可：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/42.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>想一想，在ActiveMQ中，我们如果想实现并发消费的话，恐怕还得搞个线程池提交任务吧，RocketMQ让我们的工作变得简单！</p>
<h4 id="Transaction-Message"><a href="#Transaction-Message" class="headerlink" title="Transaction Message"></a>Transaction Message</h4><p>在说事务消息之前，我们先来说说分布式事务的那些事！</p>
<p>什么是分布式事务，我的理解是一半事务。怎么说，比如有2个异构系统，A异构系统要做T1，B异构系统要做T2，要么都成功，要么都失败。要知道异构系统，很显然，不在一个数据库实例上，它们往往分布在不同物理节点上，本地事务已经失效。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/43.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<blockquote>
</blockquote>
<ul>
<li>2阶段提交协议，Two-Phase Commit，是处理分布式事务的一种常见手段。2PC，存在2个重要角色：事务协调器（TC），事务执行者。</li>
<li>2PC，可以看到节点之间的通信次数太多了，时间很长！时间变长了，从而导致，事务锁定的资源时间也变长了，造成资源等待时间变长！在高并发场景下，存在严重的性能问题</li>
</ul>
<p>下面，我们来看看MQ在高并发场景下，是如何解决分布式事务的。</p>
<p><strong>考虑生活中的场景：</strong></p>
<p>我们去北京庆丰包子铺吃炒肝，先去营业员那里付款（Action1），拿到小票（Ticket），然后去取餐窗口排队拿炒肝（Action2）。思考2个问题：第一，为什么不在付款的同时，给顾客炒肝？如果这样的话，会增加处理时间，使得后面的顾客等待时间变长，相当于降低了接待顾客的能力（降低了系统的QPS）。第二，付了款，拿到的是Ticket，顾客为什么会接受？从心理上说，顾客相信Ticket会兑现炒肝。事实上也是如此，就算在最后炒肝没了，或者断电断水（系统出现异常），顾客依然可以通过Ticket进行退款操作，这样都不会有什么损失！（虽然这么说，但是实际上包子铺最大化了它的利益，如果炒肝真的没了，浪费了顾客的时间，不过顾客顶多发发牢骚，最后接受）</p>
<p>生活已经告诉我们处理分布式事务，保证数据最终一致性的思路！这个Ticket（凭证）其实就是消息！</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/44.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>业务操作和消息的生成耦合在一起，保证了只要A银行的账户发生扣款，那么一定会生成一条转账消息。只要A银行系统的事务成功提交，我们可以通过实时消息服务，将转账消息通知B银行系统，如果B银行系统回复成功，那么A银行系统可以在table中设置这条转账消息的状态。</p>
<p>这样耦合的方式，从架构上来看，就有点不太优雅，而且存在一些问题。比如说，消息的存储实质上是在A银行系统中的，如果A银行系统出了问题，将导致无法转账。如果解耦，将消息独立出来呢？</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/45.jpg?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>如上图所示，消息数据独立存储，业务和消息解耦，实质上消息的发送有2次，一条是转账消息，另一条是确认消息。</p>
<p>到这里，我们先来看看基于RocketMQ的代码：</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/46.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>生产者这里用到是：TransactionMQProducer。</p>
<p>这里涉及到2个角色：本地事务执行器（代码中的TransactionExecuterImpl）、服务器回查客户端Listener（代码中的TransactionCheckListener）。</p>
<p>如果事务消息发送到MQ上后，会回调  本地事务执行器；但是此时事务消息是prepare状态，对消费者还不可见，需要  本地事务执行器  返回RMQ一个确认消息。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/47.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>事务消息是否对消费者可见，完全由事务返回给RMQ的状态码决定（状态码的本质也是一条消息）。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/48.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/mq/49.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>生产者发送了2条消息给RMQ，有一条本地事务执行成功，有一条本地事务执行失败。</p>
<p>2条业务消息 + 2条确认消息  因此是4条；</p>
<p>注意，到消费者只消费了一条数据，就是只有告诉RMQ本地事务执行成功的那条消息才会被消费！因此是1条！</p>
<p>但是，注意到本地事务执行失败的消息，RMQ并没有check listener？这是为什么呢？因为RMQ在3.0.8的时候还是支持check listener回查机制的，但是到了3.2.6的时候将事务回查机制“阉割”了！</p>
<blockquote>
<p>那么3.0.8的时候，RMQ是怎么做事务回查的呢？看一看源码，你会知道，其实事务消息开始是prepare状态，然后RMQ会将其持久化到MySQL当中，然后如果收到确认消息，就删除掉这条prepare消息，如果迟迟收不到确认消息，那么RMQ会定时的扫描prepare消息，发送给produce group进行回查确认！</p>
</blockquote>
<hr>
<p>到这里，问题来了，要知道3.2.6版本，没有回查机制了，会存在问题么？</p>
<p>当然会存在问题！假设，我们发送一条转账事务消息给RMQ，成功后回调本地事务，DB减操作成功，刚准备给RMQ一个确认消息，此时突然断电，或者网络抖动，使得这条确认消息没有发送出去。此时RMQ中的那条转账事务消息，始终处于prepare状态，消费者读取不到，但是却已经完成一方的账户资金变动！！！</p>
<p>既然，RMQ3.2.6版本不为我们进行回查，那么只能由我们自己完成了。</p>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle-&quot;WM_CONCAT&quot;: 标识符无效</title>
    <url>/2020/05/18/oracle/debug/1/</url>
    <content><![CDATA[<h3 id="“WM-CONCAT”-标识符无效"><a href="#“WM-CONCAT”-标识符无效" class="headerlink" title="“WM_CONCAT”: 标识符无效"></a>“WM_CONCAT”: 标识符无效</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>11gr2和12C上已经摒弃了wm_concat函数，当时我们很多程序员在程序中确使用了该函数，导致程序出现错误，为了减轻程序员修改程序的工作量，只有通过手工创建个wm_concat函数，来临时解决该问题，但是注意，及时创建了该函数，在使用的过程中，也需要用to_char(wm_concat())方式，才能完全替代之前的应用。</p>
<span id="more"></span>


<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol>
<li><p>解锁sys用户</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys account unlock;</span><br></pre></td></tr></table></figure></li>
<li><p>创建包，包体，函数</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE</span><br><span class="line">TYPE WM_CONCAT_IMPL <span class="keyword">AS</span> OBJECT ( CURR_STR VARCHAR2(<span class="number">32767</span>),</span><br><span class="line"><span class="keyword">STATIC</span></span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">    ODCIAGGREGATEINITIALIZE(SCTX <span class="keyword">IN</span> <span class="keyword">OUT</span> WM_CONCAT_IMPL) <span class="keyword">RETURN</span> NUMBER,</span><br><span class="line">    <span class="keyword">MEMBER</span></span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">        ODCIAGGREGATEITERATE(SELF <span class="keyword">IN</span> <span class="keyword">OUT</span> WM_CONCAT_IMPL,</span><br><span class="line">        P1 <span class="keyword">IN</span> VARCHAR2) <span class="keyword">RETURN</span> NUMBER,</span><br><span class="line">        <span class="keyword">MEMBER</span></span><br><span class="line">    <span class="keyword">FUNCTION</span></span><br><span class="line">            ODCIAGGREGATETERMINATE(SELF <span class="keyword">IN</span> WM_CONCAT_IMPL,</span><br><span class="line">            RETURNVALUE <span class="keyword">OUT</span> VARCHAR2,</span><br><span class="line">            FLAGS <span class="keyword">IN</span> NUMBER) <span class="keyword">RETURN</span> NUMBER,</span><br><span class="line">            <span class="keyword">MEMBER</span></span><br><span class="line">        <span class="keyword">FUNCTION</span></span><br><span class="line">                ODCIAGGREGATEMERGE(SELF <span class="keyword">IN</span> <span class="keyword">OUT</span> WM_CONCAT_IMPL,</span><br><span class="line">                SCTX2 <span class="keyword">IN</span> WM_CONCAT_IMPL) <span class="keyword">RETURN</span> NUMBER );</span><br></pre></td></tr></table></figure></li>
<li><p>定义类型body</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE</span><br><span class="line">TYPE BODY WM_CONCAT_IMPL <span class="keyword">IS</span> <span class="keyword">STATIC</span></span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">    ODCIAGGREGATEINITIALIZE(SCTX <span class="keyword">IN</span> <span class="keyword">OUT</span> WM_CONCAT_IMPL) <span class="keyword">RETURN</span> NUMBER <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">        SCTX :<span class="operator">=</span> WM_CONCAT_IMPL(<span class="keyword">NULL</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> ODCICONST.SUCCESS;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">MEMBER</span></span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">    ODCIAGGREGATEITERATE(SELF <span class="keyword">IN</span> <span class="keyword">OUT</span> WM_CONCAT_IMPL,</span><br><span class="line">    P1 <span class="keyword">IN</span> VARCHAR2) <span class="keyword">RETURN</span> NUMBER <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF</span><br><span class="line">            (CURR_STR <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>) <span class="keyword">THEN</span> CURR_STR :<span class="operator">=</span> CURR_STR <span class="operator">||</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">||</span> P1;</span><br><span class="line"><span class="keyword">ELSE</span> CURR_STR :<span class="operator">=</span> P1;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">IF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> ODCICONST.SUCCESS;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">MEMBER</span></span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">    ODCIAGGREGATETERMINATE(SELF <span class="keyword">IN</span> WM_CONCAT_IMPL,</span><br><span class="line">    RETURNVALUE <span class="keyword">OUT</span> VARCHAR2,</span><br><span class="line">    FLAGS <span class="keyword">IN</span> NUMBER) <span class="keyword">RETURN</span> NUMBER <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">        RETURNVALUE :<span class="operator">=</span> CURR_STR ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> ODCICONST.SUCCESS;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">MEMBER</span></span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">    ODCIAGGREGATEMERGE(SELF <span class="keyword">IN</span> <span class="keyword">OUT</span> WM_CONCAT_IMPL,</span><br><span class="line">    SCTX2 <span class="keyword">IN</span> WM_CONCAT_IMPL) <span class="keyword">RETURN</span> NUMBER <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF</span><br><span class="line">            (SCTX2.CURR_STR <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>) <span class="keyword">THEN</span> SELF.CURR_STR :<span class="operator">=</span> SELF.CURR_STR <span class="operator">||</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">||</span> SCTX2.CURR_STR ;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">IF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> ODCICONST.SUCCESS;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义行变列函数</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE</span><br><span class="line"><span class="keyword">FUNCTION</span></span><br><span class="line">    wm_concat(P1 VARCHAR2) <span class="keyword">RETURN</span> VARCHAR2 AGGREGATE</span><br><span class="line">        <span class="keyword">USING</span> WM_CONCAT_IMPL ;</span><br></pre></td></tr></table></figure></li>
<li><p>创建同义词并授权</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> public synonym WM_CONCAT_IMPL <span class="keyword">for</span> sys.WM_CONCAT_IMPL;</span><br><span class="line"><span class="keyword">create</span> public synonym wm_concat <span class="keyword">for</span> sys.wm_concat;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> WM_CONCAT_IMPL <span class="keyword">to</span> public;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> wm_concat <span class="keyword">to</span> public;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意</strong></p>
<p>DBeaver这种类似的数据库管理工具，无法执行上述SQL脚本，建议使用<code>PLSQL</code></p>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则</title>
    <url>/2020/09/03/design/pattern-2/</url>
    <content><![CDATA[<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>​    对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。</p>
<p><strong>解决问题：</strong></p>
<p>　　假如有A和B两个类，当A需求发生改变需要修改时，不能导致B类出问题。</p>
<p><strong>现状：</strong></p>
<p>　　在实际情况很难去做到单一职责原则，因为随着业务的不断变更，类的职责也在发生着变化，即职责扩散。如类A完成职责P的功能，但是随着后期业务细化，职责P分解成更小粒度的P1与P2，这时根据单一职责原则则需要拆分类A以分别满足细分后的职责P1和P2。但是实际开发环节，若类的逻辑足够简单，可以在代码上级别上违背单一职责原则；若类的方法足够少，可以在方法级别上违背单一职责原则。</p>
<span id="more"></span>

<p><strong>经典案例：</strong></p>
<p>用一个类描述动物呼吸的场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">(String animal)</span> </span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breath(<span class="string">&quot;🐂&quot;</span>);</span><br><span class="line">        animal.breath(<span class="string">&quot;🐖&quot;</span>);</span><br><span class="line">        animal.breath(<span class="string">&quot;🐎&quot;</span>);</span><br><span class="line">        animal.breath(<span class="string">&quot;🐟&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从示例可以发现，Animal类已不足以支持客户端所需职责，因为🐟吃水。若遵循单一职责原则，则需要拆分Animal类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">(String animal)</span> </span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aquatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">(String animal)</span> </span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">&quot;吃水&quot;</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breath(<span class="string">&quot;🐂&quot;</span>);</span><br><span class="line">        animal.breath(<span class="string">&quot;🐖&quot;</span>);</span><br><span class="line">        animal.breath(<span class="string">&quot;🐎&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Aquatic aquatic = <span class="keyword">new</span> Aquatic();</span><br><span class="line">        aquatic.breath(<span class="string">&quot;🐟&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时你会发现，若针对简单的业务逻辑来说，若每次细分都需要拆分的话实在是太繁琐了，而且服务端与客户端代码都需要做相应的修改。所以直接在原先类中进行修改，虽然违背了单一职责原则，但花销小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">(String animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;🐟&quot;</span>.equals(animal)) &#123;</span><br><span class="line">            System.out.println(animal + <span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(animal + <span class="string">&quot;吃水&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><p>降低类的功能复杂度</p>
</li>
<li><p>提高系统的可维护性</p>
</li>
<li><p>变更风险低</p>
</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul>
<li><p>客户端不应依赖它不需要的接口</p>
</li>
<li><p>类间的依赖关系应该建立在最小的接口上</p>
</li>
</ul>
<p>​    其实通俗来理解就是，不要在一个接口里面放很多的方法，这样会显得这个类很臃肿。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加灵活轻便。或许有的人认为接口隔离原则和单一职责原则很像，但两个原则还是存在着明显的区别。单一职责原则是在业务逻辑上的划分，注重的是职责。接口隔离原则是基于接口设计考虑。例如一个接口的职责包含10个方法，这10个方法都放在同一接口中，并且提供给多个模块调用，但不同模块需要依赖的方法是不一样的，这时模块为了实现自己的功能就不得不实现一些对其没有意义的方法，这样的设计是不符合接口隔离原则的。接口隔离原则要求”尽量使用多个专门的接口”专门提供给不同的模块。</p>
<p><strong>经典案例：</strong></p>
<p>类A通过Interface1依赖类B，1，2，3；类B通过Interface1依赖D，1，4，5。</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/design/1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        a.use1(b);</span><br><span class="line">        a.use2(b);</span><br><span class="line">        a.use3(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">interface1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation1)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation2)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation3)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation4)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation5)&#125;&quot;</span>);</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">interface1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation1)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation2)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation3)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation4)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation5)&#125;&quot;</span>);</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use1</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use3</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use1</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use3</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，上述设计不符合接口隔离原则。</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/design/2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        a.use1(b);</span><br><span class="line">        a.use2(b);</span><br><span class="line">        a.use3(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">interface1</span>,<span class="title">interface2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation1)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation2)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B-&gt;&#123;nameof(operation3)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">interface1</span>,<span class="title">interface3</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation1)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation4)&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D-&gt;&#123;nameof(operation5)&#125;&quot;</span>);</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use1</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">(interface2 interface2)</span> </span>&#123;</span><br><span class="line">        interface2.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use3</span><span class="params">(interface2 interface2)</span> </span>&#123;</span><br><span class="line">        interface2.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use1</span><span class="params">(interface1 interface1)</span> </span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use4</span><span class="params">(interface3 interface3)</span> </span>&#123;</span><br><span class="line">        interface3.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use5</span><span class="params">(interface3 interface3)</span> </span>&#123;</span><br><span class="line">        interface3.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><ul>
<li><p>高层模块不应该依赖底层模块，二者都应该依赖抽象。</p>
</li>
<li><p>抽象不应该依赖细节，细节应该依赖抽象。</p>
</li>
<li><p>依赖倒置的中心思想是面向接口编程。</p>
</li>
<li><p>依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。</p>
</li>
<li><p>使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。</p>
</li>
</ul>
<p><strong>经典案例：</strong></p>
<p>三二班有个小明，想要学习JAVA，于是买了本《深入理解JAVA》进行学习。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XiaoMing xm = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">        xm.Study(<span class="keyword">new</span> CSharp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSharp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;《深入理解JAVA》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">(CSharp cSharp)</span> </span>&#123;</span><br><span class="line">        cSharp.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了一段时间，小明觉得光学习一门太没有意思了。听说Linux比较好玩，于是买了本《鸟哥的私房菜Linux》。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XiaoMing xm = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">        xm.Study(<span class="keyword">new</span> CSharp());</span><br><span class="line">        xm.Study(<span class="keyword">new</span> Linux());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSharp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;《深入理解JAVA》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linux</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;《鸟哥的私房菜Linux》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">(CSharp cSharp)</span> </span>&#123;</span><br><span class="line">        cSharp.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">(Linux linux)</span> </span>&#123;</span><br><span class="line">        linux.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小明是一个聪明的娃，过了一段时间学得差不多了，于是又想学习《设计模式》…就这样小明在不断学习中成长，而我们的代码却越来越臃肿，变得难以维护。由于XiaoMing是一个高级模块并且是一个细节实现类，此类依赖了书籍CSharp和Linux又是一个细节依赖类，这导致XiaoMing每读一本书都需要修改代码，这与我们的依赖倒置原则是相悖的。那如何解决XiaoMing的这种问题呢？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XiaoMing xm = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">        xm.Study(<span class="keyword">new</span> CSharp());</span><br><span class="line">        xm.Study(<span class="keyword">new</span> Linux());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSharp</span> <span class="keyword">implements</span> <span class="title">IBook</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;《深入理解JAVA》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span> <span class="title">IBook</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;《鸟哥的私房菜Linux》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">(IBook book)</span> </span>&#123;</span><br><span class="line">        book.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，只要让XiaoMing依赖于抽象IBook，其他书籍依赖于该抽象，以后不管小明读什么书，哈哈都是so easy的。</p>
<p><strong>依赖关系传递的三种方式：</strong></p>
<p>1、通过接口传递(上述示例) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">(IBook book)</span> </span>&#123;</span><br><span class="line">        book.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、通过构造方法传递　　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IBook _book;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMing</span><span class="params">(IBook book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._book = book;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._book.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过Setter方法传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IBook _book;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBook</span><span class="params">(IBook book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._book = book;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._book.ShowMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖倒置原则的本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。我们在项目中使用这个原则要遵循下面的规则：</p>
<ul>
<li><p>每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备</p>
</li>
<li><p>变量的表面类型尽量是接口或者抽象类</p>
</li>
<li><p>任何类都不应该从具体类派生</p>
</li>
<li><p>尽量不要覆写基类的方法</p>
</li>
<li><p>如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响</p>
</li>
<li><p>结合里氏替换原则使用</p>
</li>
</ul>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>​    子类应当可以替换父类并出现在父类能够出现的地方。比如：公司搞年度派对，都有员工都可以抽奖，那么不管是新员工还是老员工，也不管是总部员工还是外派员工，都应当可以参加抽奖。</p>
<p><strong>里氏替换至少包含一下两个含义：</strong></p>
<ul>
<li><p>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</p>
</li>
<li><p>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。 </p>
</li>
</ul>
<p><strong>案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;100-50=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        </span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func2(<span class="number">100</span>, <span class="number">50</span>));        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码可以看出，若类B在继承类A时不注意，重写了父类方法func1就会导致结果与预想的不一致，改变了父类原有的功能。</p>
<p><strong>故里氏转换原则应满足以下要求：</strong></p>
<ul>
<li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</p>
</li>
<li><p>子类可以增加自己特有的方法</p>
</li>
<li><p>当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松</p>
</li>
<li><p>当子类的方法实现父类的抽象方法时，方法的返回值应比父类更严格</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<p>可以大大减少程序的bug以及增强代码的可读性</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>​    也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与”陌生人”说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<pre><code>  迪米特法则中的朋友是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li><p>降低类之间的耦合度，提高模块的相对独立性。</p>
</li>
<li><p>由于亲和度降低，从而提高了类的可复用率和系统的扩展性。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<p>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>
<p><strong>使用迪米特法则需要注意：</strong></p>
<ul>
<li><p>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</p>
</li>
<li><p>在类的结构设计上，尽量降低类成员的访问权限。</p>
</li>
<li><p>在类的设计上，优先考虑将一个类设置成不变类。</p>
</li>
<li><p>在对其他类的引用上，将引用其他对象的次数降到最低。</p>
</li>
<li><p>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</p>
</li>
<li><p>谨慎使用序列化（Serializable）功能。</p>
</li>
</ul>
<p><strong>经典案例：</strong></p>
<p>蔡徐坤与经纪人的关系实例。蔡徐坤只负责浪，经纪人负责处理日常事务，如与粉丝的见面会，与媒体公司的业务洽淡等。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Agent agent = <span class="keyword">new</span> Agent();</span><br><span class="line">        agent.setStar(<span class="keyword">new</span> Star(<span class="string">&quot;蔡徐坤&quot;</span>));</span><br><span class="line">        agent.setFans(<span class="keyword">new</span> Fans(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        agent.setCompany(<span class="keyword">new</span> Company(<span class="string">&quot;**公司&quot;</span>));</span><br><span class="line">        agent.meeting();</span><br><span class="line">        agent.business();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Star myStar;</span><br><span class="line">    <span class="keyword">private</span> Fans myFans;</span><br><span class="line">    <span class="keyword">private</span> Company myCompany;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStar</span><span class="params">(Star myStar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStar = myStar;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFans</span><span class="params">(Fans myFans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myFans = myFans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompany</span><span class="params">(Company myCompany)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myCompany = myCompany;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(myFans.getName()+<span class="string">&quot;与明星&quot;</span>+myStar.getName()+<span class="string">&quot;见面了。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(myCompany.getName()+<span class="string">&quot;与明星&quot;</span>+myStar.getName()+<span class="string">&quot;洽谈业务。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Star</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fans</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fans</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>​    软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将客户端和服务端分开。公共部分抽象出来。</p>
<p><strong>问题由来：</strong></p>
<p>​    在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p><strong>解决办法：</strong></p>
<p>​    当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>​    开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我”你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p>
<p>​    在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的”平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p>
<p>​    其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<p>​    说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 </p>
<p><strong>为什么使用开闭原则？</strong></p>
<ul>
<li><p>只要是面向对象的编程，在开发过程中都会强调开闭原则</p>
</li>
<li><p>是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态</p>
</li>
<li><p>可以提高代码的复用性</p>
</li>
<li><p>可以提高代码的可维护性</p>
</li>
</ul>
<p><strong>如何使用开闭原则？</strong></p>
<ul>
<li><p>抽象约束</p>
<blockquote>
<p>抽象对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放。 </p>
</blockquote>
</li>
<li><p>元数据控件模块行为　　　　</p>
</li>
<li><p>制定项目章程</p>
</li>
<li><p>封装变化</p>
<blockquote>
<p>将相同的变化封装到一个接口或抽象类中，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同变化出现在同一个接口或抽象类中。</p>
</blockquote>
</li>
</ul>
<p><strong>案例：</strong></p>
<p>一个工厂生产宝马和奥迪两种品牌的车 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        AutomobileFactory carf = <span class="keyword">new</span> AutomobileFactory();</span><br><span class="line">        carf.createAuto(AutomobileFactory.AutoType.BMW);</span><br><span class="line">        carf.createAuto(AutomobileFactory.AutoType.AUDI);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAutomobile</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">IAutomobile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi 我是奥迪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">IAutomobile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello 我是宝马&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomobileFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AutoType</span> </span>&#123;</span><br><span class="line">        AUDI, BMW</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAutomobile <span class="title">createAuto</span><span class="params">(AutoType carType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (carType) &#123;</span><br><span class="line">			<span class="keyword">case</span> AutoType.AUDI:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">			<span class="keyword">case</span> AutoType.BMW:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着业务不断扩展，需要生产宾利，怎么办？对原有工厂进行改造使其满足生产宾利的条件？对开闭原则来说，这显然不合适。于是。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        IAutomobileFactory audi = <span class="keyword">new</span> AudiFactory();</span><br><span class="line">        audi.createAuto();</span><br><span class="line">        IAutomobileFactory bmw = <span class="keyword">new</span> BMWFactory();</span><br><span class="line">        bmw.createAuto();</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAutomobile</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">IAutomobile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi 我是奥迪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">IAutomobile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello 我是宝马&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAutomobileFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IAutomobile <span class="title">createAuto</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">IAutomobileFactory</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAutomobile <span class="title">createAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">IAutomobileFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAutomobile <span class="title">createAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security + OAuth2（一）</title>
    <url>/2019/05/04/spring/spring-security-oauth2-1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经过前段时间对SSO单点登录的研究发现，有以下几类方案可以实现</p>
<ol>
<li>Spring Session + Redis</li>
<li>Spring Security + JWT</li>
<li>Spring Security + OAuth2 + Redis</li>
</ol>
<p>本文章将讲述<code>Spring Security + OAuth2 + Redis</code>，其他方式不做更多说明，直接上干货，下面是大概的流程。</p>
<p><img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/security%2Boauth2/Spring%20Security%20%2B%20OAuth2.png"></p>
<span id="more"></span>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">neusoft-sso-login 授权服务</span><br><span class="line">├── AuthApplication</span><br><span class="line">└── security</span><br><span class="line">      ├── WebSecurityConfigurer</span><br><span class="line">      ├── WebResponseException</span><br><span class="line">      └── auth</span><br><span class="line">            ├── AuthFailHandler</span><br><span class="line">            ├── AuthRequestFilter </span><br><span class="line">            ├── AuthServerConfigurerAdapter</span><br><span class="line">            └── AuthSuccessHandler</span><br><span class="line">      └── service</span><br><span class="line">            ├── ClientDetailsServiceImpl</span><br><span class="line">            └── UserDetailsServiceImpl</span><br></pre></td></tr></table></figure>

<h3 id="SQL脚本"><a href="#SQL脚本" class="headerlink" title="SQL脚本"></a>SQL脚本</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `neusoft_sr_oper` (</span><br><span class="line">  `OPER_ID` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `OPER_ACCOUNT` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `OPER_PWD` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `OPER_NAME` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号名称&#x27;</span>,</span><br><span class="line">  `CREATOR_ID` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;创建者ID（0-注册用户，super-超级管理员，其他-子用户）&#x27;</span>,</span><br><span class="line">  `LAST_LOGIN_IP` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后登录IP&#x27;</span>,</span><br><span class="line">  `LAST_LOGIN_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后登录时间&#x27;</span>,</span><br><span class="line">  `LOGIN_COUNT` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;登录次数&#x27;</span>,</span><br><span class="line">  `STATUS` <span class="type">varchar</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0-正常，1-停用，2-锁定，99-注销（删除）&#x27;</span>,</span><br><span class="line">  `PWD_MODIFY_DATE` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码更新时间&#x27;</span>,</span><br><span class="line">  `STATUS_MODIFY_DATE` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;状态更新时间&#x27;</span>,</span><br><span class="line">  `CREATE_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `UPDATE_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`OPER_ID`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `OPER_ACCOUNT` (`OPER_ACCOUNT`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户基础信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `neusoft_sys_oauth_client` (</span><br><span class="line">  `CLIENT_ID` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户端ID&#x27;</span>,</span><br><span class="line">  `CLIENT_NAME` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户端名称&#x27;</span>,</span><br><span class="line">  `CLIENT_SECRET` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户端密匙&#x27;</span>,</span><br><span class="line">  `CLIENT_SECRET_PLAIN` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户端密匙明码&#x27;</span>,</span><br><span class="line">  `<span class="keyword">SCOPE</span>` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;限定范围（read，write）&#x27;</span>,</span><br><span class="line">  `AUTHORIZED_GRANT_TYPES` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;授权类型（client_credentials,password,refresh_token）&#x27;</span>,</span><br><span class="line">  `CREATE_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `UPDATE_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`CLIENT_ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;OAuth客户端&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="自定义和服务实现"><a href="#自定义和服务实现" class="headerlink" title="自定义和服务实现"></a>自定义和服务实现</h3><p>对Spring Security + OAuth2，自定义和服务实现主要是以下几个类</p>
<ul>
<li>WebSecurityConfigurerAdapter，授权拦截器配置</li>
<li>WebResponseExceptionTranslator，异常捕获处理</li>
<li>UsernamePasswordAuthenticationFilter，请求拦截器</li>
<li>UserDetailsService，获取用户信息</li>
<li>ClientDetailsService，获取客户端信息</li>
<li>AuthenticationSuccessHandler，认证成功处理</li>
<li>AuthenticationFailureHandler，认证失败处理</li>
<li>AuthorizationServerConfigurerAdapter 认证服务配置</li>
</ul>
<h3 id="CODING"><a href="#CODING" class="headerlink" title="CODING"></a>CODING</h3><h4 id="AuthApplication-java"><a href="#AuthApplication-java" class="headerlink" title="AuthApplication.java"></a>AuthApplication.java</h4><p>启动文件，因我使用的是Redis Cluster集群模式，所以要把自带的Redis加载去掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;RedisAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(AuthApplication.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--旧版本 redis操作有问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="WebSecurityConfigurer-java"><a href="#WebSecurityConfigurer-java" class="headerlink" title="WebSecurityConfigurer.java"></a>WebSecurityConfigurer.java</h4><p>自定义<code>WebSecurityConfigurerAdapter</code>，过滤<code>MATCHER_URL</code>路径为不用鉴权，登录地址设置为<code>LOGIN_URL</code>，在<code>UsernamePasswordAuthenticationFilter</code>拦截器前面新增<code>AuthRequestFilter</code>，设定认证密码模式为<code>BCryptPasswordEncoder</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurer</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AuthFailHandler authFailHandler;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AuthSuccessHandler authSuccessHandler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOGIN_URL = <span class="string">&quot;/sso/login&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String[] MATCHER_URL = &#123;<span class="string">&quot;/info&quot;</span>, <span class="string">&quot;/sso/*&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		http</span><br><span class="line">				.authorizeRequests()</span><br><span class="line">				.antMatchers(MATCHER_URL).permitAll()</span><br><span class="line">				.anyRequest().authenticated()</span><br><span class="line">				.and().csrf().disable();</span><br><span class="line"></span><br><span class="line">		http.addFilterAt(authRequestFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AuthRequestFilter <span class="title">authRequestFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		AuthRequestFilter authRequestFilter = <span class="keyword">new</span> AuthRequestFilter();</span><br><span class="line">		authRequestFilter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">		authRequestFilter.setRequiresAuthenticationRequestMatcher(<span class="keyword">new</span> AntPathRequestMatcher(LOGIN_URL, HttpMethod.POST.toString()));</span><br><span class="line">		authRequestFilter.setAuthenticationFailureHandler(authFailHandler);</span><br><span class="line">		authRequestFilter.setAuthenticationSuccessHandler(authSuccessHandler);</span><br><span class="line">		<span class="keyword">return</span> authRequestFilter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthRequestFilter-java"><a href="#AuthRequestFilter-java" class="headerlink" title="AuthRequestFilter.java"></a>AuthRequestFilter.java</h4><p>自定义<code>UsernamePasswordAuthenticationFilter</code>，将默认的Form模式变更为JSON模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthRequestFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AuthRequestFilter.class);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACCOUNT_STR = <span class="string">&quot;account&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PASSWORD_STR = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">				&amp;&amp; !request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">		UsernamePasswordAuthenticationToken authRequest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> (InputStream is = request.getInputStream()) &#123;</span><br><span class="line">			Map authenticationBean = mapper.readValue(is, Map.class);</span><br><span class="line">			authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(authenticationBean.get(ACCOUNT_STR), authenticationBean.get(PASSWORD_STR));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">&quot;JsonAuthenticationFilter form to json error!&quot;</span>);</span><br><span class="line">			authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		setDetails(request, authRequest);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthFailHandler-java"><a href="#AuthFailHandler-java" class="headerlink" title="AuthFailHandler.java"></a>AuthFailHandler.java</h4><p>自定义<code>AuthenticationFailureHandler</code>,根据不同的异常信息进行返回处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFailHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">		String code = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 锁</span></span><br><span class="line">		<span class="keyword">if</span> (e <span class="keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">			code = ERROR_AUTH_SSO_LOGIN_LOCK;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 停用</span></span><br><span class="line">		<span class="keyword">if</span> (e <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">			code = ERROR_AUTH_SSO_LOGIN_EXPIRED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 账号密码错误</span></span><br><span class="line">		<span class="keyword">if</span> (e <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">			code = ERROR_AUTH_SSO_LOGIN;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">		httpServletResponse.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">		httpServletResponse.getWriter().write(objectMapper.writeValueAsString(ResponseUtil.fail(code)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthSuccessHandler-java"><a href="#AuthSuccessHandler-java" class="headerlink" title="AuthSuccessHandler.java"></a>AuthSuccessHandler.java</h4><p>自定义<code>AuthenticationSuccessHandler</code>，读取header中的AUTHORIZATION，校验客户端secret，校验客户端scope，生成Token并自动存储到Redis中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AuthorizationServerTokenServices defaultAuthorizationServerTokenServices;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AuthSuccessHandler.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASIC_ = <span class="string">&quot;Basic &quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		String header = httpServletRequest.getHeader(HttpHeaders.AUTHORIZATION);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (header == <span class="keyword">null</span> || !header.startsWith(BASIC_)) &#123;</span><br><span class="line">			HttpUtil.writeJson(httpServletResponse, ResponseUtil.fail(ERROR_AUTH_BASIC_CLIENT), objectMapper);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String[] tokens;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			tokens = extractAndDecodeHeader(header);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			HttpUtil.writeJson(httpServletResponse, ResponseUtil.fail(ERROR_AUTH_BASIC_CLIENT), objectMapper);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span> tokens.length == <span class="number">2</span>;</span><br><span class="line">		String clientId = tokens[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//校验secret</span></span><br><span class="line">		<span class="keyword">if</span> (!passwordEncoder.matches(tokens[<span class="number">1</span>], clientDetails.getClientSecret())) &#123;</span><br><span class="line">			HttpUtil.writeJson(httpServletResponse, ResponseUtil.fail(ERROR_AUTH_CLIENT), objectMapper);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TokenRequest tokenRequest = <span class="keyword">new</span> TokenRequest(Maps.newConcurrentMap(), clientId, clientDetails.getScope(), <span class="string">&quot;all&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//校验scope</span></span><br><span class="line">		<span class="keyword">new</span> DefaultOAuth2RequestValidator().validateScope(tokenRequest, clientDetails);</span><br><span class="line">		OAuth2Request oAuth2Request = tokenRequest.createOAuth2Request(clientDetails);</span><br><span class="line">		OAuth2Authentication oAuth2Authentication = <span class="keyword">new</span> OAuth2Authentication(oAuth2Request, authentication);</span><br><span class="line">		OAuth2AccessToken oAuth2AccessToken = defaultAuthorizationServerTokenServices.createAccessToken(oAuth2Authentication);</span><br><span class="line"></span><br><span class="line">		LOGGER.info(<span class="string">&quot;token builder [&#123;&#125;]&quot;</span>, oAuth2AccessToken.getValue());</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; result = Maps.newConcurrentMap();</span><br><span class="line">		result.put(HttpHeaders.ACCESS_TOKEN, oAuth2AccessToken.getValue());</span><br><span class="line">		HttpUtil.writeJson(httpServletResponse, ResponseUtil.success(result), objectMapper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SneakyThrows</span></span><br><span class="line">	<span class="keyword">private</span> String[] extractAndDecodeHeader(String header) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">byte</span>[] base64Token = header.substring(<span class="number">6</span>).getBytes(UTF_8);</span><br><span class="line">		<span class="keyword">byte</span>[] decoded;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			decoded = Base64.getDecoder().decode(base64Token);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">					<span class="string">&quot;Failed to decode basic authentication token&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String token = <span class="keyword">new</span> String(decoded, UTF_8);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> delim = token.indexOf(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (delim == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Invalid basic authentication token&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;token.substring(<span class="number">0</span>, delim), token.substring(delim + <span class="number">1</span>)&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClientDetailsServiceImpl-java"><a href="#ClientDetailsServiceImpl-java" class="headerlink" title="ClientDetailsServiceImpl.java"></a>ClientDetailsServiceImpl.java</h4><p>接口<code>ClientDetailsService</code>实现类，获取客户端信息，并生成<code>ClientDetails</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">ClientDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> OAuthClientService clientService;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SCOPE_LIMIT = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClientDetails <span class="title">loadClientByClientId</span><span class="params">(String s)</span> <span class="keyword">throws</span> ClientRegistrationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		OAuthClient client = clientService.clientByName(s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == client) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BaseClientDetails();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BaseClientDetails clientDetails = <span class="keyword">new</span> BaseClientDetails();</span><br><span class="line">		clientDetails.setClientId(client.getClientName());</span><br><span class="line">		clientDetails.setClientSecret(client.getSecret());</span><br><span class="line">		clientDetails.setScope(Arrays.asList(client.getScope().split(SCOPE_LIMIT)));</span><br><span class="line">		clientDetails.setAuthorizedGrantTypes(Arrays.asList(client.getAuthorizedGrantTypes().split(SCOPE_LIMIT)));</span><br><span class="line">		<span class="keyword">return</span> clientDetails;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UserDetailsServiceImpl-java"><a href="#UserDetailsServiceImpl-java" class="headerlink" title="UserDetailsServiceImpl.java"></a>UserDetailsServiceImpl.java</h4><p>接口<code>UserDetailsService</code>实现类，获取用户信息，并生成<code>UserDetails</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String account)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (Strings.isNullOrEmpty(account)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(ResponseCodeSso.ERROR_AUTH_SSO_LOGIN_ACCOUNT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!authService.accountExtis(account)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(ResponseCodeSso.ERROR_AUTH_SSO_LOGIN_ACCOUNT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getUserDetails(account);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> UserDetails <span class="title">getUserDetails</span><span class="params">(String account)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Oper oper = authService.infoByWhere(account);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == oper) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(ResponseCodeSso.ERROR_AUTH_SSO_LOGIN_ACCOUNT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取角色，未进行处理</span></span><br><span class="line">		Collection&lt;? extends GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_USER&quot;</span>);</span><br><span class="line"></span><br><span class="line">		User user = <span class="keyword">new</span> User(</span><br><span class="line">				oper.getOperAccont(),</span><br><span class="line">				oper.getOperPwd(),</span><br><span class="line">				oper.getStatus().startsWith(<span class="string">&quot;0&quot;</span>),     <span class="comment">// 是否正常</span></span><br><span class="line">				!oper.getStatus().startsWith(<span class="string">&quot;1&quot;</span>),    <span class="comment">// 是否停用</span></span><br><span class="line">				<span class="keyword">true</span>,</span><br><span class="line">				!oper.getStatus().startsWith(<span class="string">&quot;2&quot;</span>),    <span class="comment">// 是否锁定</span></span><br><span class="line">				authorities</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthServerConfigurerAdapter-java"><a href="#AuthServerConfigurerAdapter-java" class="headerlink" title="AuthServerConfigurerAdapter.java"></a>AuthServerConfigurerAdapter.java</h4><p>Token存储模式设置为Redis Cluster存储，将<code>Lettuce</code>替代<code>Jedis</code>，重定义<code>/oauth/check_token</code>路径为<code>/sso/check</code>，嵌入自定义授权异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisCacheConfig redisCacheConfig;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> CacheConfig cacheConfig;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LettuceConnectionFactory <span class="title">lettuceConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RedisClusterConfig clusterConfig = <span class="keyword">new</span> RedisClusterConfig(redisCacheConfig);</span><br><span class="line">		RedisClusterConfiguration clusterConfiguration = <span class="keyword">new</span> RedisClusterConfiguration(clusterConfig.getClusterNodes());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(clusterConfiguration);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisCacheTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RedisTemplate&lt;String, Serializable&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">		template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">		template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">		template.setConnectionFactory(lettuceConnectionFactory());</span><br><span class="line">		<span class="keyword">return</span> template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RedisTokenStore tokenStore = <span class="keyword">new</span> RedisTokenStore(redisCacheTemplate().getConnectionFactory());</span><br><span class="line">		tokenStore.setPrefix(cacheConfig.getRoot() + <span class="string">&quot;:Token:&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> tokenStore;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TokenEnhancer <span class="title">tokenEnhancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (accessToken, authentication) -&gt; &#123;</span><br><span class="line">			<span class="keyword">final</span> Map&lt;String, Object&gt; additionalInfo = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">			additionalInfo.put(<span class="string">&quot;license&quot;</span>, <span class="string">&quot;web&quot;</span>);</span><br><span class="line">			((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);</span><br><span class="line">			<span class="keyword">return</span> accessToken;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@EnableAuthorizationServer</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> ClientDetailsServiceImpl clientDetailsService;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> TokenEnhancer tokenEnhancer;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> WebResponseExceptionTranslator webResponseException;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			clients.withClientDetails(clientDetailsService);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer oauthServer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			oauthServer</span><br><span class="line">					.allowFormAuthenticationForClients()</span><br><span class="line">					.checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			endpoints</span><br><span class="line">					.allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST)</span><br><span class="line">					.pathMapping(<span class="string">&quot;/oauth/check_token&quot;</span>, <span class="string">&quot;/sso/check&quot;</span>)</span><br><span class="line">					.tokenStore(tokenStore)</span><br><span class="line">					.tokenEnhancer(tokenEnhancer)</span><br><span class="line">					.userDetailsService(userDetailsService)</span><br><span class="line">					.authenticationManager(authenticationManager)</span><br><span class="line">					.reuseRefreshTokens(<span class="keyword">false</span>)</span><br><span class="line">					.exceptionTranslator(webResponseException);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>oauth2</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>Ambari 2.7.3 离线安装手册</title>
    <url>/2021/07/06/bigdata/Ambari-2-7-3-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="Ambari-2-7-3-离线安装手册"><a href="#Ambari-2-7-3-离线安装手册" class="headerlink" title="Ambari 2.7.3 离线安装手册"></a>Ambari 2.7.3 离线安装手册</h2><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><p>Ambari 2.7.3仅支持HDP-3.1.0，HDP-3.0.1，HDP-3.0.0使用以下URL确定对每个产品版本的支持<a href="https://supportmatrix.hortonworks.com/%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E8%BD%BD%E6%8A%A5%E5%91%8A">https://supportmatrix.hortonworks.com/，以及下载报告</a></p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/1.png" style="zoom: 67%;" />

<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/2.png" style="zoom: 67%;" />

<span id="more"></span>

<h3 id="工具包下载"><a href="#工具包下载" class="headerlink" title="工具包下载"></a>工具包下载</h3><p>Ambari-2.7.3.0：</p>
<p><a href="http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0/ambari-2.7.3.0-centos7.tar.gz">http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0/ambari-2.7.3.0-centos7.tar.gz</a></p>
<p>HDP-3.1.0：</p>
<p><a href="http://public-repo-1.hortonworks.com/HDP/centos7/3.x/updates/3.1.0.0/HDP-3.1.0.0-centos7-rpm.tar.gz">http://public-repo-1.hortonworks.com/HDP/centos7/3.x/updates/3.1.0.0/HDP-3.1.0.0-centos7-rpm.tar.gz</a></p>
<p>HDP-UTILS-1.1.0.22：</p>
<p><a href="http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7/HDP-UTILS-1.1.0.22-centos7.tar.gz">http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7/HDP-UTILS-1.1.0.22-centos7.tar.gz</a></p>
<p>JDK：1.8版本：</p>
<p>操作系统:centos7任意版本，系统为英文，64位，内存最好每台都10G以上。</p>
<p>mysql-connector-java-5.1.47.jar</p>
<p><a href="https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar">https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar</a></p>
<p>Mysql5.7版本：</p>
<p><a href="https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz">https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz</a></p>
<p>Linux ZIP:</p>
<p><a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/zip-3.0-11.el7.x86_64.rpm">http://mirror.centos.org/centos/7/os/x86_64/Packages/zip-3.0-11.el7.x86_64.rpm</a></p>
<p>Linux Unzip:</p>
<p> <a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/unzip-6.0-21.el7.x86_64.rpm">http://mirror.centos.org/centos/7/os/x86_64/Packages/unzip-6.0-21.el7.x86_64.rpm</a></p>
<p>Libtirpc-devel：</p>
<p><a href="https://buildlogs.centos.org/c7.1810.00.x86_64/libtirpc/20181031001901/0.2.4-0.15.el7.x86_64/libtirpc-0.2.4-0.15.el7.x86_64.rpm">https://buildlogs.centos.org/c7.1810.00.x86_64/libtirpc/20181031001901/0.2.4-0.15.el7.x86_64/libtirpc-0.2.4-0.15.el7.x86_64.rpm</a></p>
<p>Percona-XtraDB-Cluster-Shared：</p>
<p><a href="http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm">http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</a></p>
<h2 id="Linux系统软件安装配置"><a href="#Linux系统软件安装配置" class="headerlink" title="Linux系统软件安装配置"></a>Linux系统软件安装配置</h2><h3 id="服务器规划"><a href="#服务器规划" class="headerlink" title="服务器规划"></a>服务器规划</h3><table>
<thead>
<tr>
<th>IP</th>
<th>操作系统</th>
<th>节点角色</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.1.121</td>
<td>CentOS 7.6.1810</td>
<td>master</td>
</tr>
<tr>
<td>192.168.1.122</td>
<td>CentOS 7.6.1810</td>
<td>work</td>
</tr>
<tr>
<td>192.168.1.123</td>
<td>CentOS 7.6.1810</td>
<td>work</td>
</tr>
</tbody></table>
<h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><h4 id="服务器防火墙关闭"><a href="#服务器防火墙关闭" class="headerlink" title="服务器防火墙关闭"></a>服务器防火墙关闭</h4><p>关闭掉linux防火墙（所有机器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# systemctl stop firewalld.service</span><br><span class="line">[root@localhost ~]# systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>


<p>安装完成后，可以重新启动iptables。如果您环境中的安全协议阻止禁用iptables，则可以启用iptables，如果所有必需端口都已打开且可用，Ambari会在Ambari Server安装过程中检查iptables是否正在运行。如果iptables正在运行，则会显示警告，提醒检查所需端口是否已打开且可用。群集安装向导中的“主机确认”步骤还会为运行iptables的每个主机发出警告。</p>
<h4 id="修改主机名及机器隐射"><a href="#修改主机名及机器隐射" class="headerlink" title="修改主机名及机器隐射"></a>修改主机名及机器隐射</h4><p><strong>修改主机名</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1)192.168.1.121</span><br><span class="line">[root@localhost ~]# hostnamectl set-hostname master</span><br><span class="line"></span><br><span class="line">2)192.168.1.122</span><br><span class="line">[root@localhost ~]# hostnamectl set-hostname slave1</span><br><span class="line"></span><br><span class="line">3)192.168.1.123</span><br><span class="line">[root@localhost ~]# hostnamectl set-hostname slave2</span><br></pre></td></tr></table></figure>

<p><strong>修改/etc/hosts文件（所有机器）</strong></p>
<p>这里主要是为了可以实现通过名称来查找相应的服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat &lt;&lt; EOF &gt; /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.1.121 master</span><br><span class="line">192.168.1.122 slave1</span><br><span class="line">192.168.1.123 slave2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>修改主机为英文</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat &lt;&lt; EOF &gt; /etc/locale.conf</span><br><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>重启电脑</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# reboot</span><br></pre></td></tr></table></figure>

<h4 id="服务器文件句柄设置"><a href="#服务器文件句柄设置" class="headerlink" title="服务器文件句柄设置"></a>服务器文件句柄设置</h4><p><strong>永久设置（所有机器）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# vi /etc/security/limits.conf </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> End of file</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure>

<p><strong>关闭当前的shell窗口，重新打开ulimit -a查看是否设置成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 31116</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65536</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 131072</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<h4 id="禁用SELinux和PackageKit将检查umask值"><a href="#禁用SELinux和PackageKit将检查umask值" class="headerlink" title="禁用SELinux和PackageKit将检查umask值"></a>禁用SELinux和PackageKit将检查umask值</h4><p><strong>禁用selinux（所有机器）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# vi /etc/selinux/config </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUXTYPE= can take one of three values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure>

<p>主要是把SELINUX改为disabled</p>
<p><strong>umask值（所有机器）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# echo umask 0022 &gt;&gt; /etc/profile</span><br><span class="line">[root@master ~]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h4 id="服务器免登录"><a href="#服务器免登录" class="headerlink" title="服务器免登录"></a>服务器免登录</h4><p><strong>配置<code>所有节点</code>无密码登录到其他节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ssh-keygen -t rsa		## 一路回车</span><br><span class="line">[root@master ~]# chmod 700 ~/.ssh</span><br><span class="line">[root@master ~]# ssh-copy-id slave1</span><br><span class="line">[root@master ~]# ssh-copy-id slave2</span><br><span class="line">[root@master ~]# ssh-copy-id master</span><br></pre></td></tr></table></figure>

<p><strong>测试所有机器是否SSH免登录互通</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ssh slave1 date; ssh slave2 date; ssh master date;</span><br><span class="line">Wed Jun 30 02:56:40 CST 2021</span><br><span class="line">Wed Jun 30 02:56:40 CST 2021</span><br><span class="line">Wed Jun 30 02:56:40 CST 2021</span><br></pre></td></tr></table></figure>

<p><strong>将创建的密钥拷贝出来</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# mkdir /home/tools				## 所有节点</span><br><span class="line">[root@master ~]# cp /root/.ssh/id_rsa /home/tools/</span><br><span class="line">[root@master ~]# ls /home/tools/</span><br><span class="line">id_rsa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：后面ambari安装的时候需要上传这个密钥，所以需要先拷贝出来。</p>
</blockquote>
<h4 id="挂载本地Yum源配置"><a href="#挂载本地Yum源配置" class="headerlink" title="挂载本地Yum源配置"></a>挂载本地Yum源配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1）将CentOS7的ISO文件挂载到本地（所有机器）</span><br><span class="line">[root@localhost ~]# mkdir /mnt/cdrom</span><br><span class="line">[root@localhost ~]# mount /dev/cdrom /mnt/cdrom </span><br><span class="line"></span><br><span class="line">2）创建yum本地源，并将系统自带的迁移到tmp目录中（所有机器）</span><br><span class="line">[root@localhost ~]# mv /etc/yum.repos.d/* /tmp/</span><br><span class="line">[root@localhost ~]# touch /etc/yum.repos.d/local.repo</span><br><span class="line">[root@localhost ~]# cat &lt;&lt; EOF &gt; /etc/yum.repos.d/local.repo</span><br><span class="line"></span><br><span class="line">[LocalRepo]</span><br><span class="line">name=LocalRepository</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line">enable=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">3）重置yum源</span><br><span class="line">[root@localhost ~]# yum clean all</span><br><span class="line">[root@localhost ~]# yum makecache</span><br><span class="line">[root@localhost ~]# yum repolist</span><br></pre></td></tr></table></figure>

<h3 id="系统安装软件"><a href="#系统安装软件" class="headerlink" title="系统安装软件"></a>系统安装软件</h3><h4 id="服务器时间同步"><a href="#服务器时间同步" class="headerlink" title="服务器时间同步"></a>服务器时间同步</h4><p><strong>安装ntp服务（所有机器）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master cdrom]# yum -y install ntp</span><br></pre></td></tr></table></figure>

<p><strong>设置master为主服务器，开启nptd服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# vi /etc/ntp.conf </span><br></pre></td></tr></table></figure>

<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/3.png" style="zoom: 67%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 红色框内是需要修改的部分：</span></span><br><span class="line">restrict 192.168.0.0 mask 255.255.255.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use public servers from the pool.ntp.org project.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server 3.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新增</span></span><br><span class="line">server 127.127.1.0</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br></pre></td></tr></table></figure>

<p><strong>重启服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# systemctl restart ntpd.service</span><br></pre></td></tr></table></figure>

<p><strong>开机自启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# systemctl enable ntpd.service</span><br></pre></td></tr></table></figure>

<p><strong>子节点设置同步（子节点）</strong></p>
<p>主服务器开启ntp服务器以后，子节点就不需要开启了，因为当server与client之间的时间误差过大时（可能是1000秒），处于对修改时间可能对系统和应用带来不可预知的问题，NTP将停止时间同步！所以如果发现NTP启动之后时间并不进行同步时，应该考虑到可能是时间差过大引起的，此时需要先手动进行时间同步！所以直接使用定时手动同步的方式就可以了。</p>
<p>添加任务计划实时同步master服务器时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@slave1 ~]# crontab -e</span><br><span class="line">0-59/10 * * * * /usr/sbin/ntpdate master</span><br><span class="line">[root@slave1 ~]# crontab -l</span><br><span class="line">0-59/10 * * * * /usr/sbin/ntpdate master</span><br></pre></td></tr></table></figure>

<p><strong>设置Master时间为当前时间</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# date -s &#x27;2021-06-30 13:06&#x27;</span><br><span class="line">Wed Jun 30 13:06:00 CST 2021</span><br></pre></td></tr></table></figure>

<h4 id="删除默认JDK"><a href="#删除默认JDK" class="headerlink" title="删除默认JDK"></a>删除默认JDK</h4><p><strong>删除openJDK（所有节点）</strong></p>
<p>一些开发版的centos会自带jdk，我们一般用自己的jdk，把自带的删除。先看看有没有安装java -version</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# java -version</span><br><span class="line">openjdk version &quot;1.8.0_101&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_101-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.101-b13, mixed mode)</span><br></pre></td></tr></table></figure>

<p><strong>查找他们的安装位置（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# rpm -qa | grep java</span><br><span class="line">java-1.8.0-openjdk-headless-1.8.0.101-3.b13.el7_2.x86_64</span><br><span class="line">tzdata-java-2016f-1.el7.noarch</span><br><span class="line">java-1.8.0-openjdk-1.8.0.101-3.b13.el7_2.x86_64</span><br><span class="line">javapackages-tools-3.4.1-11.el7.noarch</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.2.el7_2.x86_64</span><br><span class="line">java-1.7.0-openjdk-1.7.0.111-2.6.7.2.el7_2.x86_64</span><br><span class="line">python-javapackages-3.4.1-11.el7.noarch</span><br></pre></td></tr></table></figure>

<p><strong>删除全部，noarch文件可以不用删除（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.101-3.b13.el7_2.x86_64</span><br><span class="line">[root@master ~]# rpm -e --nodeps java-1.8.0-openjdk-1.8.0.101-3.b13.el7_2.x86_64</span><br><span class="line">[root@master ~]# rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.2.el7_2.x86_64</span><br><span class="line">[root@master ~]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.2.el7_2.x86_64</span><br></pre></td></tr></table></figure>

<p><strong>检查有没有删除</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# java -version</span><br><span class="line">-bash: /usr/bin/java: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<p>注：如果还没有删除，则用<code>yum -y remove</code>去删除他们</p>
<h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p><strong>上传jdk到Master的/home/tools/目录下</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# tar -zxvf jdk-8u291-linux-x64.tar.gz</span><br><span class="line">[root@master tools]# rm -rf jdk-8u291-linux-x64.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 把JDK复制到其他机器</span></span></span><br><span class="line">[root@master tools]# scp -r /home/tools/jdk1.8.0_291 root@slave1:/home/tools/jdk1.8.0_291</span><br><span class="line">[root@master tools]# scp -r /home/tools/jdk1.8.0_291 root@slave2:/home/tools/jdk1.8.0_291</span><br></pre></td></tr></table></figure>

<p><strong>进入配置JAVA环境（所以机器）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/home/tools/jdk1.8.0_291</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>

<p><strong>使环境变量生效（所以机器）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# source /etc/profile</span><br></pre></td></tr></table></figure>

<p><strong>测试JDK</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master mysql]# java -version</span><br><span class="line">java version &quot;1.8.0_291&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_291-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)</span><br></pre></td></tr></table></figure>

<h4 id="安装Httpd"><a href="#安装Httpd" class="headerlink" title="安装Httpd"></a>安装Httpd</h4><p><strong>Master安装httpd</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# yum -y install httpd</span><br><span class="line">[root@master tools]# service httpd restart</span><br><span class="line">[root@master tools]# chkconfig httpd on</span><br></pre></td></tr></table></figure>

<h4 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h4><p><strong>上传mysql安装包到/home/tools中（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz</span></span><br><span class="line">[root@master tools]# tar -zxvf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 迁移Mysql</span></span><br><span class="line">[root@master tools]# mv mysql-5.7.17-linux-glibc2.5-x86_64 /usr/local/mysql</span><br></pre></td></tr></table></figure>

<p><strong>创建mysql用户组及用户</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# groupadd mysql</span><br><span class="line">[root@master tools]# useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure>

<p><strong>修改Mysql文件夹用户组及用户</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# cd /usr/local/</span><br><span class="line">[root@master local]# chown -R mysql:mysql mysql</span><br></pre></td></tr></table></figure>

<p><strong>创建Mysql数据目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master local]# mkdir -p /usr/local/mysql/data</span><br><span class="line">[root@master local]# chown -R mysql:mysql data</span><br></pre></td></tr></table></figure>

<p><strong>配置Mysql</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master mysql]# cd /usr/local/mysql/</span><br><span class="line">[root@master mysql]# cp ./support-files/my-default.cnf /etc/my.cnf</span><br><span class="line">[root@master mysql]# vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove leading <span class="comment"># and set to the amount of RAM for the most important data</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cache <span class="keyword">in</span> MySQL. Start at 70% of total RAM <span class="keyword">for</span> dedicated server, <span class="keyword">else</span> 10%.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> innodb_buffer_pool_size = 128M</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove leading <span class="comment"># to turn on a very important data integrity option: logging</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> changes to the binary <span class="built_in">log</span> between backups.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> log_bin</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These are commonly <span class="built_in">set</span>, remove the <span class="comment"># and set as required.</span></span></span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">datadir = /usr/local/mysql/data</span><br><span class="line">port = 3306</span><br><span class="line"><span class="meta">#</span><span class="bash"> server_id = .....</span></span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">character-set-server = utf8</span><br><span class="line">log_error = error.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> socket = .....</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove leading <span class="comment"># to set options mainly useful for reporting servers.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The server defaults are faster <span class="keyword">for</span> transactions and fast SELECTs.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Adjust sizes as needed, experiment to find the optimal values.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> join_buffer_size = 128M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sort_buffer_size = 2M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> read_rnd_buffer_size = 2M</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span></span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTIO</span><br><span class="line">skip_ssl</span><br></pre></td></tr></table></figure>

<p><strong>初始化Mysql</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master mysql]# yum install perl			# mysql依赖</span><br><span class="line">[root@master mysql]# yum install autoconf		# mysql依赖</span><br><span class="line">[root@master mysql]# ./bin/mysqld --initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>

<p><strong>设置Mysql开机启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master mysql]# cp /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld</span><br><span class="line">[root@master mysql]# chmod +x /etc/rc.d/init.d/mysqld </span><br><span class="line">[root@master mysql]# chkconfig --add mysqld</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动Mysql</span></span><br><span class="line">[root@master mysql]# service mysqld start</span><br></pre></td></tr></table></figure>

<p><strong>终端使用mysql命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master mysql]# vi ~/.bash_profile </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入</span></span><br><span class="line">export PATH=$PATH:/usr/local/mysql/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载</span></span><br><span class="line">[root@master mysql]# source ~/.bash_profile </span><br></pre></td></tr></table></figure>

<h4 id="安装ZIP和UNZIP"><a href="#安装ZIP和UNZIP" class="headerlink" title="安装ZIP和UNZIP"></a>安装ZIP和UNZIP</h4><p><strong>上传zip和unzip安装包到/home/tools中（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# rpm -ivh zip-3.0-11.el7.x86_64.rpm</span><br><span class="line">[root@master tools]# rpm -ivh unzip-6.0-21.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h4 id="安装libtirpc"><a href="#安装libtirpc" class="headerlink" title="安装libtirpc"></a>安装libtirpc</h4><p><strong>上传libtirpc-devel安装包到/home/tools中（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# yum install -y libtirpc</span><br><span class="line">[root@master tools]# rpm -ivh libtirpc-devel-0.2.4-0.15.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h4 id="安装Kerberos"><a href="#安装Kerberos" class="headerlink" title="安装Kerberos"></a>安装Kerberos</h4><p><strong>在Master中安装软件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# yum install -y krb5-server krb5-workstation</span><br></pre></td></tr></table></figure>

<p><strong>编辑文件/etc/krb5.conf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# vi /etc/krb5.conf</span><br><span class="line"></span><br><span class="line">[libdefaults]</span><br><span class="line">  renew_lifetime = 7d</span><br><span class="line">  forwardable = true</span><br><span class="line">  default_realm = BIGDATA.COM			# 这个名字必须和realms名字相同</span><br><span class="line">  ticket_lifetime = 24h</span><br><span class="line">  dns_lookup_realm = false</span><br><span class="line">  dns_lookup_kdc = false</span><br><span class="line">  default_ccache_name = /tmp/krb5cc_%&#123;uid&#125;</span><br><span class="line"><span class="meta">  #</span><span class="bash">default_tgs_enctypes = aes des3-cbc-sha1 rc4 des-cbc-md5</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">default_tkt_enctypes = aes des3-cbc-sha1 rc4 des-cbc-md5</span></span><br><span class="line"></span><br><span class="line">[logging]</span><br><span class="line">  default = FILE:/var/log/krb5kdc.log</span><br><span class="line">  admin_server = FILE:/var/log/kadmind.log</span><br><span class="line">  kdc = FILE:/var/log/krb5kdc.log</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line">  BIGDATA.COM = &#123;</span><br><span class="line">    admin_server = master				# 主机名</span><br><span class="line">    kdc = master						# 主机名</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>编辑文件/var/kerberos/krb5kdc/kdc.conf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# vi /var/kerberos/krb5kdc/kdc.conf</span><br><span class="line"></span><br><span class="line">[kdcdefaults]</span><br><span class="line"> kdc_ports = 88</span><br><span class="line"> kdc_tcp_ports = 88</span><br><span class="line"></span><br><span class="line">[realms]</span><br><span class="line"> BIGDATA.COM = &#123;							# 名字和krb5.conf中的realms名字相同</span><br><span class="line"><span class="meta">  #</span><span class="bash">master_key_type = aes256-cts</span></span><br><span class="line">  acl_file = /var/kerberos/krb5kdc/kadm5.acl</span><br><span class="line">  dict_file = /usr/share/dict/words</span><br><span class="line">  admin_keytab = /var/kerberos/krb5kdc/kadm5.keytab</span><br><span class="line">  supported_enctypes = aes256-cts:normal aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal des-cbc-crc:normal</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>编辑文件/var/kerberos/krb5kdc/kadm5.acl</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# vi /var/kerberos/krb5kdc/kadm5.acl</span><br><span class="line">*/admin@BIGDATA.COM     *</span><br></pre></td></tr></table></figure>

<p><strong>初始化数据库</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kdb5_util create -s -r BIGDATA.COM</span><br><span class="line">Loading random data</span><br><span class="line">Initializing database &#x27;/var/kerberos/krb5kdc/principal&#x27; for realm &#x27;BIGDATA.COM&#x27;,</span><br><span class="line">master key name &#x27;K/M@BIGDATA.COM&#x27;</span><br><span class="line">You will be prompted for the database Master Password.</span><br><span class="line">It is important that you NOT FORGET this password.</span><br><span class="line">Enter KDC database master key: 								# 数据库密码，可以回车</span><br><span class="line">Re-enter KDC database master key to verify: 				# 数据库密码，可以回车</span><br><span class="line"></span><br><span class="line">[root@master ~]# ll /var/kerberos/krb5kdc/				# 生成的文件</span><br><span class="line">total 24</span><br><span class="line">-rw-------. 1 root root   22 Jul  7 00:22 kadm5.acl</span><br><span class="line">-rw-------. 1 root root  451 Jul  7 00:22 kdc.conf</span><br><span class="line">-rw-------. 1 root root 8192 Jul  7 00:23 principal</span><br><span class="line">-rw-------. 1 root root 8192 Jul  7 00:23 principal.kadm5</span><br><span class="line">-rw-------. 1 root root    0 Jul  7 00:23 principal.kadm5.lock</span><br><span class="line">-rw-------. 1 root root    0 Jul  7 00:23 principal.ok</span><br></pre></td></tr></table></figure>

<p><strong>初始化KDC超级管理员</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kadmin.local</span><br><span class="line">Authenticating as principal root/admin@BIGDATA.COM with password.</span><br><span class="line">kadmin.local:  addprinc admin/admin				# 新增admin/admin用户</span><br><span class="line">WARNING: no policy specified for admin/admin@BIGDATA.COM; defaulting to no policy</span><br><span class="line">Enter password for principal &quot;admin/admin@BIGDATA.COM&quot;: 					# 输入超级管理员密码</span><br><span class="line">Re-enter password for principal &quot;admin/admin@BIGDATA.COM&quot;: 					# 输入超级管理员密码</span><br><span class="line">Principal &quot;admin/admin@BIGDATA.COM&quot; created.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>启动kerberos</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# systemctl start krb5kdc</span><br><span class="line">[root@master ~]# systemctl start kadmin</span><br><span class="line">[root@master ~]# systemctl enable krb5kdc			# 开机启动</span><br><span class="line">[root@master ~]# systemctl enable kadmin			# 开机启动</span><br></pre></td></tr></table></figure>

<h2 id="安装Ambari"><a href="#安装Ambari" class="headerlink" title="安装Ambari"></a>安装Ambari</h2><h3 id="制作本地Ambari源"><a href="#制作本地Ambari源" class="headerlink" title="制作本地Ambari源"></a>制作本地Ambari源</h3><p><strong>将ambari、hdp、hdp-utils放到/var/www/html/hdp目录下，解压（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master tools]# mkdir -p /var/www/html/hdp</span><br><span class="line">[root@master tools]# cd /var/www/html/hdp</span><br><span class="line">[root@master hdp]# ll</span><br><span class="line">total 10844988</span><br><span class="line">-rw-r--r--. 1 root root 1947685893 Jun 30 16:55 ambari-2.7.3.0-centos7.tar.gz</span><br><span class="line">-rw-r--r--. 1 root root 9066967592 Jun 30 17:41 HDP-3.1.0.0-centos7-rpm.tar.gz</span><br><span class="line">-rw-r--r--. 1 root root   90606616 Jun 30 17:35 HDP-UTILS-1.1.0.22-centos7.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@master hdp]# tar -zxvf ambari-2.7.3.0-centos7.tar.gz</span><br><span class="line">[root@master hdp]# tar -zxvf HDP-3.1.0.0-centos7-rpm.tar.gz</span><br><span class="line">[root@master hdp]# mkdir HDP-UTILS-1.1.0.22</span><br><span class="line">[root@master hdp]# tar -zxvf HDP-UTILS-1.1.0.22-centos7.tar.gz -C /var/www/html/hdp/HDP-UTILS-1.1.0.22/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的tar.gz包</span></span><br><span class="line">[root@master hdp]# rm -rf ambari-2.7.3.0-centos7.tar.gz HDP-3.1.0.0-centos7-rpm.tar.gz HDP-UTILS-1.1.0.22-centos7.tar.gz</span><br><span class="line"></span><br><span class="line">[root@master hdp]# ll</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 3 root root  21 Jun 30 17:46 ambari</span><br><span class="line">drwxr-xr-x. 3 1001 users 21 Dec 11  2018 HDP</span><br><span class="line">drwxr-xr-x. 3 root root  23 Jul  1 09:43 HDP-UTILS-1.1.0.22</span><br></pre></td></tr></table></figure>

<p>现在可以通过访问<a href="http://192.168.1.121/hdp/%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%88%90%E5%8A%9F%E8%AE%BF%E9%97%AE">http://192.168.1.121/hdp/查看是否能成功访问</a></p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/5.png" style="zoom: 67%;" />

<p><strong>安装本地源制作相关工具（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# yum install yum-utils createrepo yum-plugin-priorities -y</span><br><span class="line">[root@master hdp]# createrepo  ./</span><br><span class="line">Spawning worker 0 with 29 pkgs</span><br><span class="line">Spawning worker 1 with 29 pkgs</span><br><span class="line">Spawning worker 2 with 29 pkgs</span><br><span class="line">Spawning worker 3 with 29 pkgs</span><br><span class="line">Spawning worker 4 with 29 pkgs</span><br><span class="line">Spawning worker 5 with 29 pkgs</span><br><span class="line">Spawning worker 6 with 28 pkgs</span><br><span class="line">Spawning worker 7 with 28 pkgs</span><br><span class="line">Workers Finished</span><br><span class="line">Saving Primary metadata</span><br><span class="line">Saving file lists metadata</span><br><span class="line">Saving other metadata</span><br><span class="line">Generating sqlite DBs</span><br><span class="line">Sqlite DBs complete</span><br></pre></td></tr></table></figure>

<p><strong>设置Ambari的yum源（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# vi ambari/centos7/2.7.3.0-139/ambari.repo </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">VERSION_NUMBER=2.7.3.0-139</span></span><br><span class="line">[ambari-2.7.3.0]</span><br><span class="line"><span class="meta">#</span><span class="bash">json.url = http://public-repo-1.hortonworks.com/HDP/hdp_urlinfo.json</span></span><br><span class="line">name=ambari Version - ambari-2.7.3.0</span><br><span class="line"><span class="meta">#</span><span class="bash">baseurl=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0</span></span><br><span class="line">baseurl=http://192.168.1.121/hdp/ambari/centos7/2.7.3.0-139</span><br><span class="line">gpgcheck=1</span><br><span class="line"><span class="meta">#</span><span class="bash">gpgkey=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span></span><br><span class="line">gpgkey=http://192.168.1.121/hdp/ambari/centos7/2.7.3.0-139/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure>

<p><strong>设置HDP的yum源（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# vi HDP/centos7/3.1.0.0-78/hdp.repo </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">VERSION_NUMBER=3.1.0.0-78</span></span><br><span class="line">[HDP-3.1.0.0]</span><br><span class="line">name=HDP Version - HDP-3.1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash">baseurl=http://public-repo-1.hortonworks.com/HDP/centos7/3.x/updates/3.1.0.0</span></span><br><span class="line">baseurl=http://192.168.1.121/hdp/HDP/centos7/3.1.0.0-78</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://192.168.1.121/hdp/HDP/centos7/3.1.0.0-78/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[HDP-UTILS-1.1.0.22]</span><br><span class="line">name=HDP-UTILS Version - HDP-UTILS-1.1.0.22</span><br><span class="line"><span class="meta">#</span><span class="bash">baseurl=http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7</span></span><br><span class="line">baseurl=http://192.168.1.121/hdp/HDP-UTILS-1.1.0.22/HDP-UTILS/centos7/1.1.0.22</span><br><span class="line">gpgcheck=1</span><br><span class="line"><span class="meta">#</span><span class="bash">gpgkey=http://public-repo-1.hortonworks.com/HDP/centos7/3.x/updates/3.1.0.0/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span></span><br><span class="line">gpgkey=http://192.168.1.121/hdp/HDP-UTILS-1.1.0.22/HDP-UTILS/centos7/1.1.0.22/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure>

<p><strong>把设置好的yum文件，复制到/etc/yum.repos.d/（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# cp ambari/centos7/2.7.3.0-139/ambari.repo /etc/yum.repos.d/</span><br><span class="line">[root@master hdp]# cp HDP/centos7/3.1.0.0-78/hdp.repo /etc/yum.repos.d/</span><br></pre></td></tr></table></figure>

<p><strong>分发yum文件到slave1和slave2中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# scp ambari/centos7/2.7.3.0-139/ambari.repo root@slave1:/etc/yum.repos.d/</span><br><span class="line">ambari.repo                                                                                                                                                                    100%  529   925.5KB/s   00:00    </span><br><span class="line">[root@master hdp]# scp ambari/centos7/2.7.3.0-139/ambari.repo root@slave2:/etc/yum.repos.d/</span><br><span class="line">ambari.repo       </span><br><span class="line"></span><br><span class="line">[root@master hdp]# scp HDP/centos7/3.1.0.0-78/hdp.repo root@slave1:/etc/yum.repos.d/</span><br><span class="line">hdp.repo                                                                                                                                                                       100%  801     1.3MB/s   00:00    </span><br><span class="line">[root@master hdp]# scp HDP/centos7/3.1.0.0-78/hdp.repo root@slave2:/etc/yum.repos.d/</span><br><span class="line">hdp.repo    </span><br></pre></td></tr></table></figure>

<p><strong>把设置好的yum重置（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# yum clean all</span><br><span class="line">[root@master hdp]# yum makecache</span><br><span class="line">[root@master hdp]# yum repolist</span><br></pre></td></tr></table></figure>

<h3 id="设置Mysql"><a href="#设置Mysql" class="headerlink" title="设置Mysql"></a>设置Mysql</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master mysql]# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.17 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 设置登录密码</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">set</span> password <span class="keyword">for</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>=password(<span class="string">&#x27;000000&#x27;</span>);</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 添加远程登录用户</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> grant all privileges on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;000000&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>root远程连接赋所有权限，grant all privileges on <em>.</em> to ‘root‘@’%’ with grant option;</p>
</blockquote>
<h3 id="安装配置Ambari"><a href="#安装配置Ambari" class="headerlink" title="安装配置Ambari"></a>安装配置Ambari</h3><p><strong>安装Ambari-Server（Master）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# yum install ambari-server</span><br></pre></td></tr></table></figure>

<p><strong>创建Ambari-Server数据表和用户</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master hdp]# mysql -u root -p</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建表</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE ambari DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use ambari;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建ambari用户</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;ambari&#x27;</span>;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;ambari&#x27;</span>;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;master&#x27;</span> IDENTIFIED BY <span class="string">&#x27;ambari&#x27;</span>;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 授权</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span>  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span>  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;master&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> FLUSH PRIVILEGES;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将SQL脚本加载到ambari数据库中</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql</span> </span><br></pre></td></tr></table></figure>

<p><strong>建立mysql与ambari-server的连接</strong></p>
<p>上传mysql-connector-java-5.1.47.jar到/home/tools中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# mkdir /usr/share/java</span><br><span class="line">[root@master ~]# cp /home/tools/mysql-connector-java-5.1.47.jar /usr/share/java/mysql-connector-java.jar</span><br><span class="line">[root@master ~]# cp /usr/share/java/mysql-connector-java.jar /var/lib/ambari-server/resources/mysql-connector-java.jar</span><br></pre></td></tr></table></figure>

<p><strong>初始化配置Ambari并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ambari-server setup</span><br><span class="line">Using python  /usr/bin/python</span><br><span class="line">Setup ambari-server</span><br><span class="line">Checking SELinux...</span><br><span class="line">SELinux status is &#x27;enabled&#x27;</span><br><span class="line">SELinux mode is &#x27;permissive&#x27;</span><br><span class="line">WARNING: SELinux is set to &#x27;permissive&#x27; mode and temporarily disabled.		# 检查防火墙是否关闭</span><br><span class="line">OK to continue [y/n] (y)? y</span><br><span class="line">Customize user account for ambari-server daemon [y/n] (n)? y				# 提示是否自定义设置</span><br><span class="line">Enter user account for ambari-server daemon (root):							# 如果直接回车就是默认选择root用户</span><br><span class="line">Adjusting ambari-server permissions and ownership...</span><br><span class="line">Checking firewall status...</span><br><span class="line">Checking JDK...</span><br><span class="line">[1] Oracle JDK 1.8 + Java Cryptography Extension (JCE) Policy Files 8</span><br><span class="line">[2] Custom JDK</span><br><span class="line">==============================================================================</span><br><span class="line">Enter choice (1): 2															# 设置JDK</span><br><span class="line">WARNING: JDK must be installed on all hosts and JAVA_HOME must be valid on all hosts.</span><br><span class="line">WARNING: JCE Policy files are required for configuring Kerberos security. If you plan to use Kerberos,please make sure JCE Unlimited Strength Jurisdiction Policy Files are valid on all hosts.</span><br><span class="line">Path to JAVA_HOME: /home/tools/jdk1.8.0_291									# JAVA_HOME地址</span><br><span class="line">Validating JDK on Ambari Server...done.</span><br><span class="line">Check JDK version for Ambari Server...</span><br><span class="line">JDK version found: 8</span><br><span class="line">Minimum JDK version is 8 for Ambari. Skipping to setup different JDK for Ambari Server.</span><br><span class="line">Checking GPL software agreement...</span><br><span class="line">GPL License for LZO: https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html</span><br><span class="line">Enable Ambari Server to download and install GPL Licensed LZO packages [y/n] (n)? </span><br><span class="line">Completing setup...</span><br><span class="line">Configuring database...</span><br><span class="line">Enter advanced database configuration [y/n] (n)? y							# 是否自定义配置数据库</span><br><span class="line">Configuring database...</span><br><span class="line">==============================================================================</span><br><span class="line">Choose one of the following options:</span><br><span class="line">[1] - PostgreSQL (Embedded)</span><br><span class="line">[2] - Oracle</span><br><span class="line">[3] - MySQL / MariaDB</span><br><span class="line">[4] - PostgreSQL</span><br><span class="line">[5] - Microsoft SQL Server (Tech Preview)</span><br><span class="line">[6] - SQL Anywhere</span><br><span class="line">[7] - BDB</span><br><span class="line">==============================================================================</span><br><span class="line">Enter choice (1): 3															# Mysql</span><br><span class="line">Hostname (localhost): 														# Mysql地址</span><br><span class="line">Port (3306): 																# Mysql端口</span><br><span class="line">Database name (ambari): 													# 数据库名</span><br><span class="line">Username (ambari): 															# 用户名</span><br><span class="line">Enter Database Password (bigdata): 											# 密码</span><br><span class="line">Re-enter password: 															# 再次输入密码</span><br><span class="line">Configuring ambari database...</span><br><span class="line">Should ambari use existing default jdbc /usr/share/java/mysql-connector-java.jar [y/n] (y)? </span><br><span class="line">Configuring remote database connection properties...</span><br><span class="line">WARNING: Before starting Ambari Server, you must run the following DDL directly from the database shell to create the schema: /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql</span><br><span class="line">Proceed with configuring remote database connection properties [y/n] (y)? </span><br><span class="line">Extracting system views...</span><br><span class="line">ambari-admin-2.7.3.0.139.jar</span><br><span class="line">....</span><br><span class="line">Ambari repo file contains latest json url http://public-repo-1.hortonworks.com/HDP/hdp_urlinfo.json, updating stacks repoinfos with it...</span><br><span class="line">Adjusting ambari-server permissions and ownership...</span><br><span class="line">Ambari Server &#x27;setup&#x27; completed successfully.</span><br></pre></td></tr></table></figure>

<p><strong>启动日志查看</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ambari-server start</span><br><span class="line">Using python  /usr/bin/python</span><br><span class="line">Starting ambari-server</span><br><span class="line">Ambari Server running with administrator privileges.</span><br><span class="line">Organizing resource files at /var/lib/ambari-server/resources...</span><br><span class="line">Ambari database consistency check started...</span><br><span class="line">Server PID at: /var/run/ambari-server/ambari-server.pid</span><br><span class="line">Server out at: /var/log/ambari-server/ambari-server.out</span><br><span class="line">Server log at: /var/log/ambari-server/ambari-server.log</span><br><span class="line">Waiting for server start.................</span><br><span class="line">Server started listening on 8080</span><br><span class="line"></span><br><span class="line">DB configs consistency check: no errors and warnings were found.</span><br><span class="line">Ambari Server &#x27;start&#x27; completed successfully.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可通过192.168.1.121:8080查看ambari界面</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过tail查看日志</span></span><br><span class="line">[root@master ~]# tail -f /var/log/ambari-server/ambari-server.log</span><br></pre></td></tr></table></figure>

<p><strong>安装Ambari-Agent并设置自启动（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# yum -y install ambari-agent</span><br><span class="line">[root@master ~]# chkconfig --add ambari-agent</span><br></pre></td></tr></table></figure>

<h3 id="可视化配置Ambari"><a href="#可视化配置Ambari" class="headerlink" title="可视化配置Ambari"></a>可视化配置Ambari</h3><p><strong>访问Ambari web页面</strong></p>
<blockquote>
<p>默认端口8080，Username：admin；Password：admin；<a href="http://192.168.1.121:8080/">http://192.168.1.121:8080</a></p>
</blockquote>
<p><strong>开始集群安装</strong></p>
<p>点击启用安装向导，只有在没有安装过HDP集群才有这个界面</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/6.png" style="zoom: 67%;" />

<p>输入集群名称</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/7.png" style="zoom: 67%;" />

<p>设置HDP版本和安装源</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/8.png" style="zoom: 67%;" />

<p>设置集群域的名称和上传密钥</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/9.png" style="zoom: 67%;" />

<p>集群注册</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/10.png" style="zoom: 67%;" />

<p>安装基础插件HDFS、YARN + MapReduce2、Zookeeper、Ambari Metrics、SmartSense</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/11.png" style="zoom: 67%;" />

<p>选择节点安装服务</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/12.png" style="zoom: 67%;" />

<p>集群节点选择配置《DataNode，NodeManager，Client》</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/13.png" style="zoom: 67%;" />

<p>设置密码</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/14.png" style="zoom: 67%;" />

<p>组件地址配置</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/15.png" style="zoom: 67%;" />

<p>组件用户名配置</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/16.png" style="zoom: 67%;" />

<p>CPU、内存资源配置</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/17.png" style="zoom: 67%;" />

<p>查看安装信息，点击DEPLOY进行安装</p>
<img src="https://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/bigdata/ambari/18.png" style="zoom: 67%;" />

<h3 id="Ambari安装问题"><a href="#Ambari安装问题" class="headerlink" title="Ambari安装问题"></a>Ambari安装问题</h3><h4 id="HDP的本地yum源未设置成功"><a href="#HDP的本地yum源未设置成功" class="headerlink" title="HDP的本地yum源未设置成功"></a>HDP的本地yum源未设置成功</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RuntimeError: Failed to execute command &#x27;/usr/bin/yum -y install hdp-select&#x27;, exited with code &#x27;1&#x27;, message: &#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> One of the configured repositories failed (Unknown),</span><br><span class="line"></span><br><span class="line"> and yum doesn&#x27;t have enough cached data to continue. At this point the only</span><br><span class="line"></span><br><span class="line"> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     1. Contact the upstream for the repository and get them to fix the problem.</span><br></pre></td></tr></table></figure>

<p><strong>解决（所有节点）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入yum.repos.d</span></span><br><span class="line">[root@master ~]# cd /etc/yum.repos.d/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看，多了一个ambari-hdp-1.repo文件</span></span><br><span class="line">[root@master yum.repos.d]# ll</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--. 1 root root 171 Jul  1 17:50 ambari-hdp-1.repo</span><br><span class="line">-rw-r--r--. 1 root root 529 Jul  1 17:29 ambari.repo</span><br><span class="line">-rw-r--r--. 1 root root 801 Jul  1 12:53 hdp.repo</span><br><span class="line">-rw-r--r--. 1 root root 132 Jun 30 01:30 local.repo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ambari-hdp-1.repo内容，发现本地repo没有设置进去</span></span><br><span class="line">[root@master yum.repos.d]# cat ambari-hdp-1.repo</span><br><span class="line">[HDP-3.1-repo-1]</span><br><span class="line">name=HDP-3.1-repo-1</span><br><span class="line">baseurl=</span><br><span class="line"></span><br><span class="line">path=/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">[HDP-UTILS-1.1.0.22-repo-1]</span><br><span class="line">name=HDP-UTILS-1.1.0.22-repo-1</span><br><span class="line">baseurl=</span><br><span class="line"></span><br><span class="line">path=/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有节点的ambari-hdp-1.repo文件</span></span><br><span class="line">[root@master yum.repos.d]# rm -rf /etc/yum.repos.d/ambari-hdp-1.repo</span><br></pre></td></tr></table></figure>

<p>重新点击<code>Select Version</code>，重新将<code>HDP-3.1</code>和<code>HDP-UTILS-1.1.0.22</code>设置</p>
<img src="./images/8.png" style="zoom:50%;" />



<h3 id="Ambari组件安装问题"><a href="#Ambari组件安装问题" class="headerlink" title="Ambari组件安装问题"></a>Ambari组件安装问题</h3><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><ol>
<li> Error running Client；org.apache.hadoop.security.AccessControlException: Permission denied: user=ambari-qa, access=EXECUTE, inode=”/user”:hdfs:hdfs:drwxrwx—</li>
</ol>
<blockquote>
<p>解决：</p>
<p>[root@slave2 ~]# su - hdfs</p>
<p>[hdfs@slave2 ~]$ hdfs dfs -setfacl -m user:ambari-qa:rwx /user</p>
</blockquote>
<h4 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h4><ol>
<li><p>resource_management.core.exceptions.Fail: Check db_connection_check was unsuccessful. Exit code: 1. Message: The MySQL JDBC driver has not been set. Please ensure that you have executed ‘ambari-server setup –jdbc-db=mysql –jdbc-driver=/usr/share/jdbc_driver’.</p>
<blockquote>
<p>解决：ambari-server setup –jdbc-db=mysql –jdbc-driver=/usr/share/java/mysql-connector-java.jar</p>
</blockquote>
</li>
</ol>
<h4 id="Ranger"><a href="#Ranger" class="headerlink" title="Ranger"></a>Ranger</h4><ol>
<li><p>Specified key was too long; max key length is 767 bytes</p>
<blockquote>
<p>解决：Mysql 5.6数据库需要设置<code>set global innodb_file_format=BARRACUDA;</code>和<code>set global innodb_large_prefix=1;</code></p>
</blockquote>
</li>
<li><p>If Ranger Hive Plugin is disabled. hive.security.authorization.manager needs to be set to org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory</p>
<blockquote>
<p>解决：在Hive配置中将hive.security.authorization.manager设置为 org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory</p>
</blockquote>
</li>
</ol>
<h4 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h4><ol>
<li><p>Warning Ambari Metrics hbase_master_heapsize 896 Value is less than the recommended default of 1024. HBase Master Heap Size. In embedded mode, total heap size is sum of master and regionserver heap sizes.</p>
<blockquote>
<p>解决：在Ambari Metrics中将HBase Master Maximum Memory调整为1024</p>
</blockquote>
</li>
</ol>
<h4 id="Knox"><a href="#Knox" class="headerlink" title="Knox"></a>Knox</h4><ol>
<li><p>dfs.permissions.enabled needs to be set to true if Ranger HDFS Plugin is enabled.</p>
<blockquote>
<p>解决：在HDFS中将dfs.permissions.enabled设置为true</p>
</blockquote>
</li>
</ol>
<h4 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h4><ol>
<li><p>Atlas is configured to use the HBase installed in this cluster. If you would like Atlas to use another HBase instance, please configure this property and HBASE_CONF_DIR variable in atlas-env appropriately.</p>
<blockquote>
<p>解决：将atlas.graph.storage.hostname设置为对应服务器的IP或根据上实例中的master,slave1,slave2</p>
</blockquote>
</li>
</ol>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ol>
<li><p>Linux内核报错，Message from syslogd@slave2 at Jul  1 19:16:26 … kernel:NMI watchdog: BUG: soft lockup - CPU#7 stuck for 36s! [sshd:29945]</p>
<blockquote>
<p>解决：</p>
<p>echo 30 &gt; /proc/sys/kernel/watchdog_thresh</p>
<p>echo “kernel.watchdog_thresh=30” &gt;&gt; /etc/sysctl.conf</p>
<p>sysctl -w kernel.watchdog_thresh=30</p>
<p>sysctl -q vm.swappiness</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>bigdata</category>
        <category>ambari</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>ambari</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读Spring IOC原理（四）</title>
    <url>/2018/05/10/java/spring/4/</url>
    <content><![CDATA[<h4 id="源码解读Spring-IOC原理（四）"><a href="#源码解读Spring-IOC原理（四）" class="headerlink" title="源码解读Spring IOC原理（四）"></a>源码解读Spring IOC原理（四）</h4><h5 id="IOC容器的高级特性"><a href="#IOC容器的高级特性" class="headerlink" title="IOC容器的高级特性"></a>IOC容器的高级特性</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h6><p>通过前面4篇文章对Spring IoC容器的源码分析，我们已经基本上了解了Spring IoC容器对Bean定义资源的定位、读入和解析过程，同时也清楚了当用户通过getBean方法向IoC容器获取被管理的Bean时，IoC容器对Bean进行的初始化和依赖注入过程，这些是Spring IoC容器的基本功能特性。Spring IoC容器还有一些高级特性，如使用lazy-init属性对Bean预初始化、FactoryBean产生或者修饰Bean对象的生成、IoC容器初始化Bean过程中使用BeanPostProcessor后置处理器对Bean声明周期事件管理和IoC容器的autowiring自动装配功能等。</p>
<span id="more"></span>

<h6 id="Spring-IoC容器的lazy-init属性实现预实例化"><a href="#Spring-IoC容器的lazy-init属性实现预实例化" class="headerlink" title="Spring IoC容器的lazy-init属性实现预实例化"></a><strong>Spring IoC容器的lazy-init属性实现预实例化</strong></h6><p>通过前面我们对IoC容器的实现和工作原理分析，我们知道IoC容器的初始化过程就是对Bean定义资源的定位、载入和注册，此时容器对Bean的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取Bean时，通过getBean方法的调用完成。</p>
<p> 当Bean定义资源的<Bean>元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取被管理的Bean时，就不用再初始化和对Bean进行依赖注入了，直接从容器中获取已经完成依赖注入的现成Bean，可以提高应用第一次向容器获取Bean的性能。</p>
<p>下面我们通过代码分析容器预实例化的实现过程：</p>
<p>(1). refresh()<br>先从IoC容器的初始会过程开始，通过前面文章分析，我们知道IoC容器读入已经定位的Bean定义资源是从refresh方法开始的，我们首先从AbstractApplicationContext类的refresh方法入手分析，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器初始化的过程，读入Bean定义资源，并解析注册  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">            <span class="comment">//调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  </span></span><br><span class="line">            prepareRefresh();  </span><br><span class="line">            <span class="comment">//告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从  </span></span><br><span class="line">            <span class="comment">//子类的refreshBeanFactory()方法启动  </span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  </span><br><span class="line">            <span class="comment">//为BeanFactory配置容器特性，例如类加载器、事件处理器等  </span></span><br><span class="line">           prepareBeanFactory(beanFactory);  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//为容器的某些子类指定特殊的BeanPost事件处理器  </span></span><br><span class="line">               postProcessBeanFactory(beanFactory);  </span><br><span class="line">               <span class="comment">//调用所有注册的BeanFactoryPostProcessor的Bean  </span></span><br><span class="line">               invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">               <span class="comment">//为BeanFactory注册BeanPost事件处理器.  </span></span><br><span class="line">               <span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件  </span></span><br><span class="line">               registerBeanPostProcessors(beanFactory);  </span><br><span class="line">               <span class="comment">//初始化信息源，和国际化相关.  </span></span><br><span class="line">               initMessageSource();  </span><br><span class="line">               <span class="comment">//初始化容器事件传播器.  </span></span><br><span class="line">               initApplicationEventMulticaster();  </span><br><span class="line">               <span class="comment">//调用子类的某些特殊Bean初始化方法  </span></span><br><span class="line">               onRefresh();  </span><br><span class="line">               <span class="comment">//为事件传播器注册事件监听器.  </span></span><br><span class="line">               registerListeners();  </span><br><span class="line">               <span class="comment">//这里是对容器lazy-init属性进行处理的入口方法  </span></span><br><span class="line">               finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">               <span class="comment">//初始化容器的生命周期事件处理器，并发布容器的生命周期事件  </span></span><br><span class="line">               finishRefresh();  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">               <span class="comment">//销毁以创建的单态Bean  </span></span><br><span class="line">               destroyBeans();  </span><br><span class="line">               <span class="comment">//取消refresh操作，重置容器的同步标识.  </span></span><br><span class="line">               cancelRefresh(ex);  </span><br><span class="line">               <span class="keyword">throw</span> ex;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在refresh方法中ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();启动了Bean定义资源的载入、注册过程，而finishBeanFactoryInitialization方法是对注册后的Bean定义中的预实例化(lazy-init=false，Spring默认就是预实例化，即为true)的Bean进行处理的地方。</p>
<p>(2). finishBeanFactoryInitialization处理预实例化Bean</p>
<p>当Bean定义资源被载入IoC容器之后，容器将Bean定义资源解析为容器内部的数据结构BeanDefinition注册到容器中，AbstractApplicationContext类中的finishBeanFactoryInitialization方法对配置了预实例化属性的Bean进行预初始化过程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对配置了lazy-init属性的Bean进行预实例化处理  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService)  </span></span><br><span class="line">       <span class="comment">//在对某些Bean属性进行转换时使用  </span></span><br><span class="line">       <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;  </span><br><span class="line">               beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;  </span><br><span class="line">           beanFactory.setConversionService(  </span><br><span class="line">                   beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//为了类型匹配，停止使用临时的类加载器  </span></span><br><span class="line">       beanFactory.setTempClassLoader(<span class="keyword">null</span>);  </span><br><span class="line">       <span class="comment">//缓存容器中所有注册的BeanDefinition元数据，以防被修改  </span></span><br><span class="line">       beanFactory.freezeConfiguration();  </span><br><span class="line">       <span class="comment">//对配置了lazy-init属性的单态模式Bean进行预实例化处理  </span></span><br><span class="line">       beanFactory.preInstantiateSingletons();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurableListableBeanFactory是一个接口，其preInstantiateSingletons方法由其子类DefaultListableBeanFactory提供。  </p>
<p>(3). DefaultListableBeanFactory对配置lazy-init属性单态Bean的预实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对配置lazy-init属性单态Bean的预实例化  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;  </span><br><span class="line">           <span class="keyword">this</span>.logger.info(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//在对配置lazy-init属性单态Bean的预实例化过程中，必须多线程同步，以确保数据一致性  </span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;  </span><br><span class="line">           <span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;  </span><br><span class="line">               <span class="comment">//获取指定名称的Bean定义  </span></span><br><span class="line">               RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);  </span><br><span class="line">               <span class="comment">//Bean不是抽象的，是单态模式的，且lazy-init属性配置为false  </span></span><br><span class="line">               <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;  </span><br><span class="line">                   <span class="comment">//如果指定名称的bean是创建容器的Bean  </span></span><br><span class="line">                   <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;  </span><br><span class="line">                   <span class="comment">//FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号  </span></span><br><span class="line">                  <span class="comment">//时，获取的是产生容器对象本身，而不是容器产生的Bean.  </span></span><br><span class="line">                  <span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程  </span></span><br><span class="line">                       <span class="keyword">final</span> FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);  </span><br><span class="line">                       <span class="comment">//标识是否需要预实例化  </span></span><br><span class="line">                       <span class="keyword">boolean</span> isEagerInit;  </span><br><span class="line">                       <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;  </span><br><span class="line">                           <span class="comment">//一个匿名内部类  </span></span><br><span class="line">                           isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;  </span><br><span class="line">                               <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                                   <span class="keyword">return</span> ((SmartFactoryBean) factory).isEagerInit();  </span><br><span class="line">                               &#125;  </span><br><span class="line">                           &#125;, getAccessControlContext());  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       <span class="keyword">else</span> &#123;  </span><br><span class="line">                           isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit();   </span><br><span class="line">                       &#125;  </span><br><span class="line">                       <span class="keyword">if</span> (isEagerInit) &#123;  </span><br><span class="line">                          <span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程  </span></span><br><span class="line">                           getBean(beanName);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="comment">//调用getBean方法，触发容器对Bean实例化和依赖注入过程  </span></span><br><span class="line">                       getBean(beanName);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过对lazy-init处理源码的分析，我们可以看出，如果设置了lazy-init属性，则容器在完成Bean定义的注册之后，会通过getBean方法，触发对指定Bean的初始化和依赖注入过程，这样当应用第一次向容器索取所需的Bean时，容器不再需要对Bean进行初始化和依赖注入，直接从已经完成实例化和依赖注入的Bean中取一个线程的Bean，这样就提高了第一次获取Bean的性能。</p>
<h6 id="FactoryBean的实现"><a href="#FactoryBean的实现" class="headerlink" title="FactoryBean的实现"></a>FactoryBean的实现</h6><p>在Spring中，有两个很容易混淆的类：BeanFactory和FactoryBean。<br>BeanFactory：Bean工厂，是一个工厂(Factory)，我们Spring IoC容器的最顶层接口就是这个BeanFactory，它的作用是管理Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
<p>FactoryBean：工厂Bean，是一个Bean，作用是产生其他bean实例。通常情况下，这种bean没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他bean实例。通常情况下，bean无须自己实现工厂模式，Spring容器担任工厂角色；但少数情况下，容器中的bean本身就是工厂，其作用是产生其它bean实例。</p>
<p>当用户使用容器本身时，可以使用转义字符”&amp;”来得到FactoryBean本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身。在BeanFactory中通过如下代码定义了该转义字符：</p>
<p>StringFACTORY_BEAN_PREFIX = “&amp;”;</p>
<p>如果myJndiObject是一个FactoryBean，则使用&amp;myJndiObject得到的是myJndiObject对象，而不是myJndiObject产生出来的对象。</p>
<p>(1).FactoryBean的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂Bean，用于产生其他对</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//获取容器管理的对象实例</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//获取Bean工厂创建的对象的类型</span></span><br><span class="line">    <span class="function">Class <span class="title">getObjectType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例</span></span><br><span class="line">    <span class="comment">//对象，每次请求都返回同一个实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2). AbstractBeanFactory的getBean方法调用FactoryBean<br>在前面我们分析Spring Ioc容器实例化Bean并进行依赖注入过程的源码时，提到在getBean方法触发容器实例化Bean的时候会调用AbstractBeanFactory的doGetBean方法来进行实例化的过程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方    </span></span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    </span><br><span class="line">     <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(    </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span>    </span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> BeansException </span>&#123;    </span><br><span class="line">         <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖    </span></span><br><span class="line">         <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称    </span></span><br><span class="line">         <span class="keyword">final</span> String beanName = transformedBeanName(name);    </span><br><span class="line">         Object bean;    </span><br><span class="line">       <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整    </span></span><br><span class="line">           <span class="comment">//个IoC容器中只创建一次，不需要重复创建    </span></span><br><span class="line">         Object sharedInstance = getSingleton(beanName);    </span><br><span class="line">         <span class="comment">//IoC容器创建单态模式Bean实例对象    </span></span><br><span class="line">         <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;    </span><br><span class="line">             <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;    </span><br><span class="line">             <span class="comment">//如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回    </span></span><br><span class="line">                   <span class="comment">//已经创建的Bean    </span></span><br><span class="line">                 <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;    </span><br><span class="line">                     logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +    </span><br><span class="line">                             <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);    </span><br><span class="line">                 &#125;    </span><br><span class="line">                 <span class="keyword">else</span> &#123;    </span><br><span class="line">                     logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);    </span><br><span class="line">                 &#125;    </span><br><span class="line">             &#125;    </span><br><span class="line">             <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理   </span></span><br><span class="line">             bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">        ……  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//容器已经得到了Bean实例对象，这个实例对象可能是一个普通的Bean，也可能是  </span></span><br><span class="line">       <span class="comment">//一个工厂Bean，如果是一个工厂Bean，则使用它创建一个Bean实例对象，如果  </span></span><br><span class="line">       <span class="comment">//调用本身就想获得一个容器的引用，则指定返回这个工厂Bean实例对象  </span></span><br><span class="line">       <span class="comment">//如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)，  </span></span><br><span class="line">       <span class="comment">//且Bean实例也不是创建Bean实例对象的工厂Bean  </span></span><br><span class="line">       <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果Bean实例不是工厂Bean，或者指定名称是容器的解引用，调用者向获取对  </span></span><br><span class="line">       <span class="comment">//容器的引用，则直接返回当前的Bean实例  </span></span><br><span class="line">       <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> beanInstance;  </span><br><span class="line">       &#125;  </span><br><span class="line">   <span class="comment">//处理指定名称不是容器的解引用，或者根据名称获取的Bean实例对象是一个工厂Bean  </span></span><br><span class="line">   <span class="comment">//使用工厂Bean创建一个Bean的实例对象  </span></span><br><span class="line">       Object object = <span class="keyword">null</span>;  </span><br><span class="line">       <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//从Bean工厂缓存中获取给定名称的Bean实例对象  </span></span><br><span class="line">           object = getCachedObjectForFactoryBean(beanName);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//让Bean工厂生产给定名称的Bean对象实例  </span></span><br><span class="line">       <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           FactoryBean factory = (FactoryBean) beanInstance;  </span><br><span class="line">           <span class="comment">//如果从Bean工厂生产的Bean是单态模式的，则缓存  </span></span><br><span class="line">           <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">               <span class="comment">//从容器中获取指定名称的Bean定义，如果继承基类，则合并基类相关属性  </span></span><br><span class="line">               mbd = getMergedLocalBeanDefinition(beanName);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//如果从容器得到Bean定义信息，并且Bean定义信息不是虚构的，则让工厂  </span></span><br><span class="line">           <span class="comment">//Bean生产Bean实例对象  </span></span><br><span class="line">           <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());  </span><br><span class="line">           <span class="comment">//调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean  </span></span><br><span class="line">           <span class="comment">//方法，实现工厂Bean生产Bean对象实例的过程  </span></span><br><span class="line">           object = getObjectFromFactoryBean(factory, beanName, !synthetic);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> object;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>(3)、AbstractBeanFactory生产Bean实例对象：</p>
<p>AbstractBeanFactory类中生产Bean实例对象的主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bean工厂生产Bean实例对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//Bean工厂是单态模式，并且Bean工厂缓存中存在指定名称的Bean实例对象  </span></span><br><span class="line">       <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;  </span><br><span class="line">           <span class="comment">//多线程同步，以防止数据不一致  </span></span><br><span class="line">           <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;  </span><br><span class="line">               <span class="comment">//直接从Bean工厂缓存中获取指定名称的Bean实例对象  </span></span><br><span class="line">               Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);  </span><br><span class="line">               <span class="comment">//Bean工厂缓存中没有指定名称的实例对象，则生产该实例对象  </span></span><br><span class="line">               <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//调用Bean工厂的getObject方法生产指定Bean的实例对象  </span></span><br><span class="line">                   object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);  </span><br><span class="line">                   <span class="comment">//将生产的实例对象添加到Bean工厂缓存中  </span></span><br><span class="line">                   <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, (object != <span class="keyword">null</span> ? object : NULL_OBJECT));  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">return</span> (object != NULL_OBJECT ? object : <span class="keyword">null</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//调用Bean工厂的getObject方法生产指定Bean的实例对象  </span></span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="keyword">return</span> doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//调用Bean工厂的getObject方法生产指定Bean的实例对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">final</span> FactoryBean factory, <span class="keyword">final</span> String beanName, <span class="keyword">final</span> <span class="keyword">boolean</span> shouldPostProcess)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeanCreationException </span>&#123;  </span><br><span class="line">       Object object;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               AccessControlContext acc = getAccessControlContext();  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="comment">//实现PrivilegedExceptionAction接口的匿名内置类  </span></span><br><span class="line">                   <span class="comment">//根据JVM检查权限，然后决定BeanFactory创建实例对象  </span></span><br><span class="line">                   object = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;  </span><br><span class="line">                       <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                               <span class="comment">//调用BeanFactory接口实现类的创建对象方法  </span></span><br><span class="line">                               <span class="keyword">return</span> factory.getObject();  </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;, acc);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> pae.getException();  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="comment">//调用BeanFactory接口实现类的创建对象方法  </span></span><br><span class="line">               object = factory.getObject();  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//创建出来的实例对象为null，或者因为单态对象正在创建而返回null  </span></span><br><span class="line">       <span class="keyword">if</span> (object == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(  </span><br><span class="line">                   beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//为创建出来的Bean实例对象添加BeanPostProcessor后置处理器  </span></span><br><span class="line">       <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               object = postProcessObjectFromFactoryBean(object, beanName);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Post-processing of the FactoryBean&#x27;s object failed&quot;</span>, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> object;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码分析中，我们可以看出，BeanFactory接口调用其实现类的getObject方法来实现创建Bean实例对象的功能。</p>
<p>(4).工厂Bean的实现类getObject方法创建Bean实例对象：<br>FactoryBean的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean等等，FactoryBean接口为Spring容器提供了一个很好的封装机制，具体的getObject有不同的实现类根据不同的实现策略来具体提供，我们分析一个最简单的AnnotationTestFactoryBean的实现源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTestBeanFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">IJmxTestBean</span>&gt; </span>&#123;  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> FactoryCreatedAnnotationTestBean instance = <span class="keyword">new</span> FactoryCreatedAnnotationTestBean();  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AnnotationTestBeanFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">this</span>.instance.setName(<span class="string">&quot;FACTORY&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//AnnotationTestBeanFactory产生Bean实例对象的实现  </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> IJmxTestBean <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">public</span> Class&lt;? extends IJmxTestBean&gt; getObjectType() &#123;  </span><br><span class="line">           <span class="keyword">return</span> FactoryCreatedAnnotationTestBean.class;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>其他的Proxy，RMI，JNDI等等，都是根据相应的策略提供getObject的实现。这里不做一一分析，这已经不是Spring的核心功能，有需要的时候再去深入研究。</p>
<h6 id="BeanPostProcessor后置处理器的实现"><a href="#BeanPostProcessor后置处理器的实现" class="headerlink" title="BeanPostProcessor后置处理器的实现"></a>BeanPostProcessor后置处理器的实现</h6><p>BeanPostProcessor后置处理器是Spring IoC容器经常使用到的一个特性，这个Bean后置处理器是一个监听器，可以监听容器触发的Bean声明周期事件。后置处理器向容器注册以后，容器中管理的Bean就具备了接收IoC容器事件回调的能力。</p>
<p>BeanPostProcessor的使用非常简单，只需要提供一个实现接口BeanPostProcessor的实现类，然后在Bean的配置文件中设置即可。</p>
<p>(1).BeanPostProcessor的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;  </span><br><span class="line">   <span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//为在Bean的初始化前提供回调入口  </span></span><br><span class="line">       <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;  </span><br><span class="line">       <span class="comment">//为在Bean的初始化之后提供回调入口  </span></span><br><span class="line">       <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>这两个回调的入口都是和容器管理的Bean的生命周期事件紧密相关，可以为用户提供在Spring IoC容器初始化Bean过程中自定义的处理操作。</p>
<p>(2).AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器：<br>BeanPostProcessor后置处理器的调用发生在Spring IoC容器完成对Bean实例对象的创建和属性的依赖注入完成之后，在对Spring依赖注入的源码分析过程中我们知道，当应用程序第一次调用getBean方法(lazy-init预实例化除外)向Spring IoC容器索取指定Bean时触发Spring IoC容器创建Bean实例对象并进行依赖注入的过程，其中真正实现创建Bean对象并进行依赖注入的方法是AbstractAutowireCapableBeanFactory类的doCreateBean方法，主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真正创建Bean的方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//创建Bean实例对象  </span></span><br><span class="line">       ……  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           <span class="comment">//对Bean属性进行依赖注入  </span></span><br><span class="line">           populateBean(beanName, mbd, instanceWrapper);  </span><br><span class="line">           <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="comment">//在对Bean实例对象生成和依赖注入完成以后，开始对Bean实例对象  </span></span><br><span class="line">              <span class="comment">//进行初始化 ，为Bean实例对象应用BeanPostProcessor后置处理器  </span></span><br><span class="line">              exposedObject = initializeBean(beanName, exposedObject, mbd);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> (BeanCreationException) ex;  </span><br><span class="line">           &#125;  </span><br><span class="line">       ……  </span><br><span class="line">       <span class="comment">//为应用返回所需要的实例对象  </span></span><br><span class="line">       <span class="keyword">return</span> exposedObject;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们知道，为Bean实例对象添加BeanPostProcessor后置处理器的入口的是initializeBean方法。</p>
<p>(3).initializeBean方法为容器产生的Bean实例对象添加BeanPostProcessor后置处理器：<br>同样在AbstractAutowireCapableBeanFactory类中，initializeBean方法实现为容器创建的Bean实例对象添加BeanPostProcessor后置处理器，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//JDK的安全机制验证权限  </span></span><br><span class="line">       <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//实现PrivilegedAction接口的匿名内部类  </span></span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                   invokeAwareMethods(beanName, bean);  </span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;, getAccessControlContext());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="comment">//为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息  </span></span><br><span class="line">           invokeAwareMethods(beanName, bean);  </span><br><span class="line">       &#125;  </span><br><span class="line">       Object wrappedBean = bean;  </span><br><span class="line">       <span class="comment">//对BeanPostProcessor后置处理器的postProcessBeforeInitialization  </span></span><br><span class="line">       <span class="comment">//回调方法的调用，为Bean实例初始化前做一些处理  </span></span><br><span class="line">       <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;  </span><br><span class="line">           wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置  </span></span><br><span class="line">       <span class="comment">//文件中通过init-method属性指定的  </span></span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           invokeInitMethods(beanName, wrappedBean, mbd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                   (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),  </span><br><span class="line">                   beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对BeanPostProcessor后置处理器的postProcessAfterInitialization  </span></span><br><span class="line">       <span class="comment">//回调方法的调用，为Bean实例初始化之后做一些处理  </span></span><br><span class="line">       <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;  </span><br><span class="line">           wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> wrappedBean;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//调用BeanPostProcessor后置处理器实例对象初始化之前的处理方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       Object result = existingBean;  </span><br><span class="line">       <span class="comment">//遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器  </span></span><br><span class="line">       <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">           <span class="comment">//调用Bean实例所有的后置处理中的初始化前处理方法，为Bean实例对象在  </span></span><br><span class="line">           <span class="comment">//初始化之前做一些自定义的处理操作  </span></span><br><span class="line">           result = beanProcessor.postProcessBeforeInitialization(result, beanName);  </span><br><span class="line">           <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">return</span> result;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> result;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//调用BeanPostProcessor后置处理器实例对象初始化之后的处理方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       Object result = existingBean;  </span><br><span class="line">       <span class="comment">//遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器  </span></span><br><span class="line">       <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">           <span class="comment">//调用Bean实例所有的后置处理中的初始化后处理方法，为Bean实例对象在  </span></span><br><span class="line">           <span class="comment">//初始化之后做一些自定义的处理操作  </span></span><br><span class="line">           result = beanProcessor.postProcessAfterInitialization(result, beanName);  </span><br><span class="line">           <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">return</span> result;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实现，在Spring中，BeanPostProcessor的实现子类非常的多，分别完成不同的操作，如：AOP面向切面编程的注册通知适配器、Bean对象的数据校验、Bean继承属性/方法的合并等等，我们以最简单的AOP切面织入来简单了解其主要的功能。</p>
<p>(4).AdvisorAdapterRegistrationManager在Bean对象初始化后注册通知适配器：<br>AdvisorAdapterRegistrationManager是BeanPostProcessor的一个实现类，其主要的作用为容器中管理的Bean注册一个面向切面编程的通知适配器，以便在Spring容器为所管理的Bean进行面向切面编程时提供方便，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为容器中管理的Bean注册一个面向切面编程的通知适配器  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisorAdapterRegistrationManager</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;  </span><br><span class="line">   <span class="comment">//容器中负责管理切面通知适配器注册的对象  </span></span><br><span class="line">   <span class="keyword">private</span> AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdvisorAdapterRegistry</span><span class="params">(AdvisorAdapterRegistry advisorAdapterRegistry)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">this</span>.advisorAdapterRegistry = advisorAdapterRegistry;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//BeanPostProcessor在Bean对象初始化前的操作  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="comment">//没有做任何操作，直接返回容器创建的Bean对象  </span></span><br><span class="line">       <span class="keyword">return</span> bean;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//BeanPostProcessor在Bean对象初始化后的操作  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AdvisorAdapter)&#123;  </span><br><span class="line">           <span class="comment">//如果容器创建的Bean实例对象是一个切面通知适配器，则向容器的注册</span></span><br><span class="line">              <span class="keyword">this</span>.advisorAdapterRegistry.registerAdvisorAdapter((AdvisorAdapter) bean);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> bean;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的BeanPostProcessor接口实现类的也类似，都是对Bean对象使用到的一些特性进行处理，或者向IoC容器中注册，为创建的Bean实例对象做一些自定义的功能增加，这些操作是容器初始化Bean时自动触发的，不需要认为的干预。</p>
<h6 id="Spring-IoC容器autowiring实现原理"><a href="#Spring-IoC容器autowiring实现原理" class="headerlink" title="Spring IoC容器autowiring实现原理"></a>Spring IoC容器autowiring实现原理</h6><p>Spring IoC容器提供了两种管理Bean依赖关系的方式：</p>
<blockquote>
<ul>
<li>显式管理：通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理。</li>
<li>autowiring：Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的Bean，从而自动地完成依赖注入。</li>
</ul>
</blockquote>
<p>通过对autowiring自动装配特性的理解，我们知道容器对Bean的自动装配发生在容器对Bean依赖注入的过程中。在前面对Spring IoC容器的依赖注入过程源码分析中，我们已经知道了容器对Bean实例对象的属性注入的处理发生在AbstractAutoWireCapableBeanFactory类中的populateBean方法中，我们通过程序流程分析autowiring的实现原理：</p>
<p>(1). AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入：<br>应用第一次通过getBean方法(配置了lazy-init预实例化属性的除外)向IoC容器索取Bean时，容器创建Bean实例对象，并且对Bean实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory的populateBean方法就是实现Bean属性依赖注入的功能，其主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取Bean定义的属性值，并对属性值进行处理  </span></span><br><span class="line">       PropertyValues pvs = mbd.getPropertyValues();  </span><br><span class="line">       ……  </span><br><span class="line">       <span class="comment">//对依赖注入处理，首先处理autowiring自动装配的依赖注入  </span></span><br><span class="line">       <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </span><br><span class="line">               mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">           MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);  </span><br><span class="line">           <span class="comment">//根据Bean名称进行autowiring自动装配处理  </span></span><br><span class="line">           <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </span><br><span class="line">               autowireByName(beanName, mbd, bw, newPvs);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//根据Bean类型进行autowiring自动装配处理  </span></span><br><span class="line">           <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">               autowireByType(beanName, mbd, bw, newPvs);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对非autowiring的属性进行依赖注入处理  </span></span><br><span class="line">        ……  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>(2).Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据名称对属性进行自动依赖注入  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等//都是简单属性)进行处理  </span></span><br><span class="line">       String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);  </span><br><span class="line">       <span class="keyword">for</span> (String propertyName : propertyNames) &#123;  </span><br><span class="line">           <span class="comment">//如果Spring IoC容器中包含指定名称的Bean  </span></span><br><span class="line">           <span class="keyword">if</span> (containsBean(propertyName)) &#123;  </span><br><span class="line">                <span class="comment">//调用getBean方法向IoC容器索取指定名称的Bean实例，迭代触发属性的//初始化和依赖注入  </span></span><br><span class="line">               Object bean = getBean(propertyName);  </span><br><span class="line">               <span class="comment">//为指定名称的属性赋予属性值  </span></span><br><span class="line">               pvs.add(propertyName, bean);  </span><br><span class="line">               <span class="comment">//指定名称属性注册依赖Bean名称，进行属性依赖注入  </span></span><br><span class="line">               registerDependentBean(propertyName, beanName);  </span><br><span class="line">               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                   logger.debug(<span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +  </span><br><span class="line">                           <span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;  </span><br><span class="line">                   logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +  </span><br><span class="line">                           <span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//根据类型对属性进行自动依赖注入  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取用户定义的类型转换器  </span></span><br><span class="line">       TypeConverter converter = getCustomTypeConverter();  </span><br><span class="line">       <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           converter = bw;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//存放解析的要注入的属性  </span></span><br><span class="line">       Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">4</span>);  </span><br><span class="line">         <span class="comment">//对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符  </span></span><br><span class="line">        <span class="comment">//URL等都是简单属性)进行处理  </span></span><br><span class="line">       String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);  </span><br><span class="line">       <span class="keyword">for</span> (String propertyName : propertyNames) &#123;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//获取指定属性名称的属性描述器  </span></span><br><span class="line">               PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);  </span><br><span class="line">               <span class="comment">//不对Object类型的属性进行autowiring自动依赖注入  </span></span><br><span class="line">               <span class="keyword">if</span> (!Object.class.equals(pd.getPropertyType())) &#123;  </span><br><span class="line">                   <span class="comment">//获取属性的setter方法  </span></span><br><span class="line">                   MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);  </span><br><span class="line">                   <span class="comment">//检查指定类型是否可以被转换为目标对象的类型  </span></span><br><span class="line">                   <span class="keyword">boolean</span> eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());  </span><br><span class="line">                   <span class="comment">//创建一个要被注入的依赖描述  </span></span><br><span class="line">                   DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);  </span><br><span class="line">                   <span class="comment">//根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象  </span></span><br><span class="line">                   Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);  </span><br><span class="line">                   <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                       <span class="comment">//为属性赋值所引用的对象  </span></span><br><span class="line">                       pvs.add(propertyName, autowiredArgument);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;  </span><br><span class="line">                       <span class="comment">//指定名称属性注册依赖Bean名称，进行属性依赖注入  </span></span><br><span class="line">                       registerDependentBean(autowiredBeanName, beanName);  </span><br><span class="line">                       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                           logger.debug(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +  </span><br><span class="line">                                   propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="comment">//释放已自动注入的属性  </span></span><br><span class="line">                   autowiredBeanNames.clear();  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些，但是真正实现属性注入的是DefaultSingletonBeanRegistry类的registerDependentBean方法。</p>
<p>(3).DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为指定的Bean注入依赖的Bean  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//处理Bean名称，将别名转换为规范的Bean名称  </span></span><br><span class="line">       String canonicalName = canonicalName(beanName);  </span><br><span class="line">       <span class="comment">//多线程同步，保证容器内数据的一致性  </span></span><br><span class="line">       <span class="comment">//先从容器中：bean名称--&gt;全部依赖Bean名称集合找查找给定名称Bean的依赖Bean  </span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;  </span><br><span class="line">           <span class="comment">//获取给定名称Bean的所有依赖Bean名称  </span></span><br><span class="line">           Set&lt;String&gt; dependentBeans = <span class="keyword">this</span>.dependentBeanMap.get(canonicalName);  </span><br><span class="line">           <span class="keyword">if</span> (dependentBeans == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="comment">//为Bean设置依赖Bean信息  </span></span><br><span class="line">               dependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">8</span>);  </span><br><span class="line">               <span class="keyword">this</span>.dependentBeanMap.put(canonicalName, dependentBeans);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//向容器中：bean名称--&gt;全部依赖Bean名称集合添加Bean的依赖信息  </span></span><br><span class="line">           <span class="comment">//即，将Bean所依赖的Bean添加到容器的集合中  </span></span><br><span class="line">           dependentBeans.add(dependentBeanName);  </span><br><span class="line">       &#125;  </span><br><span class="line">         <span class="comment">//从容器中：bean名称--&gt;指定名称Bean的依赖Bean集合找查找给定名称  </span></span><br><span class="line">        <span class="comment">//Bean的依赖Bean  </span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;  </span><br><span class="line">           Set&lt;String&gt; dependenciesForBean = <span class="keyword">this</span>.dependenciesForBeanMap.get(dependentBeanName);  </span><br><span class="line">           <span class="keyword">if</span> (dependenciesForBean == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               dependenciesForBean = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">8</span>);  </span><br><span class="line">               <span class="keyword">this</span>.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//向容器中：bean名称--&gt;指定Bean的依赖Bean名称集合添加Bean的依赖信息  </span></span><br><span class="line">           <span class="comment">//即，将Bean所依赖的Bean添加到容器的集合中  </span></span><br><span class="line">           dependenciesForBean.add(canonicalName);  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过对autowiring的源码分析，我们可以看出，autowiring的实现过程：</p>
<blockquote>
<ul>
<li>对Bean的属性迭代调用getBean方法，完成依赖Bean的初始化和依赖注入。</li>
<li>将依赖Bean的属性引用设置到被依赖的Bean属性上。</li>
<li>将依赖Bean的名称和被依赖Bean的名称存储在IoC容器的集合中。</li>
</ul>
</blockquote>
<p>Spring IoC容器的autowiring属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读Spring IOC原理（二）</title>
    <url>/2018/05/10/java/spring/2/</url>
    <content><![CDATA[<h4 id="源码解读Spring-IOC原理（二）"><a href="#源码解读Spring-IOC原理（二）" class="headerlink" title="源码解读Spring IOC原理（二）"></a>源码解读Spring IOC原理（二）</h4><h5 id="IOC容器的初始化？"><a href="#IOC容器的初始化？" class="headerlink" title="IOC容器的初始化？"></a>IOC容器的初始化？</h5><p>IoC容器的初始化包括BeanDefinition的Resource定位、载入和注册这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext系列容器也许是我们最熟悉的，因为web项目中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext等，其继承体系如下图所示<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/4.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"><br>ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。</p>
<span id="more"></span>

<p>下面我们分别简单地演示一下两种ioc容器的创建过程</p>
<h6 id="XmlBeanFactory-屌丝IOC-的整个流程"><a href="#XmlBeanFactory-屌丝IOC-的整个流程" class="headerlink" title="XmlBeanFactory(屌丝IOC)的整个流程"></a>XmlBeanFactory(屌丝IOC)的整个流程</h6><p>通过XmlBeanFactory的源码，我们可以发现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span><span class="keyword">throws</span> BeansException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> BeansException</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息</span></span><br><span class="line">ClassPathResource resource =<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;application-context.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建DefaultListableBeanFactory</span></span><br><span class="line">DefaultListableBeanFactory factory =<span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory</span></span><br><span class="line">XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用</span></span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure>

<p>通过前面的源码，this.reader = new XmlBeanDefinitionReader(this); 中其中this 传的是factory对象</p>
<h6 id="FileSystemXmlApplicationContext-的IOC容器流程"><a href="#FileSystemXmlApplicationContext-的IOC容器流程" class="headerlink" title="FileSystemXmlApplicationContext 的IOC容器流程"></a>FileSystemXmlApplicationContext 的IOC容器流程</h6><p>解剖<code>ApplicationContext = new FileSystemXmlApplicationContext(xmlPath);</code>，调用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String... configLocations)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span>  <span class="keyword">throws</span> BeansException </span>&#123;    </span><br><span class="line"> <span class="keyword">super</span>(parent);  </span><br><span class="line"> setConfigLocations(configLocations);  </span><br><span class="line">  <span class="keyword">if</span> (refresh) &#123;  </span><br><span class="line">   refresh();  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="设置资源加载器和资源定位"><a href="#设置资源加载器和资源定位" class="headerlink" title="设置资源加载器和资源定位"></a>设置资源加载器和资源定位</h6><p>通过分析FileSystemXmlApplicationContext的源代码可以知道，在创建FileSystemXmlApplicationContext容器时，构造方法做以下两项重要工作：</p>
<blockquote>
<ul>
<li>调用父类容器的构造方法(super(parent)方法)为容器设置好Bean资源加载器。</li>
<li>再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置Bean定义资源文件的定位路径。</li>
</ul>
</blockquote>
<p>通过追踪FileSystemXmlApplicationContext的继承体系，发现其父类的父类AbstractApplicationContext中初始化IoC容器所做的主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span>  </span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//静态初始化块，在整个容器创建过程中只执行一次  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="comment">//为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容  </span></span><br><span class="line">       <span class="comment">//器关闭事件(ContextClosedEvent)类  </span></span><br><span class="line">        ContextClosedEvent.class.getName();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//FileSystemXmlApplicationContext调用父类构造方法调用的就是该方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.parent = parent;  </span><br><span class="line">        <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取一个Spring Source的加载器用于读入Spring Bean定义资源文件  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// AbstractApplicationContext继承DefaultResourceLoader，也是一个S  </span></span><br><span class="line">        <span class="comment">//Spring资源加载器，其getResource(String location)方法用于载入资源  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext构造方法中调用PathMatchingResourcePatternResolver的构造方法创建Spring资源加载器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;  </span><br><span class="line">        Assert.notNull(resourceLoader, <span class="string">&quot;ResourceLoader must not be null&quot;</span>);  </span><br><span class="line">        <span class="comment">//设置Spring的资源加载器  </span></span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在设置容器的资源加载器之后，接下来FileSystemXmlApplicationContet执行setConfigLocations方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean定义资源文件的定位，该方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理单个资源文件路径为一个字符串的情况  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String location)</span> </span>&#123;  </span><br><span class="line">   <span class="comment">//String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;  </span></span><br><span class="line">   <span class="comment">//即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式  </span></span><br><span class="line">    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//解析Bean定义资源文件的路径，处理多个资源文件字符串数组  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String[] locations)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);  </span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;  </span><br><span class="line">            <span class="comment">// resolvePath为同一个类中将字符串解析为路径的方法  </span></span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean定义资源文件，也可以使用字符串数组，即下面两种方式都是可以的：</p>
<blockquote>
<ul>
<li>ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”);<br>多个资源文件路径之间可以是用” ,; /t/n”等分隔。</li>
<li>ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……});<br>至此，Spring IoC容器在初始化时将配置的Bean定义资源文件定位为Spring封装的Resource。</li>
</ul>
</blockquote>
<h6 id="AbstractApplicationContext的refresh函数载入Bean定义过程"><a href="#AbstractApplicationContext的refresh函数载入Bean定义过程" class="headerlink" title="AbstractApplicationContext的refresh函数载入Bean定义过程"></a>AbstractApplicationContext的refresh函数载入Bean定义过程</h6><p>Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入</p>
<p>FileSystemXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器对Bean定义的载入过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">          <span class="comment">//调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  </span></span><br><span class="line">          prepareRefresh();  </span><br><span class="line">          <span class="comment">//告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从  </span></span><br><span class="line">         <span class="comment">//子类的refreshBeanFactory()方法启动  </span></span><br><span class="line">          ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  </span><br><span class="line">          <span class="comment">//为BeanFactory配置容器特性，例如类加载器、事件处理器等  </span></span><br><span class="line">          prepareBeanFactory(beanFactory);  </span><br><span class="line">          <span class="keyword">try</span> &#123;  </span><br><span class="line">              <span class="comment">//为容器的某些子类指定特殊的BeanPost事件处理器  </span></span><br><span class="line">              postProcessBeanFactory(beanFactory);  </span><br><span class="line">              <span class="comment">//调用所有注册的BeanFactoryPostProcessor的Bean  </span></span><br><span class="line">              invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">              <span class="comment">//为BeanFactory注册BeanPost事件处理器.  </span></span><br><span class="line">              <span class="comment">//BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件  </span></span><br><span class="line">              registerBeanPostProcessors(beanFactory);  </span><br><span class="line">              <span class="comment">//初始化信息源，和国际化相关.  </span></span><br><span class="line">              initMessageSource();  </span><br><span class="line">              <span class="comment">//初始化容器事件传播器.  </span></span><br><span class="line">              initApplicationEventMulticaster();  </span><br><span class="line">              <span class="comment">//调用子类的某些特殊Bean初始化方法  </span></span><br><span class="line">              onRefresh();  </span><br><span class="line">              <span class="comment">//为事件传播器注册事件监听器.  </span></span><br><span class="line">              registerListeners();  </span><br><span class="line">              <span class="comment">//初始化所有剩余的单态Bean.  </span></span><br><span class="line">              finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">              <span class="comment">//初始化容器的生命周期事件处理器，并发布容器的生命周期事件  </span></span><br><span class="line">              finishRefresh();  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">              <span class="comment">//销毁以创建的单态Bean  </span></span><br><span class="line">              destroyBeans();  </span><br><span class="line">              <span class="comment">//取消refresh操作，重置容器的同步标识.  </span></span><br><span class="line">              cancelRefresh(ex);  </span><br><span class="line">              <span class="keyword">throw</span> ex;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>refresh()方法主要为IoC容器Bean的生命周期管理提供条件，Spring IoC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。</p>
<p>refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入</p>
<p>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程，代码如下：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">        refreshBeanFactory();  </span><br><span class="line">       ConfigurableListableBeanFactory beanFactory = getBeanFactory();  </span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">           logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> beanFactory;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>AbstractApplicationContext子类的refreshBeanFactory()方法：<br>AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的    refreshBeanFactory()方法，方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (hasBeanFactory()) &#123;<span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器  </span></span><br><span class="line">           destroyBeans();  </span><br><span class="line">           closeBeanFactory();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//创建IoC容器  </span></span><br><span class="line">            DefaultListableBeanFactory beanFactory = createBeanFactory();  </span><br><span class="line">            beanFactory.setSerializationId(getId());  </span><br><span class="line">           <span class="comment">//对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等  </span></span><br><span class="line">           customizeBeanFactory(beanFactory);  </span><br><span class="line">           <span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  </span></span><br><span class="line">           loadBeanDefinitions(beanFactory);  </span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;  </span><br><span class="line">               <span class="keyword">this</span>.beanFactory = beanFactory;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关闭beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义</p>
<h6 id="AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法"><a href="#AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法" class="headerlink" title="AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法"></a>AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法</h6><p>AbstractRefreshableApplicationContext中只定义了抽象的loadBeanDefinitions方法，容器真正调用的是其子类AbstractXmlApplicationContext对该方法的实现，AbstractXmlApplicationContext的主要源码如下：<br>loadBeanDefinitions方法同样是抽象方法，是由其子类实现的，也即在AbstractXmlApplicationContext中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> </span>&#123;  </span><br><span class="line">   ……  </span><br><span class="line">   <span class="comment">//实现父类抽象的载入Bean定义方法  </span></span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;  </span><br><span class="line">       <span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源  </span></span><br><span class="line">       XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);  </span><br><span class="line">       <span class="comment">//为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的  </span></span><br><span class="line">       <span class="comment">//祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器  </span></span><br><span class="line">      beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);  </span><br><span class="line">      <span class="comment">//为Bean读取器设置SAX xml解析器  </span></span><br><span class="line">      beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));  </span><br><span class="line">      <span class="comment">//当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制  </span></span><br><span class="line">      initBeanDefinitionReader(beanDefinitionReader);  </span><br><span class="line">      <span class="comment">//Bean读取器真正实现加载的方法  </span></span><br><span class="line">      loadBeanDefinitions(beanDefinitionReader);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//Xml Bean读取器加载Bean定义资源  </span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;  </span><br><span class="line">      <span class="comment">//获取Bean定义资源的定位  </span></span><br><span class="line">      Resource[] configResources = getConfigResources();  </span><br><span class="line">      <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;  </span><br><span class="line">          <span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位  </span></span><br><span class="line">          <span class="comment">//的Bean定义资源  </span></span><br><span class="line">          reader.loadBeanDefinitions(configResources);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源  </span></span><br><span class="line">      String[] configLocations = getConfigLocations();  </span><br><span class="line">      <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;  </span><br><span class="line">          <span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位  </span></span><br><span class="line">          <span class="comment">//的Bean定义资源  </span></span><br><span class="line">          reader.loadBeanDefinitions(configLocations);  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法  </span></span><br><span class="line">  <span class="comment">//该方法在ClassPathXmlApplicationContext中进行实现，对于我们  </span></span><br><span class="line">  <span class="comment">//举例分析源码的FileSystemXmlApplicationContext没有使用该方法  </span></span><br><span class="line">  <span class="keyword">protected</span> Resource[] getConfigResources() &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">  &#125;   ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Xml Bean读取器(XmlBeanDefinitionReader)调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions方法读取Bean定义资源。</p>
<p>由于我们使用FileSystemXmlApplicationContext作为例子分析，因此getConfigResources的返回值为null，因此程序执行reader.loadBeanDefinitions(configLocations)分支。</p>
<h6 id="AbstractBeanDefinitionReader读取Bean定义资源"><a href="#AbstractBeanDefinitionReader读取Bean定义资源" class="headerlink" title="AbstractBeanDefinitionReader读取Bean定义资源"></a>AbstractBeanDefinitionReader读取Bean定义资源</h6><p>AbstractBeanDefinitionReader的loadBeanDefinitions方法源码如下：<br>可以到org.springframework.beans.factory.support看一下BeanDefinitionReader的结构<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/5.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"><br>在其抽象父类AbstractBeanDefinitionReader中定义了载入过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">       <span class="comment">//获取在IoC容器初始化过程中设置的资源加载器  </span></span><br><span class="line">       ResourceLoader resourceLoader = getResourceLoader();  </span><br><span class="line">       <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(  </span><br><span class="line">                   <span class="string">&quot;Cannot import bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源  </span></span><br><span class="line">               <span class="comment">//加载多个指定位置的Bean定义资源文件  </span></span><br><span class="line">               Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);  </span><br><span class="line">               <span class="comment">//委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能  </span></span><br><span class="line">               <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);  </span><br><span class="line">               <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="keyword">for</span> (Resource resource : resources) &#123;  </span><br><span class="line">                       actualResources.add(resource);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                   logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">return</span> loadCount;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(  </span><br><span class="line">                       <span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="comment">//将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源  </span></span><br><span class="line">           <span class="comment">//加载单个指定位置的Bean定义资源文件  </span></span><br><span class="line">           Resource resource = resourceLoader.getResource(location);  </span><br><span class="line">           <span class="comment">//委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能  </span></span><br><span class="line">           <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);  </span><br><span class="line">           <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               actualResources.add(resource);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">               logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> loadCount;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//重载方法，调用loadBeanDefinitions(String);  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">       Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);  </span><br><span class="line">       <span class="keyword">int</span> counter = <span class="number">0</span>;  </span><br><span class="line">       <span class="keyword">for</span> (String location : locations) &#123;  </span><br><span class="line">           counter += loadBeanDefinitions(location);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> counter;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>loadBeanDefinitions(Resource…resources)方法和上面分析的3个方法类似，同样也是调用XmlBeanDefinitionReader的loadBeanDefinitions方法。</p>
<blockquote>
<p>从对AbstractBeanDefinitionReader的loadBeanDefinitions方法源码分析可以看出该方法做了以下两件事：</p>
</blockquote>
<ul>
<li>调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。</li>
<li>真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions方法。</li>
</ul>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/6.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<h6 id="资源加载器获取要读入的资源"><a href="#资源加载器获取要读入的资源" class="headerlink" title="资源加载器获取要读入的资源"></a>资源加载器获取要读入的资源</h6><p>XmlBeanDefinitionReader通过调用其父类DefaultResourceLoader的getResource方法获取要加载的资源，其源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Resource的具体实现方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;  </span><br><span class="line">       Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);  </span><br><span class="line">       <span class="comment">//如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象  </span></span><br><span class="line">       <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());  </span><br><span class="line">       &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">             <span class="comment">// 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象  </span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(location);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (MalformedURLException ex) &#123; </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="comment">//如果既不是classpath标识，又不是URL标识的Resource定位，则调用  </span></span><br><span class="line">           <span class="comment">//容器本身的getResourceByPath方法获取Resource  </span></span><br><span class="line">           <span class="keyword">return</span> getResourceByPath(location);  </span><br><span class="line">           </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>FileSystemXmlApplicationContext容器提供了getResourceByPath方法的实现，就是为了处理既不是classpath标识，又不是URL标识的Resource定位这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;    </span><br><span class="line">   <span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;    </span><br><span class="line">        path = path.substring(<span class="number">1</span>);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//这里使用文件系统资源对象来定义bean 文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样代码就回到了 FileSystemXmlApplicationContext 中来，他提供了FileSystemResource 来完成从文件系统得到配置文件的资源定义。</p>
<p>这样，就可以从文件系统路径上对IOC 配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方加载，在Spring 中我们看到它提供 的各种资源抽象，比如ClassPathResource, URLResource,FileSystemResource 等来供我们使用。上面我们看到的是定位Resource 的一个过程，而这只是加载过程的一部分.</p>
<h6 id="XmlBeanDefinitionReader加载Bean定义资源"><a href="#XmlBeanDefinitionReader加载Bean定义资源" class="headerlink" title="XmlBeanDefinitionReader加载Bean定义资源"></a>XmlBeanDefinitionReader加载Bean定义资源</h6><p>Bean定义的Resource得到了<br>继续回到XmlBeanDefinitionReader的loadBeanDefinitions(Resource …)方法看到代表bean文件的资源定义以后的载入过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//XmlBeanDefinitionReader加载资源的入口方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">       <span class="comment">//将读入的XML资源进行特殊编码处理  </span></span><br><span class="line">       <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));  </span><br><span class="line">   &#125; </span><br><span class="line">     <span class="comment">//这里是载入XML形式Bean定义资源文件方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;    </span><br><span class="line">   .......    </span><br><span class="line">   <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="comment">//将资源文件转为InputStream的IO流 </span></span><br><span class="line">       InputStream inputStream = encodedResource.getResource().getInputStream();    </span><br><span class="line">       <span class="keyword">try</span> &#123;    </span><br><span class="line">          <span class="comment">//从InputStream中得到XML的解析源    </span></span><br><span class="line">           InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);    </span><br><span class="line">           <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;    </span><br><span class="line">               inputSource.setEncoding(encodedResource.getEncoding());    </span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="comment">//这里是具体的读取过程    </span></span><br><span class="line">           <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());    </span><br><span class="line">       &#125;    </span><br><span class="line">       <span class="keyword">finally</span> &#123;    </span><br><span class="line">           <span class="comment">//关闭从Resource中得到的IO流    </span></span><br><span class="line">           inputStream.close();    </span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;    </span><br><span class="line">      .........    </span><br><span class="line"><span class="number">26</span>&#125;    </span><br><span class="line">   <span class="comment">//从特定XML文件中实际载入Bean定义资源的方法 </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span>    </span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;    </span><br><span class="line">   <span class="keyword">try</span> &#123;    </span><br><span class="line">       <span class="keyword">int</span> validationMode = getValidationModeForResource(resource);    </span><br><span class="line">       <span class="comment">//将XML文件转换为DOM对象，解析过程由documentLoader实现    </span></span><br><span class="line">       Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(    </span><br><span class="line">               inputSource, <span class="keyword">this</span>.entityResolver, <span class="keyword">this</span>.errorHandler, validationMode, <span class="keyword">this</span>.namespaceAware);    </span><br><span class="line">       <span class="comment">//这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则</span></span><br><span class="line">       <span class="keyword">return</span> registerBeanDefinitions(doc, resource);    </span><br><span class="line">     &#125;    </span><br><span class="line">     .......    </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现</p>
<h6 id="DocumentLoader将Bean定义资源转换为Document对象"><a href="#DocumentLoader将Bean定义资源转换为Document对象" class="headerlink" title="DocumentLoader将Bean定义资源转换为Document对象"></a>DocumentLoader将Bean定义资源转换为Document对象</h6><p>DocumentLoader将Bean定义资源转换为Document对象，ocumentLoader将Bean定义资源转换成Document对象的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用标准的JAXP将载入的Bean定义资源转换成document对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,  </span></span></span><br><span class="line"><span class="params"><span class="function">           ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">       <span class="comment">//创建文件解析器工厂  </span></span><br><span class="line">       DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);  </span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">           logger.debug(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//创建文档解析器  </span></span><br><span class="line">       DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);  </span><br><span class="line">       <span class="comment">//解析Spring的Bean定义资源  </span></span><br><span class="line">       <span class="keyword">return</span> builder.parse(inputSource);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> ParserConfigurationException </span>&#123;  </span><br><span class="line">       <span class="comment">//创建文档解析工厂  </span></span><br><span class="line">       DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();  </span><br><span class="line">       factory.setNamespaceAware(namespaceAware);  </span><br><span class="line">       <span class="comment">//设置解析XML的校验  </span></span><br><span class="line">       <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;  </span><br><span class="line">           factory.setValidating(<span class="keyword">true</span>);  </span><br><span class="line">           <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;  </span><br><span class="line">               factory.setNamespaceAware(<span class="keyword">true</span>);  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;  </span><br><span class="line">                   ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(  </span><br><span class="line">                           <span class="string">&quot;Unable to validate using XSD: Your JAXP provider [&quot;</span> + factory +  </span><br><span class="line">                           <span class="string">&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot;</span> +  </span><br><span class="line">                           <span class="string">&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;</span>);  </span><br><span class="line">                   pcex.initCause(ex);  </span><br><span class="line">                   <span class="keyword">throw</span> pcex;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> factory;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该解析过程调用JavaEE标准的JAXP标准进行处理。</p>
<p>至此Spring IoC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。</p>
<p>接下来我们要继续分析Spring IoC容器将载入的Bean定义资源文件转换为Document对象之后，是如何将其解析为Spring IoC管理的Bean对象并将其注册到容器中的。</p>
<h6 id="XmlBeanDefinitionReader解析载入的Bean定义资源文件"><a href="#XmlBeanDefinitionReader解析载入的Bean定义资源文件" class="headerlink" title="XmlBeanDefinitionReader解析载入的Bean定义资源文件"></a>XmlBeanDefinitionReader解析载入的Bean定义资源文件</h6><p>XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML文件中实际载入Bean定义资源的方法，该方法在载入Bean定义资源之后将其转换为Document对象，接下来调用registerBeanDefinitions启动Spring IoC容器对Bean定义的解析过程，registerBeanDefinitions方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">       <span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析  </span></span><br><span class="line">       BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();  </span><br><span class="line">       <span class="comment">//获得容器中注册的Bean数量  </span></span><br><span class="line">       <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();  </span><br><span class="line">       <span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成  </span></span><br><span class="line">       documentReader.registerBeanDefinitions(doc, createReaderContext(resource));  </span><br><span class="line">       <span class="comment">//统计解析的Bean数量  </span></span><br><span class="line">       <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//创建BeanDefinitionDocumentReader对象，解析Document对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>Bean定义资源的载入解析分为以下两个过程：</p>
<blockquote>
</blockquote>
<ul>
<li>通过调用XML解析器将Bean定义资源文件转换得到Document对象，但是这些Document对象并没有按照Spring的Bean规则进行解析。这一步是载入的过程</li>
<li>在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析。</li>
</ul>
<p>按照Spring的Bean规则对Document对象解析的过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现的。</p>
<h6 id="DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析"><a href="#DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析" class="headerlink" title="DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析"></a>DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析</h6><p>BeanDefinitionDocumentReader接口通过registerBeanDefinitions方法调用其实现类DefaultBeanDefinitionDocumentReader对Document对象进行解析，解析的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据Spring DTD对Bean的定义规则解析Bean定义Document对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//获得XML描述符  </span></span><br><span class="line">        <span class="keyword">this</span>.readerContext = readerContext;  </span><br><span class="line">        logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);  </span><br><span class="line">        <span class="comment">//获得Document的根元素  </span></span><br><span class="line">        Element root = doc.getDocumentElement();  </span><br><span class="line">        <span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，  </span></span><br><span class="line">        <span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素  </span></span><br><span class="line">       BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);  </span><br><span class="line">       <span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性  </span></span><br><span class="line">       preProcessXml(root);  </span><br><span class="line">       <span class="comment">//从Document的根元素开始进行Bean定义的Document对象  </span></span><br><span class="line">       parseBeanDefinitions(root, delegate);  </span><br><span class="line">       <span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性  </span></span><br><span class="line">       postProcessXml(root);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//创建BeanDefinitionParserDelegate，用于完成真正的解析过程  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createHelper</span><span class="params">(XmlReaderContext readerContext, Element root)</span> </span>&#123;  </span><br><span class="line">       BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);  </span><br><span class="line">       <span class="comment">//BeanDefinitionParserDelegate初始化Document根元素  </span></span><br><span class="line">       delegate.initDefaults(root);  </span><br><span class="line">       <span class="keyword">return</span> delegate;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间  </span></span><br><span class="line">       <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;  </span><br><span class="line">           <span class="comment">//获取Bean定义的Document对象根元素的所有子节点  </span></span><br><span class="line">           NodeList nl = root.getChildNodes();  </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </span><br><span class="line">               Node node = nl.item(i);  </span><br><span class="line">               <span class="comment">//获得Document节点是XML元素节点  </span></span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;  </span><br><span class="line">                   Element ele = (Element) node;  </span><br><span class="line">               <span class="comment">//Bean定义的Document的元素节点使用的是Spring默认的XML命名空间  </span></span><br><span class="line">                   <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;  </span><br><span class="line">                       <span class="comment">//使用Spring的Bean规则解析元素节点  </span></span><br><span class="line">                       parseDefaultElement(ele, delegate);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">else</span> &#123;  </span><br><span class="line">                       <span class="comment">//没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点  </span></span><br><span class="line">                       delegate.parseCustomElement(ele);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="comment">//Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的  </span></span><br><span class="line">           <span class="comment">//解析规则解析Document根节点  </span></span><br><span class="line">           delegate.parseCustomElement(root);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//使用Spring的Bean规则解析Document元素节点  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//如果元素节点是&lt;Import&gt;导入元素，进行导入解析  </span></span><br><span class="line">       <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;  </span><br><span class="line">           importBeanDefinitionResource(ele);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果元素节点是&lt;Alias&gt;别名元素，进行别名解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;  </span><br><span class="line">           processAliasRegistration(ele);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素，  </span></span><br><span class="line">       <span class="comment">//按照Spring的Bean规则解析元素  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;  </span><br><span class="line">           processBeanDefinition(ele, delegate);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析&lt;Import&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取给定的导入元素的location属性  </span></span><br><span class="line">       String location = ele.getAttribute(RESOURCE_ATTRIBUTE);  </span><br><span class="line">       <span class="comment">//如果导入元素的location属性值为空，则没有导入任何资源，直接返回  </span></span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;  </span><br><span class="line">           getReaderContext().error(<span class="string">&quot;Resource location must not be empty&quot;</span>, ele);  </span><br><span class="line">           <span class="keyword">return</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//使用系统变量值解析location属性值  </span></span><br><span class="line">       location = SystemPropertyUtils.resolvePlaceholders(location);  </span><br><span class="line">       Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">4</span>);  </span><br><span class="line">       <span class="comment">//标识给定的导入元素的location是否是绝对路径  </span></span><br><span class="line">       <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (URISyntaxException ex) &#123;  </span><br><span class="line">           <span class="comment">//给定的导入元素的location不是绝对路径  </span></span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//给定的导入元素的location是绝对路径  </span></span><br><span class="line">       <span class="keyword">if</span> (absoluteLocation) &#123;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//使用资源读入器加载给定路径的Bean定义资源  </span></span><br><span class="line">               <span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);  </span><br><span class="line">               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                   logger.debug(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;  </span><br><span class="line">               getReaderContext().error(  </span><br><span class="line">                       <span class="string">&quot;Failed to import bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ele, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="comment">//给定的导入元素的location是相对路径  </span></span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="keyword">int</span> importCount;  </span><br><span class="line">               <span class="comment">//将给定导入元素的location封装为相对路径资源  </span></span><br><span class="line">               Resource relativeResource = getReaderContext().getResource().createRelative(location);  </span><br><span class="line">               <span class="comment">//封装的相对路径资源存在  </span></span><br><span class="line">               <span class="keyword">if</span> (relativeResource.exists()) &#123;  </span><br><span class="line">                   <span class="comment">//使用资源读入器加载Bean定义资源  </span></span><br><span class="line">                   importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);  </span><br><span class="line">                   actualResources.add(relativeResource);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//封装的相对路径资源不存在  </span></span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   <span class="comment">//获取Spring IoC容器资源读入器的基本路径  </span></span><br><span class="line">                   String baseLocation = getReaderContext().getResource().getURL().toString();  </span><br><span class="line">                   <span class="comment">//根据Spring IoC容器资源读入器的基本路径加载给定导入  </span></span><br><span class="line">                   <span class="comment">//路径的资源  </span></span><br><span class="line">                   importCount = getReaderContext().getReader().loadBeanDefinitions(  </span><br><span class="line">                           StringUtils.applyRelativePath(baseLocation, location), actualResources);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                   logger.debug(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">               getReaderContext().error(<span class="string">&quot;Failed to resolve current resource location&quot;</span>, ele, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;  </span><br><span class="line">               getReaderContext().error(<span class="string">&quot;Failed to import bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>,  </span><br><span class="line">                       ele, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[actualResources.size()]);  </span><br><span class="line">       <span class="comment">//在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件  </span></span><br><span class="line">       getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析&lt;Alias&gt;别名元素，为Bean向Spring IoC容器注册别名  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取&lt;Alias&gt;别名元素中name的属性值  </span></span><br><span class="line">       String name = ele.getAttribute(NAME_ATTRIBUTE);  </span><br><span class="line">       <span class="comment">//获取&lt;Alias&gt;别名元素中alias的属性值  </span></span><br><span class="line">       String alias = ele.getAttribute(ALIAS_ATTRIBUTE);  </span><br><span class="line">       <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;  </span><br><span class="line">       <span class="comment">//&lt;alias&gt;别名元素的name属性值为空  </span></span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;  </span><br><span class="line">           getReaderContext().error(<span class="string">&quot;Name must not be empty&quot;</span>, ele);  </span><br><span class="line">           valid = <span class="keyword">false</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//&lt;alias&gt;别名元素的alias属性值为空  </span></span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;  </span><br><span class="line">           getReaderContext().error(<span class="string">&quot;Alias must not be empty&quot;</span>, ele);  </span><br><span class="line">           valid = <span class="keyword">false</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (valid) &#123;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//向容器的资源读入器注册别名  </span></span><br><span class="line">               getReaderContext().getRegistry().registerAlias(name, alias);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">               getReaderContext().error(<span class="string">&quot;Failed to register alias &#x27;&quot;</span> + alias +  </span><br><span class="line">                       <span class="string">&quot;&#x27; for bean with name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件  </span></span><br><span class="line">           getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析Bean定义资源Document对象的普通元素  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类  </span></span><br><span class="line">       <span class="comment">//对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);  </span></span><br><span class="line">       <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">              <span class="comment">//向Spring IoC容器注册解析得到的Bean定义，这是Bean定义向IoC容器注册的入口            </span></span><br><span class="line">                  BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;  </span><br><span class="line">               getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +  </span><br><span class="line">                       bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//在完成向Spring IoC容器注册解析得到的Bean定义之后，发送注册事件  </span></span><br><span class="line">           getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过上述Spring IoC容器对载入的Bean定义Document解析可以看出，我们使用Spring时，在Spring配置文件中可以使用<Import>元素来导入IoC容器所需要的其他资源，Spring IoC容器在解析时会首先将指定导入的资源加载进容器中。使用<Ailas>别名时，Spring IoC容器首先将别名元素所定义的别名注册到容器中。</p>
<p>对于既不是<Import>元素，又不是<Alias>元素的元素，即Spring配置文件中普通的<Bean>元素的解析由BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法来实现。</p>
<h6 id="BeanDefinitionParserDelegate解析Bean定义资源文件中的元素"><a href="#BeanDefinitionParserDelegate解析Bean定义资源文件中的元素" class="headerlink" title="BeanDefinitionParserDelegate解析Bean定义资源文件中的元素"></a>BeanDefinitionParserDelegate解析Bean定义资源文件中的<Bean>元素</h6><p>Bean定义资源文件中的<Import>和<Alias>元素解析在DefaultBeanDefinitionDocumentReader中已经完成，对Bean定义资源文件中使用最多的<Bean>元素交由BeanDefinitionParserDelegate来解析，其解析实现的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析&lt;Bean&gt;元素的入口  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析Bean定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的id，name  </span></span><br><span class="line">   <span class="comment">//和别名属性  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取&lt;Bean&gt;元素中的id属性值  </span></span><br><span class="line">       String id = ele.getAttribute(ID_ATTRIBUTE);  </span><br><span class="line">       <span class="comment">//获取&lt;Bean&gt;元素中的name属性值  </span></span><br><span class="line">       String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);  </span><br><span class="line">       <span class="comment">////获取&lt;Bean&gt;元素中的alias属性值  </span></span><br><span class="line">       List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">       <span class="comment">//将&lt;Bean&gt;元素中的所有name属性值存放到别名中  </span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;  </span><br><span class="line">           String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);  </span><br><span class="line">           aliases.addAll(Arrays.asList(nameArr));  </span><br><span class="line">       &#125;  </span><br><span class="line">       String beanName = id;  </span><br><span class="line">       <span class="comment">//如果&lt;Bean&gt;元素中没有配置id属性时，将别名中的第一个值赋值给beanName  </span></span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;  </span><br><span class="line">           beanName = aliases.remove(<span class="number">0</span>);  </span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">               logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +  </span><br><span class="line">                       <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt;  </span></span><br><span class="line">       <span class="comment">//元素中是否包含子&lt;Bean&gt;元素  </span></span><br><span class="line">       <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复  </span></span><br><span class="line">           checkNameUniqueness(beanName, aliases, ele);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方  </span></span><br><span class="line">       AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);  </span><br><span class="line">       <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                       <span class="comment">//如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子//&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册  </span></span><br><span class="line">                       beanName = BeanDefinitionReaderUtils.generateBeanName(  </span><br><span class="line">                               beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">else</span> &#123;  </span><br><span class="line">                       <span class="comment">//如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子//&lt;Bean&gt;元素，为解析的Bean使用别名向IoC容器注册  </span></span><br><span class="line">                       beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);  </span><br><span class="line">                       <span class="comment">//为解析的Bean使用别名注册时，为了向后兼容                                    //Spring1.2/2.0，给别名添加类名后缀  </span></span><br><span class="line">                       String beanClassName = beanDefinition.getBeanClassName();  </span><br><span class="line">                       <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;  </span><br><span class="line">                               beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;  </span><br><span class="line">                               !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;  </span><br><span class="line">                           aliases.add(beanClassName);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                       logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +  </span><br><span class="line">                               <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                   error(ex.getMessage(), ele);  </span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           String[] aliasesArray = StringUtils.toStringArray(aliases);  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//当解析出错时，返回null  </span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//详细对&lt;Bean&gt;元素中配置的Bean定义其他属性进行解析，由于上面的方法中已经对//Bean的id、name和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//记录解析的&lt;Bean&gt;  </span></span><br><span class="line">       <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));  </span><br><span class="line">       <span class="comment">//这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去  </span></span><br><span class="line">       <span class="comment">//只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成  </span></span><br><span class="line">       String className = <span class="keyword">null</span>;  </span><br><span class="line">       <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;  </span><br><span class="line">           className = ele.getAttribute(CLASS_ATTRIBUTE).trim();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           String parent = <span class="keyword">null</span>;  </span><br><span class="line">           <span class="comment">//如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值  </span></span><br><span class="line">           <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;  </span><br><span class="line">               parent = ele.getAttribute(PARENT_ATTRIBUTE);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition  </span></span><br><span class="line">           <span class="comment">//为载入Bean定义信息做准备  </span></span><br><span class="line">           AbstractBeanDefinition bd = createBeanDefinition(className, parent);  </span><br><span class="line">           <span class="comment">//对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等  </span></span><br><span class="line">           parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);  </span><br><span class="line">           <span class="comment">//为&lt;Bean&gt;元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));  </span></span><br><span class="line">           <span class="comment">//对&lt;Bean&gt;元素的meta(元信息)属性解析  </span></span><br><span class="line">           parseMetaElements(ele, bd);  </span><br><span class="line">           <span class="comment">//对&lt;Bean&gt;元素的lookup-method属性解析  </span></span><br><span class="line">           parseLookupOverrideSubElements(ele, bd.getMethodOverrides());  </span><br><span class="line">           <span class="comment">//对&lt;Bean&gt;元素的replaced-method属性解析  </span></span><br><span class="line">           parseReplacedMethodSubElements(ele, bd.getMethodOverrides());  </span><br><span class="line">           <span class="comment">//解析&lt;Bean&gt;元素的构造方法设置  </span></span><br><span class="line">           parseConstructorArgElements(ele, bd);  </span><br><span class="line">           <span class="comment">//解析&lt;Bean&gt;元素的&lt;property&gt;设置  </span></span><br><span class="line">           parsePropertyElements(ele, bd);  </span><br><span class="line">           <span class="comment">//解析&lt;Bean&gt;元素的qualifier属性  </span></span><br><span class="line">           parseQualifierElements(ele, bd);  </span><br><span class="line">           <span class="comment">//为当前解析的Bean设置所需的资源和依赖对象  </span></span><br><span class="line">           bd.setResource(<span class="keyword">this</span>.readerContext.getResource());  </span><br><span class="line">           bd.setSource(extractSource(ele));  </span><br><span class="line">           <span class="keyword">return</span> bd;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;  </span><br><span class="line">           error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;  </span><br><span class="line">           error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">finally</span> &#123;  </span><br><span class="line">           <span class="keyword">this</span>.parseState.pop();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//解析&lt;Bean&gt;元素出错时，返回null  </span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>只要使用过Spring，对Spring配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在Spring配置文件中<Bean>元素的中配置的属性就是通过该方法解析和设置到Bean中去的。</p>
<p>注意：在解析<Bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition，将<Bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象。</p>
<p>上面方法中一些对一些配置如元信息(meta)、qualifier等的解析，我们在Spring中配置时使用的也不多，我们在使用Spring的<Bean>元素时，配置最多的是<property>属性，因此我们下面继续分析源码，了解Bean的属性在解析时是如何设置的。</p>
<h6 id="BeanDefinitionParserDelegate解析元素"><a href="#BeanDefinitionParserDelegate解析元素" class="headerlink" title="BeanDefinitionParserDelegate解析元素"></a>BeanDefinitionParserDelegate解析<property>元素</h6><p>BeanDefinitionParserDelegate在解析<Bean>调用parsePropertyElements方法解析<Bean>元素中的<property>属性子元素，解析源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取&lt;Bean&gt;元素中所有的子元素  </span></span><br><span class="line">       NodeList nl = beanEle.getChildNodes();  </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </span><br><span class="line">           Node node = nl.item(i);  </span><br><span class="line">           <span class="comment">//如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析  </span></span><br><span class="line">           <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;  </span><br><span class="line">               parsePropertyElement((Element) node, bd);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析&lt;property&gt;元素  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取&lt;property&gt;元素的名字   </span></span><br><span class="line">       String propertyName = ele.getAttribute(NAME_ATTRIBUTE);  </span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;  </span><br><span class="line">           error(<span class="string">&quot;Tag &#x27;property&#x27; must have a &#x27;name&#x27; attribute&quot;</span>, ele);  </span><br><span class="line">           <span class="keyword">return</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           <span class="comment">//如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。  </span></span><br><span class="line">           <span class="comment">//即如果在同一个Bean中配置同名的property，则只有第一个起作用  </span></span><br><span class="line">           <span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;  </span><br><span class="line">               error(<span class="string">&quot;Multiple &#x27;property&#x27; definitions for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ele);  </span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//解析获取property的值  </span></span><br><span class="line">           Object val = parsePropertyValue(ele, bd, propertyName);  </span><br><span class="line">           <span class="comment">//根据property的名字和值创建property实例  </span></span><br><span class="line">           PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);  </span><br><span class="line">           <span class="comment">//解析&lt;property&gt;元素中的属性  </span></span><br><span class="line">           parseMetaElements(ele, pv);  </span><br><span class="line">           pv.setSource(extractSource(ele));  </span><br><span class="line">           bd.getPropertyValues().addPropertyValue(pv);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">finally</span> &#123;  </span><br><span class="line">           <span class="keyword">this</span>.parseState.pop();  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析获取property值  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, String propertyName)</span> </span>&#123;  </span><br><span class="line">       String elementName = (propertyName != <span class="keyword">null</span>) ?  </span><br><span class="line">                       <span class="string">&quot;&lt;property&gt; element for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span> :  </span><br><span class="line">                       <span class="string">&quot;&lt;constructor-arg&gt; element&quot;</span>;  </span><br><span class="line">       <span class="comment">//获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list等  </span></span><br><span class="line">       NodeList nl = ele.getChildNodes();  </span><br><span class="line">       Element subElement = <span class="keyword">null</span>;  </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </span><br><span class="line">           Node node = nl.item(i);  </span><br><span class="line">           <span class="comment">//子元素不是description和meta属性  </span></span><br><span class="line">           <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;  </span><br><span class="line">                   !nodeNameEquals(node, META_ELEMENT)) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   error(elementName + <span class="string">&quot; must not contain more than one sub-element&quot;</span>, ele);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;<span class="comment">//当前&lt;property&gt;元素包含有子元素  </span></span><br><span class="line">                   subElement = (Element) node;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//判断property的属性值是ref还是value，不允许既是ref又是value  </span></span><br><span class="line">       <span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);  </span><br><span class="line">       <span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);  </span><br><span class="line">       <span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||  </span><br><span class="line">               ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) &#123;  </span><br><span class="line">           error(elementName +  </span><br><span class="line">                   <span class="string">&quot; is only allowed to contain either &#x27;ref&#x27; attribute OR &#x27;value&#x27; attribute OR sub-element&quot;</span>, ele);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象  </span></span><br><span class="line">       <span class="comment">//封装了ref信息  </span></span><br><span class="line">       <span class="keyword">if</span> (hasRefAttribute) &#123;  </span><br><span class="line">           String refName = ele.getAttribute(REF_ATTRIBUTE);  </span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;  </span><br><span class="line">               error(elementName + <span class="string">&quot; contains empty &#x27;ref&#x27; attribute&quot;</span>, ele);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//一个指向运行时所依赖对象的引用  </span></span><br><span class="line">           RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);  </span><br><span class="line">           <span class="comment">//设置这个ref的数据对象是被当前的property对象所引用  </span></span><br><span class="line">           ref.setSource(extractSource(ele));  </span><br><span class="line">           <span class="keyword">return</span> ref;  </span><br><span class="line">       &#125;  </span><br><span class="line">        <span class="comment">//如果属性是value，创建一个value的数据对象TypedStringValue，这个对象  </span></span><br><span class="line">       <span class="comment">//封装了value信息  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;  </span><br><span class="line">           <span class="comment">//一个持有String类型值的对象  </span></span><br><span class="line">           TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));  </span><br><span class="line">           <span class="comment">//设置这个value数据对象是被当前的property对象所引用  </span></span><br><span class="line">           valueHolder.setSource(extractSource(ele));  </span><br><span class="line">           <span class="keyword">return</span> valueHolder;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果当前&lt;property&gt;元素还有子元素  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//解析&lt;property&gt;的子元素  </span></span><br><span class="line">           <span class="keyword">return</span> parsePropertySubElement(subElement, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="comment">//propery属性中既不是ref，也不是value属性，解析出错返回null        error(elementName + &quot; must specify a ref or value&quot;, ele);  </span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过对上述源码的分析，我们可以了解在Spring配置文件中，<Bean>元素中<property>元素的相关配置是如何处理的：</p>
<blockquote>
<ul>
<li>ref被封装为指向依赖对象一个引用</li>
<li>value配置都会封装成一个字符串类型的对象</li>
<li>ref和value都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来</li>
</ul>
</blockquote>
<p>在方法的最后对于<property>元素的子元素通过parsePropertySubElement 方法解析，我们继续分析该方法的源码，了解其解析过程。</p>
<h6 id="解析元素的子元素"><a href="#解析元素的子元素" class="headerlink" title="解析元素的子元素"></a>解析<property>元素的子元素</h6><p>在BeanDefinitionParserDelegate类中的parsePropertySubElement方法对<property>中的子元素解析，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析&lt;property&gt;元素中ref,value或者集合等子元素  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, BeanDefinition bd, String defaultValueType)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//如果&lt;property&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析//内嵌元素  </span></span><br><span class="line">       <span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseNestedCustomElement(ele, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是bean，则使用解析&lt;Bean&gt;元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;  </span><br><span class="line">           BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);  </span><br><span class="line">           <span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> nestedBd;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是ref，ref中只能有以下3个属性：bean、local、parent  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;  </span><br><span class="line">           <span class="comment">//获取&lt;property&gt;元素中的bean属性值，引用其他解析的Bean的名称  </span></span><br><span class="line">           <span class="comment">//可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则  </span></span><br><span class="line">           String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);  </span><br><span class="line">           <span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;  </span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;  </span><br><span class="line">                <span class="comment">//获取&lt;property&gt;元素中的local属性值，引用同一个Xml文件中配置  </span></span><br><span class="line">                <span class="comment">//的Bean的id，local和ref不同，local只能引用同一个配置文件中的Bean  </span></span><br><span class="line">               refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);  </span><br><span class="line">               <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;  </span><br><span class="line">                   <span class="comment">//获取&lt;property&gt;元素中parent属性值，引用父级容器中的Bean  </span></span><br><span class="line">                   refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);  </span><br><span class="line">                   toParent = <span class="keyword">true</span>;  </span><br><span class="line">                   <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;  </span><br><span class="line">                       error(<span class="string">&quot;&#x27;bean&#x27;, &#x27;local&#x27; or &#x27;parent&#x27; is required for &lt;ref&gt; element&quot;</span>, ele);  </span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//没有配置ref的目标属性值  </span></span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;  </span><br><span class="line">               error(<span class="string">&quot;&lt;ref&gt; element contains empty target attribute&quot;</span>, ele);  </span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//创建ref类型数据，指向被引用的对象  </span></span><br><span class="line">           RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);  </span><br><span class="line">           <span class="comment">//设置引用类型值是被当前子元素所引用  </span></span><br><span class="line">           ref.setSource(extractSource(ele));  </span><br><span class="line">           <span class="keyword">return</span> ref;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;idref&gt;，使用解析ref元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseIdRefElement(ele);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;value&gt;，使用解析value元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseValueElement(ele, defaultValueType);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是null，为&lt;property&gt;设置一个封装null值的字符串数据  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;  </span><br><span class="line">           TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);  </span><br><span class="line">           nullHolder.setSource(extractSource(ele));  </span><br><span class="line">           <span class="keyword">return</span> nullHolder;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;array&gt;，使用解析array集合子元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseArrayElement(ele, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;list&gt;，使用解析list集合子元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseListElement(ele, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;set&gt;，使用解析set集合子元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseSetElement(ele, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;map&gt;，使用解析map集合子元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parseMapElement(ele, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//如果子元素是&lt;props&gt;，使用解析props集合子元素的方法解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;  </span><br><span class="line">           <span class="keyword">return</span> parsePropsElement(ele);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//既不是ref，又不是value，也不是集合，则子元素配置错误，返回null  </span></span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           error(<span class="string">&quot;Unknown property sub-element: [&quot;</span> + ele.getNodeName() + <span class="string">&quot;]&quot;</span>, ele);  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上述源码分析，我们明白了在Spring配置文件中，对<property>元素中配置的Array、List、Set、Map、Prop等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如ManagedList、ManagedArray、ManagedSet等，这些Managed类是Spring对象BeanDefiniton的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。</p>
<h6 id="解析子元素"><a href="#解析子元素" class="headerlink" title="解析子元素"></a>解析<list>子元素</h6><p>在BeanDefinitionParserDelegate类中的parseListElement方法就是具体实现解析<property>元素中的<list>集合子元素，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析&lt;list&gt;集合子元素  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List <span class="title">parseListElement</span><span class="params">(Element collectionEle, BeanDefinition bd)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取&lt;list&gt;元素中的value-type属性，即获取集合元素的数据类型  </span></span><br><span class="line">       String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);  </span><br><span class="line">       <span class="comment">//获取&lt;list&gt;集合元素中的所有子节点  </span></span><br><span class="line">       NodeList nl = collectionEle.getChildNodes();  </span><br><span class="line">       <span class="comment">//Spring中将List封装为ManagedList  </span></span><br><span class="line">       ManagedList&lt;Object&gt; target = <span class="keyword">new</span> ManagedList&lt;Object&gt;(nl.getLength());  </span><br><span class="line">       target.setSource(extractSource(collectionEle));  </span><br><span class="line">       <span class="comment">//设置集合目标数据类型  </span></span><br><span class="line">       target.setElementTypeName(defaultElementType);  </span><br><span class="line">       target.setMergeEnabled(parseMergeAttribute(collectionEle));  </span><br><span class="line">       <span class="comment">//具体的&lt;list&gt;元素解析  </span></span><br><span class="line">       parseCollectionElements(nl, target, bd, defaultElementType);  </span><br><span class="line">       <span class="keyword">return</span> target;  </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="comment">//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseCollectionElements</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String defaultElementType)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//遍历集合所有节点  </span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementNodes.getLength(); i++) &#123;  </span><br><span class="line">           Node node = elementNodes.item(i);  </span><br><span class="line">           <span class="comment">//节点不是description节点  </span></span><br><span class="line">           <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123;  </span><br><span class="line">               <span class="comment">//将解析的元素加入集合中，递归调用下一个子元素  </span></span><br><span class="line">               target.add(parsePropertySubElement((Element) node, bd, defaultElementType));  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过对Spring Bean定义资源文件转换的Document对象中的元素层层解析，Spring IoC现在已经将XML形式定义的Bean定义资源文件转换为Spring IoC所识别的数据结构——BeanDefinition，它是Bean定义资源文件中配置的POJO对象在Spring IoC容器中的映射，我们可以通过AbstractBeanDefinition为入口，荣IoC容器进行索引、查询和操作。</p>
<p>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IoC容器中BeanDefinition存储的只是一些静态信息，接下来需要向容器注册Bean定义信息才能全部完成IoC容器的初始化过程</p>
<h6 id="解析过后的BeanDefinition在IoC容器中的注册"><a href="#解析过后的BeanDefinition在IoC容器中的注册" class="headerlink" title="解析过后的BeanDefinition在IoC容器中的注册"></a>解析过后的BeanDefinition在IoC容器中的注册</h6><p>让我们继续跟踪程序的执行顺序，接下来会到我们第3步中分析DefaultBeanDefinitionDocumentReader对Bean定义转换的Document对象解析的流程中，在其parseDefaultElement方法中完成对Document对象的解析后得到封装BeanDefinition的BeanDefinitionHold对象，然后调用BeanDefinitionReaderUtils的registerBeanDefinition方法向IoC容器注册解析的Bean，BeanDefinitionReaderUtils的注册的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将解析的BeanDefinitionHold注册到容器中 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">        <span class="comment">//获取解析的BeanDefinition的名称</span></span><br><span class="line">         String beanName = definitionHolder.getBeanName();  </span><br><span class="line">        <span class="comment">//向IoC容器注册BeanDefinition </span></span><br><span class="line">        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());  </span><br><span class="line">        <span class="comment">//如果解析的BeanDefinition有别名，向容器为其注册别名  </span></span><br><span class="line">         String[] aliases = definitionHolder.getAliases();  </span><br><span class="line">        <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (String aliase : aliases) &#123;  </span><br><span class="line">                registry.registerAlias(beanName, aliase);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory。</p>
<h6 id="DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition"><a href="#DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition" class="headerlink" title="DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition"></a>DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition</h6><p>DefaultListableBeanFactory中使用一个HashMap的集合对象存放IoC容器中注册解析的BeanDefinition，向IoC容器注册的主要源码如下：<br><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/7.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储注册的俄BeanDefinition  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();  </span><br><span class="line">   <span class="comment">//向IoC容器注册解析的BeanDefiniton  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">       Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);  </span><br><span class="line">       Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);  </span><br><span class="line">       <span class="comment">//校验解析的BeanDefiniton  </span></span><br><span class="line">       <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               ((AbstractBeanDefinition) beanDefinition).validate();  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,  </span><br><span class="line">                       <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//注册的过程中需要线程同步，以保证数据的一致性  </span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;  </span><br><span class="line">           Object oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);  </span><br><span class="line">           <span class="comment">//检查是否有同名的BeanDefinition已经在IoC容器中注册，如果已经注册，  </span></span><br><span class="line">           <span class="comment">//并且不允许覆盖已注册的Bean，则抛出注册失败异常  </span></span><br><span class="line">           <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.allowBeanDefinitionOverriding) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,  </span><br><span class="line">                           <span class="string">&quot;Cannot register bean definition [&quot;</span> + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> + beanName +  </span><br><span class="line">                           <span class="string">&quot;&#x27;: There is already [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] bound.&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;<span class="comment">//如果允许覆盖，则同名的Bean，后注册的覆盖先注册的  </span></span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;  </span><br><span class="line">                       <span class="keyword">this</span>.logger.info(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +  </span><br><span class="line">                               <span class="string">&quot;&#x27;: replacing [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//IoC容器中没有已经注册同名的Bean，按正常注册流程注册  </span></span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="keyword">this</span>.beanDefinitionNames.add(beanName);  </span><br><span class="line">               <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);  </span><br><span class="line">           <span class="comment">//重置所有已经注册过的BeanDefinition的缓存  </span></span><br><span class="line">           resetBeanDefinition(beanName);  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现  在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>现在通过上面的代码，总结一下IOC容器初始化的基本步骤：</p>
<blockquote>
<ul>
<li><p>初始化的入口在容器实现中的 refresh()调用来完成</p>
</li>
<li><p>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,其中的大致过程如下：通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition  这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.</p>
</li>
<li><p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在ServletContext 中的框架实现。</p>
</li>
</ul>
</blockquote>
<p>在使用 Spring IOC 容器的时候我们还需要区别两个概念:</p>
<blockquote>
<p>Beanfactory 和 Factory bean，其中 BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext， XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。 FactoryBean 只是一个可以在 IOC而容器中被管理的一个 bean,是对各种处理过程和资源使用的抽象,Factory bean 在需要时产生另一个对象，而不返回 FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂,看成是SPRING 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读Spring IOC原理（三）</title>
    <url>/2018/05/10/java/spring/3/</url>
    <content><![CDATA[<h4 id="源码解读Spring-IOC原理（三）"><a href="#源码解读Spring-IOC原理（三）" class="headerlink" title="源码解读Spring IOC原理（三）"></a>源码解读Spring IOC原理（三）</h4><h5 id="IOC容器的依赖注入"><a href="#IOC容器的依赖注入" class="headerlink" title="IOC容器的依赖注入"></a>IOC容器的依赖注入</h5><h6 id="依赖注入发生的时间"><a href="#依赖注入发生的时间" class="headerlink" title="依赖注入发生的时间"></a>依赖注入发生的时间</h6><p>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入，依赖注入在以下两种情况发生：</p>
<blockquote>
<ul>
<li>用户第一次通过getBean方法向IoC容索要Bean时，IoC容器触发依赖注入。</li>
<li>当用户在Bean定义资源中为<Bean>元素配置了lazy-init属性，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入。</li>
</ul>
</blockquote>
<p>BeanFactory接口定义了Spring IoC容器的基本功能规范，是Spring IoC容器所应遵守的最底层和最基本的编程规范。BeanFactory接口中定义了几个getBean方法，就是用户向IoC容器索取管理的Bean的方法，我们通过分析其子类的具体实现，理解Spring IoC容器在用户索取Bean时如何完成依赖注入。</p>
<p><img src="http://zhouqi-blog.oss-cn-shenzhen.aliyuncs.com/img/spring/8.png?imageView2/2/w/600/h/600/q/75%7Cimageslim"></p>
<p>在BeanFactory中我们看到getBean（String…）函数，它的具体实现在AbstractBeanFactory中</p>
<span id="more"></span>

<h6 id="AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean"><a href="#AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean" class="headerlink" title="AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean"></a>AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean</h6><p>AbstractBeanFactory的getBean相关方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取IoC容器中指定名称的Bean  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></span><br><span class="line">       <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//获取IoC容器中指定名称和类型的Bean  </span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></span><br><span class="line">       <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//获取IoC容器中指定名称和参数的Bean  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></span><br><span class="line">       <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//获取IoC容器中指定名称、类型和参数的Bean  </span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">   <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></span><br><span class="line">       <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方  </span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">   <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖  </span></span><br><span class="line">       <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称  </span></span><br><span class="line">       <span class="keyword">final</span> String beanName = transformedBeanName(name);  </span><br><span class="line">       Object bean;  </span><br><span class="line">       <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整  </span></span><br><span class="line">       <span class="comment">//个IoC容器中只创建一次，不需要重复创建  </span></span><br><span class="line">       Object sharedInstance = getSingleton(beanName);  </span><br><span class="line">       <span class="comment">//IoC容器创建单态模式Bean实例对象  </span></span><br><span class="line">       <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">               <span class="comment">//如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回  </span></span><br><span class="line">               <span class="comment">//已经创建的Bean  </span></span><br><span class="line">               <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">                   logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +  </span><br><span class="line">                           <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理  </span></span><br><span class="line">           <span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是  </span></span><br><span class="line">           <span class="comment">//创建创建对象的工厂Bean，两者之间有区别  </span></span><br><span class="line">           bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;<span class="comment">//缓存没有正在创建的单态模式Bean  </span></span><br><span class="line">           <span class="comment">//缓存中已经有已经创建的原型模式Bean，但是由于循环引用的问题导致实  </span></span><br><span class="line">           <span class="comment">//例化对象失败  </span></span><br><span class="line">           <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//对IoC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否  </span></span><br><span class="line">           <span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器  </span></span><br><span class="line">           <span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找  </span></span><br><span class="line">           BeanFactory parentBeanFactory = getParentBeanFactory();  </span><br><span class="line">           <span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean  </span></span><br><span class="line">           <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">               <span class="comment">//解析指定Bean名称的原始名称  </span></span><br><span class="line">               String nameToLookup = originalBeanName(name);  </span><br><span class="line">               <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//委派父级容器根据指定名称和显式的参数查找  </span></span><br><span class="line">                   <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   <span class="comment">//委派父级容器根据指定名称和类型查找  </span></span><br><span class="line">                   <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//创建的Bean是否需要进行类型验证，一般不需要  </span></span><br><span class="line">           <span class="keyword">if</span> (!typeCheckOnly) &#123;  </span><br><span class="line">               <span class="comment">//向容器标记指定的Bean已经被创建  </span></span><br><span class="line">               markBeanAsCreated(beanName);  </span><br><span class="line">           &#125;  </span><br><span class="line">            <span class="comment">//根据指定Bean名称获取其父级的Bean定义，主要解决Bean继承时子类  </span></span><br><span class="line">           <span class="comment">//合并父类公共属性问题  </span></span><br><span class="line">           <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);  </span><br><span class="line">           checkMergedBeanDefinition(mbd, beanName, args);  </span><br><span class="line">           <span class="comment">//获取当前Bean所有依赖Bean的名称  </span></span><br><span class="line">           String[] dependsOn = mbd.getDependsOn();  </span><br><span class="line">           <span class="comment">//如果当前Bean有依赖Bean  </span></span><br><span class="line">           <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">for</span> (String dependsOnBean : dependsOn) &#123;  </span><br><span class="line">                   <span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean  </span></span><br><span class="line">                   getBean(dependsOnBean);  </span><br><span class="line">                   <span class="comment">//把被依赖Bean注册给当前依赖的Bean  </span></span><br><span class="line">                   registerDependentBean(dependsOnBean, beanName);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//创建单态模式Bean的实例对象  </span></span><br><span class="line">           <span class="keyword">if</span> (mbd.isSingleton()) &#123;  </span><br><span class="line">           <span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象  </span></span><br><span class="line">               sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">                       <span class="keyword">try</span> &#123;  </span><br><span class="line">                           <span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子//类和父类的定义  </span></span><br><span class="line">                           <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">                           <span class="comment">//显式地从容器单态模式Bean缓存中清除实例对象  </span></span><br><span class="line">                           destroySingleton(beanName);  </span><br><span class="line">                           <span class="keyword">throw</span> ex;  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;);  </span><br><span class="line">               <span class="comment">//获取给定Bean的实例对象  </span></span><br><span class="line">               bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//IoC容器创建原型模式Bean实例对象  </span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;  </span><br><span class="line">               <span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象  </span></span><br><span class="line">               Object prototypeInstance = <span class="keyword">null</span>;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创//建的原型对象  </span></span><br><span class="line">                   beforePrototypeCreation(beanName);  </span><br><span class="line">                   <span class="comment">//创建指定Bean对象实例  </span></span><br><span class="line">                   prototypeInstance = createBean(beanName, mbd, args);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">finally</span> &#123;  </span><br><span class="line">                   <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IoC容器指//定Bean的原型对象不再创建了  </span></span><br><span class="line">                   afterPrototypeCreation(beanName);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//获取给定Bean的实例对象  </span></span><br><span class="line">               bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中  </span></span><br><span class="line">           <span class="comment">//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中  </span></span><br><span class="line">           <span class="comment">//比较常用，如：request、session、application等生命周期  </span></span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               String scopeName = mbd.getScope();  </span><br><span class="line">               <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);  </span><br><span class="line">               <span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法  </span></span><br><span class="line">               <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例  </span></span><br><span class="line">                   Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                       <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">                           beforePrototypeCreation(beanName);  </span><br><span class="line">                           <span class="keyword">try</span> &#123;  </span><br><span class="line">                               <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                           &#125;  </span><br><span class="line">                           <span class="keyword">finally</span> &#123;  </span><br><span class="line">                               afterPrototypeCreation(beanName);  </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;);  </span><br><span class="line">                   <span class="comment">//获取给定Bean的实例对象  </span></span><br><span class="line">                   bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">catch</span> (IllegalStateException ex) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,  </span><br><span class="line">                           <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; &quot;</span> +  </span><br><span class="line">                           <span class="string">&quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,  </span><br><span class="line">                           ex);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对创建的Bean实例对象进行类型检查  </span></span><br><span class="line">       <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> (T) bean;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面对向IoC容器获取Bean方法的分析，我们可以看到在Spring中，如果Bean定义的单态模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean定义还可以扩展为指定其生命周期范围。</p>
<p>上面的源码只是定义了根据Bean定义的模式，采取的不同创建Bean实例对象的策略，具体的Bean实例对象的创建过程由实现了ObejctFactory接口的匿名内部类的createBean方法完成，ObejctFactory使用委派模式，具体的Bean实例创建过程交由其实现类AbstractAutowireCapableBeanFactory完成，我们继续分析AbstractAutowireCapableBeanFactory的createBean方法的源码，理解其创建Bean实例的具体实现过程。</p>
<h6 id="AbstractAutowireCapableBeanFactory创建Bean实例对象"><a href="#AbstractAutowireCapableBeanFactory创建Bean实例对象" class="headerlink" title="AbstractAutowireCapableBeanFactory创建Bean实例对象"></a>AbstractAutowireCapableBeanFactory创建Bean实例对象</h6><p>AbstractAutowireCapableBeanFactory类实现了ObejctFactory接口，创建容器指定的Bean实例对象，同时还对创建的Bean实例对象进行初始化处理。其创建Bean实例对象的方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Bean实例对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span>  </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeanCreationException </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">           logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载  </span></span><br><span class="line">       resolveBeanClass(mbd, beanName);  </span><br><span class="line">       <span class="comment">//校验和准备Bean中的方法覆盖  </span></span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           mbd.prepareMethodOverrides();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(),  </span><br><span class="line">                   beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           <span class="comment">//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建//Bean的代理对象  </span></span><br><span class="line">           Object bean = resolveBeforeInstantiation(beanName, mbd);  </span><br><span class="line">           <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">return</span> bean;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </span><br><span class="line">                   <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//创建Bean的入口  </span></span><br><span class="line">       Object beanInstance = doCreateBean(beanName, mbd, args);  </span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">           logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> beanInstance;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//真正创建Bean的方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//封装被创建的Bean对象  </span></span><br><span class="line">       BeanWrapper instanceWrapper = <span class="keyword">null</span>;  </span><br><span class="line">       <span class="keyword">if</span> (mbd.isSingleton())&#123;<span class="comment">//单态模式的Bean，先从容器中缓存中获取同名Bean  </span></span><br><span class="line">           instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//创建实例对象  </span></span><br><span class="line">           instanceWrapper = createBeanInstance(beanName, mbd, args);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);  </span><br><span class="line">       <span class="comment">//获取实例化对象的类型  </span></span><br><span class="line">       Class beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);  </span><br><span class="line">       <span class="comment">//调用PostProcessor后置处理器  </span></span><br><span class="line">       <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (!mbd.postProcessed) &#123;  </span><br><span class="line">               applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  </span><br><span class="line">               mbd.postProcessed = <span class="keyword">true</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">// Eagerly cache singletons to be able to resolve circular references  </span></span><br><span class="line">       <span class="comment">//向容器中缓存单态模式的Bean对象，以防循环引用  </span></span><br><span class="line">       <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;  </span><br><span class="line">               isSingletonCurrentlyInCreation(beanName));  </span><br><span class="line">       <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">               logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +  </span><br><span class="line">                       <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用  </span></span><br><span class="line">           addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">                   <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//Bean对象的初始化，依赖注入在此触发  </span></span><br><span class="line">       <span class="comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean  </span></span><br><span class="line">       Object exposedObject = bean;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           <span class="comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象  </span></span><br><span class="line">           populateBean(beanName, mbd, instanceWrapper);  </span><br><span class="line">           <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="comment">//初始化Bean对象  </span></span><br><span class="line">               exposedObject = initializeBean(beanName, exposedObject, mbd);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> (BeanCreationException) ex;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">           <span class="comment">//获取指定名称的已注册的单态模式Bean对象  </span></span><br><span class="line">           Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);  </span><br><span class="line">           <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="comment">//根据名称获取的以注册的Bean和正在实例化的Bean是同一个  </span></span><br><span class="line">               <span class="keyword">if</span> (exposedObject == bean) &#123;  </span><br><span class="line">                   <span class="comment">//当前实例化的Bean初始化完成  </span></span><br><span class="line">                   exposedObject = earlySingletonReference;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象  </span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;  </span><br><span class="line">                   String[] dependentBeans = getDependentBeans(beanName);  </span><br><span class="line">                   Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);  </span><br><span class="line">                   <span class="comment">//获取当前Bean所依赖的其他Bean  </span></span><br><span class="line">                   <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;  </span><br><span class="line">                       <span class="comment">//对依赖Bean进行类型检查  </span></span><br><span class="line">                       <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;  </span><br><span class="line">                           actualDependentBeans.add(dependentBean);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;  </span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,  </span><br><span class="line">                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +  </span><br><span class="line">                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +  </span><br><span class="line">                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +  </span><br><span class="line">                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +  </span><br><span class="line">                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +  </span><br><span class="line">                               <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//注册完成依赖注入的Bean  </span></span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           registerDisposableBeanIfNecessary(beanName, bean, mbd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> exposedObject;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中：</p>
<blockquote>
<ul>
<li>createBeanInstance：生成Bean所包含的java对象实例。</li>
<li>populateBean ：对Bean属性的依赖注入进行处理。</li>
</ul>
</blockquote>
<p>下面继续分析这两个方法的代码实现。</p>
<h6 id="createBeanInstance方法创建Bean的java实例对象"><a href="#createBeanInstance方法创建Bean的java实例对象" class="headerlink" title="createBeanInstance方法创建Bean的java实例对象"></a>createBeanInstance方法创建Bean的java实例对象</h6><p>在createBeanInstance方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装配特性生成java实例对象，创建对象的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Bean的实例对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//检查确认Bean是可实例化的  </span></span><br><span class="line">       Class beanClass = resolveBeanClass(mbd, beanName);  </span><br><span class="line">       <span class="comment">//使用工厂方法对Bean进行实例化  </span></span><br><span class="line">       <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </span><br><span class="line">                   <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;  </span><br><span class="line">           <span class="comment">//调用工厂方法实例化  </span></span><br><span class="line">           <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//使用容器的自动装配方法进行实例化  </span></span><br><span class="line">       <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;  </span><br><span class="line">       <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;  </span><br><span class="line">       <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   resolved = <span class="keyword">true</span>;  </span><br><span class="line">                   autowireNecessary = mbd.constructorArgumentsResolved;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (resolved) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (autowireNecessary) &#123;  </span><br><span class="line">               <span class="comment">//配置了自动装配属性，使用容器的自动装配实例化  </span></span><br><span class="line">               <span class="comment">//容器的自动装配是根据参数类型匹配Bean的构造方法  </span></span><br><span class="line">               <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="comment">//使用默认的无参构造方法实例化  </span></span><br><span class="line">               <span class="keyword">return</span> instantiateBean(beanName, mbd);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//使用Bean的构造方法进行实例化  </span></span><br><span class="line">       Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);  </span><br><span class="line">       <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||  </span><br><span class="line">               mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||  </span><br><span class="line">               mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;  </span><br><span class="line">           <span class="comment">//使用容器的自动装配特性，调用匹配的构造方法实例化  </span></span><br><span class="line">           <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//使用默认的无参构造方法实例化  </span></span><br><span class="line">       <span class="keyword">return</span> instantiateBean(beanName, mbd);  </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="comment">//使用默认的无参构造方法实例化Bean对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           Object beanInstance;  </span><br><span class="line">           <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;  </span><br><span class="line">           <span class="comment">//获取系统的安全管理接口，JDK标准的安全管理API  </span></span><br><span class="line">           <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="comment">//这里是一个匿名内置类，根据实例化策略创建实例对象  </span></span><br><span class="line">               beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                       <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;, getAccessControlContext());  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="comment">//将实例化的对象封装起来  </span></span><br><span class="line">               beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);  </span><br><span class="line">           &#125;  </span><br><span class="line">           BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);  </span><br><span class="line">           initBeanWrapper(bw);  </span><br><span class="line">           <span class="keyword">return</span> bw;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的Bean的实例化相当比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK的反射机制或者CGLIB)来进行初始化了，在方法getInstantiationStrategy().instantiate中就具体实现类使用初始策略实例化对象。</p>
<h6 id="SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象"><a href="#SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象" class="headerlink" title="SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象"></a>SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象</h6><p>在使用默认的无参构造方法创建Bean的实例化对象时，方法getInstantiationStrategy().instantiate调用了SimpleInstantiationStrategy类中的实例化Bean的方法，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用初始化策略实例化Bean对象  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法  </span></span><br><span class="line">       <span class="keyword">if</span> (beanDefinition.getMethodOverrides().isEmpty()) &#123;  </span><br><span class="line">           Constructor&lt;?&gt; constructorToUse;  </span><br><span class="line">           <span class="keyword">synchronized</span> (beanDefinition.constructorArgumentLock) &#123;  </span><br><span class="line">               <span class="comment">//获取对象的构造方法或工厂方法  </span></span><br><span class="line">               constructorToUse = (Constructor&lt;?&gt;) beanDefinition.resolvedConstructorOrFactoryMethod;  </span><br><span class="line">               <span class="comment">//如果没有构造方法且没有工厂方法  </span></span><br><span class="line">               <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//使用JDK的反射机制，判断要实例化的Bean是否是接口  </span></span><br><span class="line">                   <span class="keyword">final</span> Class clazz = beanDefinition.getBeanClass();  </span><br><span class="line">                   <span class="keyword">if</span> (clazz.isInterface()) &#123;  </span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">try</span> &#123;  </span><br><span class="line">                       <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                       <span class="comment">//这里是一个匿名内置类，使用反射机制获取Bean的构造方法  </span></span><br><span class="line">                           constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&gt;() &#123;  </span><br><span class="line">                               <span class="function"><span class="keyword">public</span> Constructor <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                                   <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                           &#125;);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       <span class="keyword">else</span> &#123;  </span><br><span class="line">                           constructorToUse =  clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化  </span></span><br><span class="line">           <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="comment">//使用CGLIB来实例化对象  </span></span><br><span class="line">           <span class="keyword">return</span> instantiateWithMethodInjection(beanDefinition, beanName, owner);  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码分析，我们看到了如果Bean有方法被覆盖了，则使用JDK的反射机制进行实例化，否则，使用CGLIB进行实例化。</p>
<p>instantiateWithMethodInjection方法调用SimpleInstantiationStrategy的子类CglibSubclassingInstantiationStrategy使用CGLIB来进行初始化，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用CGLIB进行Bean对象实例化  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(Constructor ctor, Object[] args)</span> </span>&#123;  </span><br><span class="line">           <span class="comment">//CGLIB中的类  </span></span><br><span class="line">           Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </span><br><span class="line">           <span class="comment">//将Bean本身作为其基类  </span></span><br><span class="line">           enhancer.setSuperclass(<span class="keyword">this</span>.beanDefinition.getBeanClass());  </span><br><span class="line">           enhancer.setCallbackFilter(<span class="keyword">new</span> CallbackFilterImpl());  </span><br><span class="line">           enhancer.setCallbacks(<span class="keyword">new</span> Callback[] &#123;  </span><br><span class="line">                   NoOp.INSTANCE,  </span><br><span class="line">                   <span class="keyword">new</span> LookupOverrideMethodInterceptor(),  </span><br><span class="line">                   <span class="keyword">new</span> ReplaceOverrideMethodInterceptor()  </span><br><span class="line">           &#125;);  </span><br><span class="line">           <span class="comment">//使用CGLIB的create方法生成实例对象  </span></span><br><span class="line">           <span class="keyword">return</span> (ctor == <span class="keyword">null</span>) ?   </span><br><span class="line">                   enhancer.create() :   </span><br><span class="line">                   enhancer.create(ctor.getParameterTypes(), args);  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>CGLIB是一个常用的字节码生成器的类库，它提供了一系列API实现java字节码的生成和转换功能。我们在学习JDK的动态代理时都知道，JDK的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用CGLIB。</p>
<h6 id="populateBean方法对Bean属性的依赖注入"><a href="#populateBean方法对Bean属性的依赖注入" class="headerlink" title="populateBean方法对Bean属性的依赖注入"></a>populateBean方法对Bean属性的依赖注入</h6><p>在第3步的分析中我们已经了解到Bean的依赖注入分为以下两个过程：</p>
<blockquote>
<ul>
<li>createBeanInstance：生成Bean所包含的java对象实例</li>
<li>populateBean ：对Bean属性的依赖注入进行处理</li>
</ul>
</blockquote>
<p>第4、5步中我们已经分析了容器初始化生成Bean所包含的Java实例对象的过程，现在我们继续分析生成对象后，Spring IoC容器是如何将Bean的属性依赖关系注入Bean实例对象中并设置好的，属性依赖注入的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将Bean属性设置到生成的实例对象上  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值  </span></span><br><span class="line">       PropertyValues pvs = mbd.getPropertyValues();  </span><br><span class="line">       <span class="comment">//实例对象为null  </span></span><br><span class="line">       <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//属性值不为空  </span></span><br><span class="line">           <span class="keyword">if</span> (!pvs.isEmpty()) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                       mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="comment">//实例对象为null，属性值也为空，不需要设置属性值，直接返回  </span></span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//在设置属性之前调用Bean的PostProcessor后置处理器  </span></span><br><span class="line">       <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;  </span><br><span class="line">       <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;  </span><br><span class="line">           <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;  </span><br><span class="line">                   InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;  </span><br><span class="line">                   <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;  </span><br><span class="line">                       continueWithPropertyPopulation = <span class="keyword">false</span>;  </span><br><span class="line">                       <span class="keyword">break</span>;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;  </span><br><span class="line">           <span class="keyword">return</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//依赖注入开始，首先处理autowire自动装配的注入  </span></span><br><span class="line">       <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </span><br><span class="line">               mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">           MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);  </span><br><span class="line">           <span class="comment">//对autowire自动装配的处理，根据Bean名称自动装配注入  </span></span><br><span class="line">           <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </span><br><span class="line">               autowireByName(beanName, mbd, bw, newPvs);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//根据Bean类型自动装配注入  </span></span><br><span class="line">           <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">               autowireByType(beanName, mbd, bw, newPvs);  </span><br><span class="line">           &#125;  </span><br><span class="line">           pvs = newPvs;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//检查容器是否持有用于处理单态模式Bean关闭时的后置处理器  </span></span><br><span class="line">       <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();  </span><br><span class="line">       <span class="comment">//Bean实例对象没有依赖，即没有继承基类  </span></span><br><span class="line">       <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);  </span><br><span class="line">       <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;  </span><br><span class="line">           <span class="comment">//从实例对象中提取属性描述符  </span></span><br><span class="line">           PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw);  </span><br><span class="line">           <span class="keyword">if</span> (hasInstAwareBpps) &#123;  </span><br><span class="line">               <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </span><br><span class="line">                   <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;  </span><br><span class="line">                       InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;  </span><br><span class="line">                       <span class="comment">//使用BeanPostProcessor处理器处理属性值  </span></span><br><span class="line">                       pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);  </span><br><span class="line">                       <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                           <span class="keyword">return</span>;  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">if</span> (needsDepCheck) &#123;  </span><br><span class="line">               <span class="comment">//为要设置的属性进行依赖检查  </span></span><br><span class="line">               checkDependencies(beanName, mbd, filteredPds, pvs);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对属性进行注入  </span></span><br><span class="line">       applyPropertyValues(beanName, mbd, bw, pvs);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析并注入依赖属性的过程  </span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;  </span><br><span class="line">           <span class="keyword">return</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//封装属性值  </span></span><br><span class="line">       MutablePropertyValues mpvs = <span class="keyword">null</span>;  </span><br><span class="line">       List&lt;PropertyValue&gt; original;  </span><br><span class="line">       <span class="keyword">if</span> (System.getSecurityManager()!= <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;  </span><br><span class="line">               <span class="comment">//设置安全上下文，JDK安全机制  </span></span><br><span class="line">               ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;  </span><br><span class="line">           mpvs = (MutablePropertyValues) pvs;  </span><br><span class="line">           <span class="comment">//属性值已经转换  </span></span><br><span class="line">           <span class="keyword">if</span> (mpvs.isConverted()) &#123;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="comment">//为实例化对象设置属性值  </span></span><br><span class="line">                   bw.setPropertyValues(mpvs);  </span><br><span class="line">                   <span class="keyword">return</span>;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                           mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//获取属性值对象的原始类型值  </span></span><br><span class="line">           original = mpvs.getPropertyValueList();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           original = Arrays.asList(pvs.getPropertyValues());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//获取用户自定义的类型转换  </span></span><br><span class="line">       TypeConverter converter = getCustomTypeConverter();  </span><br><span class="line">       <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           converter = bw;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象  </span></span><br><span class="line">       <span class="comment">//的实际值  </span></span><br><span class="line">       BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);  </span><br><span class="line">       <span class="comment">//为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中  </span></span><br><span class="line">       List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());  </span><br><span class="line">       <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;  </span><br><span class="line">       <span class="keyword">for</span> (PropertyValue pv : original) &#123;  </span><br><span class="line">           <span class="comment">//属性值不需要转换  </span></span><br><span class="line">           <span class="keyword">if</span> (pv.isConverted()) &#123;  </span><br><span class="line">               deepCopy.add(pv);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//属性值需要转换  </span></span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               String propertyName = pv.getName();  </span><br><span class="line">               <span class="comment">//原始的属性值，即转换之前的属性值  </span></span><br><span class="line">               Object originalValue = pv.getValue();  </span><br><span class="line">               <span class="comment">//转换属性值，例如将引用转换为IoC容器中实例化对象引用  </span></span><br><span class="line">               Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);  </span><br><span class="line">               <span class="comment">//转换之后的属性值  </span></span><br><span class="line">               Object convertedValue = resolvedValue;  </span><br><span class="line">               <span class="comment">//属性值是否可以转换  </span></span><br><span class="line">               <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;  </span><br><span class="line">                       !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);  </span><br><span class="line">               <span class="keyword">if</span> (convertible) &#123;  </span><br><span class="line">                   <span class="comment">//使用用户自定义的类型转换器转换属性值  </span></span><br><span class="line">                   convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//存储转换后的属性值，避免每次属性注入时的转换工作  </span></span><br><span class="line">               <span class="keyword">if</span> (resolvedValue == originalValue) &#123;  </span><br><span class="line">                   <span class="keyword">if</span> (convertible) &#123;  </span><br><span class="line">                       <span class="comment">//设置属性转换之后的值  </span></span><br><span class="line">                       pv.setConvertedValue(convertedValue);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   deepCopy.add(pv);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是  </span></span><br><span class="line">               <span class="comment">//动态生成的字符串，且属性的原始值不是集合或者数组类型  </span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;  </span><br><span class="line">                       !((TypedStringValue) originalValue).isDynamic() &amp;&amp;  </span><br><span class="line">                       !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;  </span><br><span class="line">                   pv.setConvertedValue(convertedValue);  </span><br><span class="line">                   deepCopy.add(pv);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   resolveNecessary = <span class="keyword">true</span>;  </span><br><span class="line">                   <span class="comment">//重新封装属性的值  </span></span><br><span class="line">                   deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;  </span><br><span class="line">           <span class="comment">//标记属性值已经转换过  </span></span><br><span class="line">           mpvs.setConverted();  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//进行属性依赖注入  </span></span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                   mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况：</p>
<blockquote>
<ul>
<li>属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入。</li>
<li>属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。</li>
</ul>
</blockquote>
<p>对属性值的解析是在BeanDefinitionValueResolver类中的resolveValueIfNecessary方法中进行的，对属性值的依赖注入是通过bw.setPropertyValues方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程。</p>
<h6 id="BeanDefinitionValueResolver解析属性值"><a href="#BeanDefinitionValueResolver解析属性值" class="headerlink" title="BeanDefinitionValueResolver解析属性值"></a>BeanDefinitionValueResolver解析属性值</h6><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由resolveValueIfNecessary方法实现，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析属性值，对注入类型进行转换  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//对引用类型的属性进行解析  </span></span><br><span class="line">       <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;  </span><br><span class="line">           RuntimeBeanReference ref = (RuntimeBeanReference) value;  </span><br><span class="line">           <span class="comment">//调用引用类型属性的解析方法  </span></span><br><span class="line">           <span class="keyword">return</span> resolveReference(argName, ref);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对属性值是引用容器中另一个Bean名称的解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanNameReference) &#123;  </span><br><span class="line">           String refName = ((RuntimeBeanNameReference) value).getBeanName();  </span><br><span class="line">           refName = String.valueOf(evaluate(refName));  </span><br><span class="line">           <span class="comment">//从容器中获取指定名称的Bean  </span></span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.containsBean(refName)) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(  </span><br><span class="line">                       <span class="string">&quot;Invalid bean name &#x27;&quot;</span> + refName + <span class="string">&quot;&#x27; in bean reference for &quot;</span> + argName);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> refName;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对Bean类型属性的解析，主要是Bean中的内部类  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinitionHolder) &#123;  </span><br><span class="line">           BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;  </span><br><span class="line">           <span class="keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinition) &#123;  </span><br><span class="line">           BeanDefinition bd = (BeanDefinition) value;  </span><br><span class="line">           <span class="keyword">return</span> resolveInnerBean(argName, <span class="string">&quot;(inner bean)&quot;</span>, bd);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对集合数组类型的属性解析  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedArray) &#123;  </span><br><span class="line">           ManagedArray array = (ManagedArray) value;  </span><br><span class="line">           <span class="comment">//获取数组的类型  </span></span><br><span class="line">           Class elementType = array.resolvedElementType;  </span><br><span class="line">           <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="comment">//获取数组元素的类型  </span></span><br><span class="line">               String elementTypeName = array.getElementTypeName();  </span><br><span class="line">               <span class="keyword">if</span> (StringUtils.hasText(elementTypeName)) &#123;  </span><br><span class="line">                   <span class="keyword">try</span> &#123;  </span><br><span class="line">                       <span class="comment">//使用反射机制创建指定类型的对象  </span></span><br><span class="line">                       elementType = ClassUtils.forName(elementTypeName, <span class="keyword">this</span>.beanFactory.getBeanClassLoader());  </span><br><span class="line">                       array.resolvedElementType = elementType;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                               <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </span><br><span class="line">                               <span class="string">&quot;Error resolving array type for &quot;</span> + argName, ex);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//没有获取到数组的类型，也没有获取到数组元素的类型，则直接设置数  </span></span><br><span class="line">               <span class="comment">//组的类型为Object  </span></span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   elementType = Object.class;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//创建指定类型的数组  </span></span><br><span class="line">           <span class="keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//解析list类型的属性值  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedList) &#123;  </span><br><span class="line">           <span class="keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//解析set类型的属性值  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedSet) &#123;  </span><br><span class="line">           <span class="keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//解析map类型的属性值  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedMap) &#123;  </span><br><span class="line">           <span class="keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//解析props类型的属性值，props其实就是key和value均为字符串的map  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedProperties) &#123;  </span><br><span class="line">           Properties original = (Properties) value;  </span><br><span class="line">           <span class="comment">//创建一个拷贝，用于作为解析后的返回值  </span></span><br><span class="line">           Properties copy = <span class="keyword">new</span> Properties();  </span><br><span class="line">           <span class="keyword">for</span> (Map.Entry propEntry : original.entrySet()) &#123;  </span><br><span class="line">               Object propKey = propEntry.getKey();  </span><br><span class="line">               Object propValue = propEntry.getValue();  </span><br><span class="line">               <span class="keyword">if</span> (propKey <span class="keyword">instanceof</span> TypedStringValue) &#123;  </span><br><span class="line">                   propKey = evaluate((TypedStringValue) propKey);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> TypedStringValue) &#123;  </span><br><span class="line">                   propValue = evaluate((TypedStringValue) propValue);  </span><br><span class="line">               &#125;  </span><br><span class="line">               copy.put(propKey, propValue);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> copy;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//解析字符串类型的属性值  </span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TypedStringValue) &#123;  </span><br><span class="line">           TypedStringValue typedStringValue = (TypedStringValue) value;  </span><br><span class="line">           Object valueObject = evaluate(typedStringValue);  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//获取属性的目标类型  </span></span><br><span class="line">               Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);  </span><br><span class="line">               <span class="keyword">if</span> (resolvedTargetType != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//对目标类型的属性进行解析，递归调用  </span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//没有获取到属性的目标对象，则按Object类型返回  </span></span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   <span class="keyword">return</span> valueObject;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                       <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </span><br><span class="line">                       <span class="string">&quot;Error converting typed String value for &quot;</span> + argName, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="keyword">return</span> evaluate(value);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析引用类型的属性值  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           <span class="comment">//获取引用的Bean名称  </span></span><br><span class="line">           String refName = ref.getBeanName();  </span><br><span class="line">           refName = String.valueOf(evaluate(refName));  </span><br><span class="line">           <span class="comment">//如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象  </span></span><br><span class="line">           <span class="keyword">if</span> (ref.isToParent()) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                           <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </span><br><span class="line">                           <span class="string">&quot;Can&#x27;t resolve reference to bean &#x27;&quot;</span> + refName +  </span><br><span class="line">                           <span class="string">&quot;&#x27; in parent factory: no parent factory available&quot;</span>);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化  </span></span><br><span class="line">           <span class="comment">//则会递归触发引用Bean的初始化和依赖注入  </span></span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               Object bean = <span class="keyword">this</span>.beanFactory.getBean(refName);  </span><br><span class="line">               <span class="comment">//将当前实例化对象的依赖引用对象  </span></span><br><span class="line">               <span class="keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="keyword">this</span>.beanName);  </span><br><span class="line">               <span class="keyword">return</span> bean;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                   <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </span><br><span class="line">                   <span class="string">&quot;Cannot resolve reference to bean &#x27;&quot;</span> + ref.getBeanName() + <span class="string">&quot;&#x27; while setting &quot;</span> + argName, ex);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="comment">//解析array类型的属性  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">resolveManagedArray</span><span class="params">(Object argName, List&lt;?&gt; ml, Class elementType)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">//创建一个指定类型的数组，用于存放和返回解析后的数组  </span></span><br><span class="line">       Object resolved = Array.newInstance(elementType, ml.size());  </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;  </span><br><span class="line">       <span class="comment">//递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i  </span></span><br><span class="line">           Array.set(resolved, i,  </span><br><span class="line">               resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), ml.get(i)));  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> resolved;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析list类型的属性  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List <span class="title">resolveManagedList</span><span class="params">(Object argName, List&lt;?&gt; ml)</span> </span>&#123;  </span><br><span class="line">       List&lt;Object&gt; resolved = <span class="keyword">new</span> ArrayList&lt;Object&gt;(ml.size());  </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;  </span><br><span class="line">           <span class="comment">//递归解析list的每一个元素  </span></span><br><span class="line">           resolved.add(  </span><br><span class="line">               resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), ml.get(i)));  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> resolved;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析set类型的属性  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Set <span class="title">resolveManagedSet</span><span class="params">(Object argName, Set&lt;?&gt; ms)</span> </span>&#123;  </span><br><span class="line">       Set&lt;Object&gt; resolved = <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(ms.size());  </span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">       <span class="comment">//递归解析set的每一个元素  </span></span><br><span class="line">       <span class="keyword">for</span> (Object m : ms) &#123;  </span><br><span class="line">           resolved.add(resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), m));  </span><br><span class="line">           i++;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> resolved;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//解析map类型的属性  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Map <span class="title">resolveManagedMap</span><span class="params">(Object argName, Map&lt;?, ?&gt; mm)</span> </span>&#123;  </span><br><span class="line">       Map&lt;Object, Object&gt; resolved = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(mm.size());  </span><br><span class="line">       <span class="comment">//递归解析map中每一个元素的key和value  </span></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry entry : mm.entrySet()) &#123;  </span><br><span class="line">           Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());  </span><br><span class="line">           Object resolvedValue = resolveValueIfNecessary(  </span><br><span class="line">                   <span class="keyword">new</span> KeyedArgName(argName, entry.getKey()), entry.getValue());  </span><br><span class="line">           resolved.put(resolvedKey, resolvedValue);  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> resolved;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码分析，我们明白了Spring是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是Bean对象实例设置到它所依赖的Bean对象属性上去，在第7步中我们已经说过，依赖注入是通过bw.setPropertyValues方法实现的，该方法也使用了委托模式，在BeanWrapper接口中至少定义了方法声明，依赖注入的具体实现交由其实现类BeanWrapperImpl来完成，下面我们就分析依BeanWrapperImpl中赖注入相关的源码。</p>
<h6 id="BeanWrapperImpl对Bean属性的依赖注入"><a href="#BeanWrapperImpl对Bean属性的依赖注入" class="headerlink" title="BeanWrapperImpl对Bean属性的依赖注入"></a>BeanWrapperImpl对Bean属性的依赖注入</h6><p>BeanWrapperImpl类主要是对容器中完成初始化的Bean实例对象进行属性的依赖注入，即把Bean对象设置到它所依赖的另一个Bean的属性中去，依赖注入的相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现属性依赖注入功能  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">       <span class="comment">//PropertyTokenHolder主要保存属性的名称、路径，以及集合的size等信息  </span></span><br><span class="line">       String propertyName = tokens.canonicalName;  </span><br><span class="line">       String actualName = tokens.actualName;  </span><br><span class="line">       <span class="comment">//keys是用来保存集合类型属性的size  </span></span><br><span class="line">       <span class="keyword">if</span> (tokens.keys != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           <span class="comment">//将属性信息拷贝  </span></span><br><span class="line">           PropertyTokenHolder getterTokens = <span class="keyword">new</span> PropertyTokenHolder();  </span><br><span class="line">           getterTokens.canonicalName = tokens.canonicalName;  </span><br><span class="line">           getterTokens.actualName = tokens.actualName;  </span><br><span class="line">           getterTokens.keys = <span class="keyword">new</span> String[tokens.keys.length - <span class="number">1</span>];  </span><br><span class="line">           System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);  </span><br><span class="line">           Object propValue;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               <span class="comment">//获取属性值，该方法内部使用JDK的内省( Introspector)机制，调用属性//的getter(readerMethod)方法，获取属性的值  </span></span><br><span class="line">               propValue = getPropertyValue(getterTokens);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </span><br><span class="line">                       <span class="string">&quot;Cannot access indexed value in property referenced &quot;</span> +  </span><br><span class="line">                       <span class="string">&quot;in indexed property path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//获取集合类型属性的长度  </span></span><br><span class="line">           String key = tokens.keys[tokens.keys.length - <span class="number">1</span>];  </span><br><span class="line">           <span class="keyword">if</span> (propValue == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NullValueInNestedPathException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </span><br><span class="line">                       <span class="string">&quot;Cannot access indexed value in property referenced &quot;</span> +  </span><br><span class="line">                       <span class="string">&quot;in indexed property path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;: returned null&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//注入array类型的属性值  </span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (propValue.getClass().isArray()) &#123;  </span><br><span class="line">               <span class="comment">//获取属性的描述符  </span></span><br><span class="line">               PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </span><br><span class="line">               <span class="comment">//获取数组的类型  </span></span><br><span class="line">               Class requiredType = propValue.getClass().getComponentType();  </span><br><span class="line">               <span class="comment">//获取数组的长度  </span></span><br><span class="line">               <span class="keyword">int</span> arrayIndex = Integer.parseInt(key);  </span><br><span class="line">               Object oldValue = <span class="keyword">null</span>;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                   <span class="comment">//获取数组以前初始化的值  </span></span><br><span class="line">                   <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;  </span><br><span class="line">                       oldValue = Array.get(propValue, arrayIndex);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="comment">//将属性的值赋值给数组中的元素  </span></span><br><span class="line">                   Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,  </span><br><span class="line">                           <span class="keyword">new</span> PropertyTypeDescriptor(pd, <span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>), requiredType));  </span><br><span class="line">                   Array.set(propValue, arrayIndex, convertedValue);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </span><br><span class="line">                           <span class="string">&quot;Invalid array index in property path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ex);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//注入list类型的属性值  </span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;  </span><br><span class="line">               PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </span><br><span class="line">               <span class="comment">//获取list集合的类型  </span></span><br><span class="line">               Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(  </span><br><span class="line">                       pd.getReadMethod(), tokens.keys.length);  </span><br><span class="line">               List list = (List) propValue;  </span><br><span class="line">               <span class="comment">//获取list集合的size  </span></span><br><span class="line">               <span class="keyword">int</span> index = Integer.parseInt(key);  </span><br><span class="line">               Object oldValue = <span class="keyword">null</span>;  </span><br><span class="line">               <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;  </span><br><span class="line">                   oldValue = list.get(index);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//获取list解析后的属性值  </span></span><br><span class="line">               Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,  </span><br><span class="line">                       <span class="keyword">new</span> PropertyTypeDescriptor(pd, <span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>), requiredType));  </span><br><span class="line">               <span class="keyword">if</span> (index &lt; list.size()) &#123;  </span><br><span class="line">                   <span class="comment">//为list属性赋值  </span></span><br><span class="line">                   list.set(index, convertedValue);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//如果list的长度大于属性值的长度，则多余的元素赋值为null  </span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= list.size()) &#123;  </span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size(); i &lt; index; i++) &#123;  </span><br><span class="line">                       <span class="keyword">try</span> &#123;  </span><br><span class="line">                           list.add(<span class="keyword">null</span>);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       <span class="keyword">catch</span> (NullPointerException ex) &#123;  </span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </span><br><span class="line">                                   <span class="string">&quot;Cannot set element with index &quot;</span> + index + <span class="string">&quot; in List of size &quot;</span> +  </span><br><span class="line">                                   list.size() + <span class="string">&quot;, accessed using property path &#x27;&quot;</span> + propertyName +  </span><br><span class="line">                                   <span class="string">&quot;&#x27;: List does not support filling up gaps with null elements&quot;</span>);  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   list.add(convertedValue);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="comment">//注入map类型的属性值  </span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;  </span><br><span class="line">               PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </span><br><span class="line">               <span class="comment">//获取map集合key的类型  </span></span><br><span class="line">               Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(  </span><br><span class="line">                       pd.getReadMethod(), tokens.keys.length);  </span><br><span class="line">               <span class="comment">//获取map集合value的类型  </span></span><br><span class="line">               Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(  </span><br><span class="line">                       pd.getReadMethod(), tokens.keys.length);  </span><br><span class="line">               Map map = (Map) propValue;  </span><br><span class="line">               <span class="comment">//解析map类型属性key值  </span></span><br><span class="line">               Object convertedMapKey = convertIfNecessary(<span class="keyword">null</span>, <span class="keyword">null</span>, key, mapKeyType,  </span><br><span class="line">                       <span class="keyword">new</span> PropertyTypeDescriptor(pd, <span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>), mapKeyType));  </span><br><span class="line">               Object oldValue = <span class="keyword">null</span>;  </span><br><span class="line">               <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;  </span><br><span class="line">                   oldValue = map.get(convertedMapKey);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//解析map类型属性value值  </span></span><br><span class="line">               Object convertedMapValue = convertIfNecessary(  </span><br><span class="line">                       propertyName, oldValue, pv.getValue(), mapValueType,  </span><br><span class="line">                       <span class="keyword">new</span> TypeDescriptor(<span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>, tokens.keys.length + <span class="number">1</span>)));  </span><br><span class="line">               <span class="comment">//将解析后的key和value值赋值给map集合属性  </span></span><br><span class="line">               map.put(convertedMapKey, convertedMapValue);  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </span><br><span class="line">                       <span class="string">&quot;Property referenced in indexed property path &#x27;&quot;</span> + propertyName +  </span><br><span class="line">                       <span class="string">&quot;&#x27; is neither an array nor a List nor a Map; returned value was [&quot;</span> + pv.getValue() + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">//对非集合类型的属性注入  </span></span><br><span class="line">       <span class="keyword">else</span> &#123;  </span><br><span class="line">           PropertyDescriptor pd = pv.resolvedDescriptor;  </span><br><span class="line">           <span class="keyword">if</span> (pd == <span class="keyword">null</span> || !pd.getWriteMethod().getDeclaringClass().isInstance(<span class="keyword">this</span>.object)) &#123;  </span><br><span class="line">               pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </span><br><span class="line">               <span class="comment">//无法获取到属性名或者属性没有提供setter(写方法)方法  </span></span><br><span class="line">               <span class="keyword">if</span> (pd == <span class="keyword">null</span> || pd.getWriteMethod() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//如果属性值是可选的，即不是必须的，则忽略该属性值  </span></span><br><span class="line">                   <span class="keyword">if</span> (pv.isOptional()) &#123;  </span><br><span class="line">                       logger.debug(<span class="string">&quot;Ignoring optional value for property &#x27;&quot;</span> + actualName +  </span><br><span class="line">                               <span class="string">&quot;&#x27; - property not found on bean class [&quot;</span> + getRootClass().getName() + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">                       <span class="keyword">return</span>;  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="comment">//如果属性值是必须的，则抛出无法给属性赋值，因为每天提供setter方法异常  </span></span><br><span class="line">                   <span class="keyword">else</span> &#123;  </span><br><span class="line">                       PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());  </span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(  </span><br><span class="line">                               getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </span><br><span class="line">                               matches.buildErrorMessage(), matches.getPossibleMatches());  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               pv.getOriginalPropertyValue().resolvedDescriptor = pd;  </span><br><span class="line">           &#125;  </span><br><span class="line">           Object oldValue = <span class="keyword">null</span>;  </span><br><span class="line">           <span class="keyword">try</span> &#123;  </span><br><span class="line">               Object originalValue = pv.getValue();  </span><br><span class="line">               Object valueToApply = originalValue;  </span><br><span class="line">               <span class="keyword">if</span> (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;  </span><br><span class="line">                   <span class="keyword">if</span> (pv.isConverted()) &#123;  </span><br><span class="line">                       valueToApply = pv.getConvertedValue();  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">else</span> &#123;  </span><br><span class="line">                       <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                           <span class="comment">//获取属性的getter方法(读方法)，JDK内省机制  </span></span><br><span class="line">                           <span class="keyword">final</span> Method readMethod = pd.getReadMethod();  </span><br><span class="line">                           <span class="comment">//如果属性的getter方法不是public访问控制权限的，即访问控制权限比较严格，  </span></span><br><span class="line">                           <span class="comment">//则使用JDK的反射机制强行访问非public的方法(暴力读取属性值)  </span></span><br><span class="line">                           <span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp;  </span><br><span class="line">                                   !readMethod.isAccessible()) &#123;  </span><br><span class="line">                               <span class="keyword">if</span> (System.getSecurityManager()!= <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                   <span class="comment">//匿名内部类，根据权限修改属性的读取控制限制  </span></span><br><span class="line">                                   AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                                       <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                                           readMethod.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">                                           <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                                       &#125;  </span><br><span class="line">                                   &#125;);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                               <span class="keyword">else</span> &#123;  </span><br><span class="line">                                   readMethod.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                           &#125;  </span><br><span class="line">                           <span class="keyword">try</span> &#123;  </span><br><span class="line">                               <span class="comment">//属性没有提供getter方法时，调用潜在的读取属性值//的方法，获取属性值  </span></span><br><span class="line">                               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                   oldValue = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;  </span><br><span class="line">                                       <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                                           <span class="keyword">return</span> readMethod.invoke(object);  </span><br><span class="line">                                       &#125;  </span><br><span class="line">                                   &#125;, acc);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                               <span class="keyword">else</span> &#123;  </span><br><span class="line">                                   oldValue = readMethod.invoke(object);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                           &#125;  </span><br><span class="line">                           <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                               <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> PrivilegedActionException) &#123;  </span><br><span class="line">                                   ex = ((PrivilegedActionException) ex).getException();  </span><br><span class="line">                               &#125;  </span><br><span class="line">                               <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                                   logger.debug(<span class="string">&quot;Could not read previous value of property &#x27;&quot;</span> +  </span><br><span class="line">                                           <span class="keyword">this</span>.nestedPath + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ex);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;  </span><br><span class="line">                       <span class="comment">//设置属性的注入值  </span></span><br><span class="line">                       valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="comment">//根据JDK的内省机制，获取属性的setter(写方法)方法  </span></span><br><span class="line">               <span class="keyword">final</span> Method writeMethod = (pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?  </span><br><span class="line">                       ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :  </span><br><span class="line">                       pd.getWriteMethod());  </span><br><span class="line">               <span class="comment">//如果属性的setter方法是非public，即访问控制权限比较严格，则使用JDK的反射机制，  </span></span><br><span class="line">               <span class="comment">//强行设置setter方法可访问(暴力为属性赋值)  </span></span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) &#123;  </span><br><span class="line">                   <span class="comment">//如果使用了JDK的安全机制，则需要权限验证  </span></span><br><span class="line">                   <span class="keyword">if</span> (System.getSecurityManager()!= <span class="keyword">null</span>) &#123;  </span><br><span class="line">                       AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                           <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                               writeMethod.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">                               <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">else</span> &#123;  </span><br><span class="line">                       writeMethod.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">final</span> Object value = valueToApply;  </span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   <span class="keyword">try</span> &#123;  </span><br><span class="line">                       <span class="comment">//将属性值设置到属性上去  </span></span><br><span class="line">                       AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;  </span><br><span class="line">                           <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                               writeMethod.invoke(object, value);  </span><br><span class="line">                               <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;, acc);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;  </span><br><span class="line">                       <span class="keyword">throw</span> ex.getException();  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   writeMethod.invoke(<span class="keyword">this</span>.object, value);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (TypeMismatchException ex) &#123;  </span><br><span class="line">               <span class="keyword">throw</span> ex;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (InvocationTargetException ex) &#123;  </span><br><span class="line">               PropertyChangeEvent propertyChangeEvent =  </span><br><span class="line">                       <span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>.rootObject, <span class="keyword">this</span>.nestedPath + propertyName, oldValue, pv.getValue());  </span><br><span class="line">               <span class="keyword">if</span> (ex.getTargetException() <span class="keyword">instanceof</span> ClassCastException) &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">else</span> &#123;  </span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> MethodInvocationException(propertyChangeEvent, ex.getTargetException());  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">               PropertyChangeEvent pce =  </span><br><span class="line">                       <span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>.rootObject, <span class="keyword">this</span>.nestedPath + propertyName, oldValue, pv.getValue());  </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> MethodInvocationException(pce, ex);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过对上面注入依赖代码的分析，我们已经明白了Spring IoC容器是如何将属性的值注入到Bean实例对象中去的：</p>
<blockquote>
<ul>
<li>对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</li>
<li>对于非集合类型的属性，大量使用了JDK的反射和内省机制，通过属性的getter方法(reader method)获取指定属性注入以前的值，同时调用属性的setter方法(writer method)为属性设置注入后的值。看到这里相信很多人都明白了Spring的setter注入原理。</li>
</ul>
</blockquote>
<p>至此Spring IoC容器对Bean定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在Spring IoC容器中管理了一系列靠依赖关系联系起来的Bean，程序不需要应用自己手动创建所需的对象，Spring IoC容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是Spring核心功能的控制反转和依赖注入的相关功能。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
