<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[适配器模式之对象适配器]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2Fdesign-pattern-1%2F</url>
    <content type="text"><![CDATA[问题导入：比如有A型螺母和B型螺母，那么用户可以再A型螺母上直接使用按着A型螺母生产的A型螺丝，同样也可以在B型螺母上直接使用按着B型螺母标准生产的B型螺丝。但是由于A型螺母和B型螺母的标准不一样，用户在A型螺母上不能直接使用B型的螺丝，反之也一样。该如何达到这个目的呢？ 使用适配器就可以解决这个问题：生产一种“A型螺母适配器”，这种A型螺母适配器的前端符合A型螺母标准要求，可以拧在A型螺母上，后端又焊接了一个B型螺母。这样用户就可以借助A型螺母适配器在A型螺母上使用B型的螺丝了。 适配器模式又称为包装器，是用来将一个类的接口转换成客户希望的另外一个接口。这可以使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式的关键是建立一个适配器，这个适配器实现了目标接口并且包含了被适配者的引用。 适配器模式的三种角色： 目标：目标是一个接口，该接口是客户想要使用的接口。 被适配者：被适配者是一个已经存在的接口或抽象类，这个接口接口或者抽象类需要适配。 适配器：适配器是一个类，该类实现了目标接口并且包含有被适配者的引用，即适配器的职责是对适配者接口或抽象类与目标接口进行适配。 以下通过一个简单的问题来描述适配器模式中所涉及的各个角色。 实例用户已经有一个两厢的插座，但是最近用户又有了一个新的三厢插座。用户现有一台洗衣机和一台电视机，洗衣机是三厢插头，而电视机是两厢插头。现在用户想用心的三厢插座来使用洗衣机和电视机，即用心的三厢插座为洗衣机和电视机接通电流。 针对以上问题，使用适配器模式设计若干个类。 目标 本问题是使用三厢插座来为电视机和洗衣机接通电流，所以目标是三厢插座。把三厢插座设置为一个接口： 123456package com.adatpe;//适配目标：三相插座public interface ThreeElectricOutlet &#123; void connectElectricCurrent();&#125; 被适配者 对于本问题，用户是想要用三厢插座为两厢插头的电视机接通电流，所以被适配者应该是两厢插座，也设置为一个接口： 123456package com.adatpe;//被适配者：两相插座public interface TwoElectricOutlet &#123; void connectElectricCurrent();&#125; 适配器 该适配器实现了目标接口三厢插座ThreeElectricOutlet，同时又包含了两厢插座TwoElectricOutlet的引用： 1234567891011121314package com.adatpe;//适配器：实现目标接口public class ThreeElectricAdapter implements ThreeElectricOutlet &#123; //适配器包含被适配者的引用 private TwoElectricOutlet outlet; public ThreeElectricAdapter(TwoElectricOutlet outlet) &#123; this.outlet = outlet; &#125; public void connectElectricCurrent() &#123; outlet.connectElectricCurrent(); &#125;&#125; 下列应用程序中，Application.java使用了适配器模式中所涉及的类，应用程序负责用Wash类创建一个对象来模拟一台洗衣机，使用TV类创建一个对象来模拟一台电视机 使用ThreeElectricOutlet接口变量调用Wash对象的connectElectricCurrent()方法，并借助适配器调用TV对象的connectElectricCurrent()方法，即用三厢插座分别为洗衣机和电视机接通电流。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.adatpe; public class Application &#123; public static void main(String[] args) &#123; ThreeElectricOutlet outlet; //目标接口（三相插座） Wash wash = new Wash(); //洗衣机 outlet = wash; //洗衣机插在三相插座上 System.out.println("使用三相插座接通电流"); outlet.connectElectricCurrent(); //接通电流开始洗衣服 TV tv = new TV(); //电视机 ThreeElectricAdapter adapter = new ThreeElectricAdapter(tv); //把电视插在适配器上面 outlet = adapter; //再把适配器插在三厢插座上 System.out.println("使用三厢插座接通电流"); outlet.connectElectricCurrent(); //接通电流，开始播放电视节目 &#125;&#125;//洗衣机使用三相插座class Wash implements ThreeElectricOutlet&#123; private String name; public Wash() &#123; name = "黄河洗衣机"; &#125; public Wash(String name)&#123; this.name = name; &#125; public void connectElectricCurrent() &#123; turnOn(); &#125; public void turnOn()&#123; System.out.println(name+"开始洗衣服了"); &#125;&#125;//电视机使用两厢插座class TV implements TwoElectricOutlet&#123; private String name; public TV() &#123; name = "长江电视机"; &#125; public TV(String name)&#123; this.name = name; &#125; public void connectElectricCurrent() &#123; turnOn(); &#125; public void turnOn()&#123; System.out.println(name+"开始播放电视节目"); &#125;&#125; 运行结果为： 使用三相插座接通电流黄河洗衣机开始洗衣服了使用三厢插座接通电流长江电视机开始播放电视节目 双向适配器在适配器模式中，如果Adapter角色同时实现目标接口和被适配者接口，并包含目标接口和被适配接口的引用，那么该适配器就是一个双向适配器。使用双向适配器，用户既可以用新的接口又可以用已有的接口。在以上例子中，如果用户希望能有三厢插座来接通洗衣机和电视机的电流，有可以用两厢插座来接通洗衣机和电视机的电流，那么就必须使用一个双向适配器。具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637package com.adatpe;public class ThreeAndTwoElectricAdapter implements ThreeElectricOutlet, TwoElectricOutlet &#123; private ThreeElectricOutlet threeElectricOutlet; private TwoElectricOutlet twoElectricOutlet; public ThreeAndTwoElectricAdapter(ThreeElectricOutlet threeOutlet,TwoElectricOutlet twoOutlet) &#123; threeElectricOutlet = threeOutlet; twoElectricOutlet = twoOutlet; &#125; public ThreeAndTwoElectricAdapter(TwoElectricOutlet twoOutlet,ThreeElectricOutlet threeOutlet)&#123; threeElectricOutlet = threeOutlet; twoElectricOutlet = twoOutlet; &#125; public void connectElectricCurrent() &#123; if(this instanceof ThreeElectricOutlet)&#123; twoElectricOutlet.connectElectricCurrent();//twoElectricOutlet是被适配的接口 &#125; if(this instanceof TwoElectricOutlet)&#123; threeElectricOutlet.connectElectricCurrent(); //threeElectricOutlet是被适配的接口 &#125; &#125; public static void main(String[] args) &#123; ThreeElectricOutlet threeOutlet; TwoElectricOutlet twOutlet; Wash wash = new Wash(); TV tv = new TV(); ThreeAndTwoElectricAdapter adapter = new ThreeAndTwoElectricAdapter(wash,tv); threeOutlet = adapter; System.out.println("使用三厢插座接通电源"); threeOutlet.connectElectricCurrent(); twOutlet = adapter; System.out.println("使用两厢插座接通电源"); twOutlet.connectElectricCurrent(); &#125;&#125; 运行结果为： 使用三厢插座接通电源长江电视机开始播放电视节目黄河洗衣机开始洗衣服了使用两厢插座接通电源长江电视机开始播放电视节目黄河洗衣机开始洗衣服了 这样就实现了即可以用三厢插座又可以用两厢插座来为电视机和洗衣机接通电流了。 优点 目标和被适配者是完全解耦的关系。 适配器模式满足“开–闭原则”，当添加一个实现了Adapter接口的新类时，不必修改Adapter，Adapter就能对这个新类的实例进行适配。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MapStruct转换list的问题]]></title>
    <url>%2Fjava%2Fjava-MapStruct-2%2F</url>
    <content type="text"><![CDATA[mapstruct在转换list之前必须有一个前置转换，即他们的实体之间的转换 错误的转换方式：1List&lt;EggVo&gt; listpoTovo(List&lt;Egg&gt; po); 正确的转换方式： 1234@Mapping(source = "id", target = "lid")EggVo poTovo(Egg po);List&lt;EggVo&gt; listpoTovo(List&lt;Egg&gt; po); 添加了实体转换之后，就可以正常的进行list转换了，同理把属性映射直接加在list转换上也是不行的，要加在实体转换上，然后list的转换也会继承这和属性的映射。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok介绍]]></title>
    <url>%2Fjava%2Fjava-Lombok%2F</url>
    <content type="text"><![CDATA[背景我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法，那Java中有没有一种方式能够避免这种重复的劳动呢？答案是有，我们来看一下下面这张图，右面是一个简单的JavaBean，只定义了两个属性，在类上加上了@Data，从左面的结构图上可以看到，已经自动生成了上面提到的方法。 Lombok简介ombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。 官方地址：https://projectlombok.org/ github地址：https://github.com/rzwitserloot/lombok Lombok使用注解介绍 @Getter / @Setter 可以作用在类上和属性上，放在类上，会对所有的非静态(non-static)属性生成Getter/Setter方法，放在属性上，会对该属性生成Getter/Setter方法。并可以指定Getter/Setter方法的访问级别。 @EqualsAndHashCode 默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。 @ToString 生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor 无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，Lombok就无能为力了。 @Data @ToString, @EqualsAndHashCode, 所有属性的@Getter, 所有non-final属性的@Setter和@RequiredArgsConstructor的组合，通常情况下，我们使用这个注解就足够了。 Lombok原理了解了简单的使用之后，现在应该比较好奇它是如何实现的。整个使用的过程中，只需要使用注解而已，不需要做其它额外的工作，那玄妙之处应该是在注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。 运行时解析运行时能够解析的注解，必须将@Retention设置为RUNTIME，这样可以通过反射拿到该注解。java.lang.reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，大部分开发者应该都很熟悉这种解析方式。 1234boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass);Annotation[] getAnnotations();Annotation[] getDeclaredAnnotations(); 编译时解析编译时解析有两种机制，网上很多文章都把它俩搞混了，分别简单描述一下。 Annotation Processing Toolapt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因： api都在com.sun.mirror非标准包下 没有集成到javac中，需要额外运行 Pluggable Annotation Processing APIJSR 269，自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，这时javac执行的过程如下： Lombok问题 无法支持多种参数构造器的重载 奇淫巧技，使用会有争议]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapStruct介绍]]></title>
    <url>%2Fjava%2Fjava-MapStruct-1%2F</url>
    <content type="text"><![CDATA[介绍MapStruct在一个成熟可维护的工程中，细分模块后，domian工程最好不要被其他工程依赖，但是实体类一般存于domain之中，这样其他工程想获取实体类数据时就需要在各自工程写model，自定义model可以根据自身业务需要而并不需要映射整个实体属性。mapstruct这个插件就是用来处理domin实体类与model类的属性映射，定义mapper接口，mapstruct就会自动的帮我们实现这个映射接口，避免了麻烦复杂的映射实现。 Github地址：https://github.com/mapstruct/mapstruct/ 使用例子：https://github.com/mapstruct/mapstruct-examples MapStrcut与其它工具对比以及使用说明：http://www.tuicool.com/articles/uiIRjai 如何使用Mapper基本类：BasicObjectMapper，BasicObjectMapper包含了4个基本方法，单个和集合以及反转的单个和集合。 开发中如需要对象转换操作可直接新建interface并继承BasicObjectMapper，并在新建的接口上加上 @Mapper(componentModel = “spring”)， 如果是属性中包含其它类以及该类已经存在Mapper则注解中加上 users = {类名.class}，具体如何使用以及其他各种用法在此不再赘述（本文的重点是看标题，看标题，看标题），google不行可以找度娘， componentModel = “spring”该配置表示生成的实现类默认加上spring @Component注解，使用时可直接通过@Autowire进行注入。 123456789101112131415161718192021package com.ampmind.framework.map;import java.util.List;import org.mapstruct.InheritConfiguration;import org.mapstruct.InheritInverseConfiguration;import org.mapstruct.Mappings;public interface BasicObjectMapper&lt;SOURCE, TARGET&gt; &#123; @Mappings(&#123;&#125;) @InheritConfiguration TARGET to(SOURCE var1); @InheritConfiguration List&lt;TARGET&gt; to(List&lt;SOURCE&gt; var1); @InheritInverseConfiguration SOURCE from(TARGET var1); @InheritInverseConfiguration List&lt;SOURCE&gt; from(List&lt;TARGET&gt; var1);&#125; 下面是两个不同的例子：先贴一下两个Model类 123456789101112131415161718192021222324252627282930package com.ampmind.service.skumng.domain;public class ProductCategory &#123; /** * 类别编码 */ private String categoryCode; /** * 类别名称 */ private String categoryName; public String getCategoryCode() &#123; return categoryCode; &#125; public void setCategoryCode(String categoryCode) &#123; this.categoryCode = categoryCode; &#125; public String getCategoryName() &#123; return categoryName; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125;&#125; CategoryVo 12345678910111213141516171819202122232425262728293031package com.ampmind.service.api.protocol.vo;public class ProductCategory &#123; private String code; private String name; public Integer getParentId() &#123; return parentId; &#125; public void setParentId(Integer parentId) &#123; this.parentId = parentId; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1.如何与Spring配合CategoryMapper 1234567891011121314151617package com.ampmind.service.skumng.api.mapper;import com.ampmind.framework.api.base.BasicObjectMapper;import com.ampmind.service.api.protocol.vo.CategoryVo;import com.ampmind.service.domain.ProductCategory;import org.mapstruct.Mapper;import org.mapstruct.Mapping;import org.mapstruct.Mappings;@Mapper(componentModel = "spring")public interface CategoryMapper extends BasicObjectMapper&lt;CategoryVo, ProductCategory&gt; &#123; @Mappings(&#123; @Mapping(source = "code", target = "categoryCode"), @Mapping(source = "name", target = "categoryName") &#125;) ProductCategory to(CategoryVo source);&#125; 上面重写了to方法，注意如果属性名一样可以不用重写。保持接口空的就行，有不一样的需要重写to方法，并在方法上加上 @Mappings注解和子注解spring注入并使用 12345678910111213141516171819@Componentpublic class Test &#123; @Autowired private CategoryMapper categoryMapper; public void test() &#123; CategoryVo vo = new CategoryVo; vo.setCategoryCode("0000"); vo.setCategoryName("属性名称"); ProductCategory pc = categoryMapper.to(vo);// 通过to方法得到 ProductCategory CategoryVo vo1 = categoryMapper.form(pc);// 通过from方法得到CategoryVo，既反转to方法。 List&lt;ProductCategory&gt; pcList = categoryMapper.to(Arrays.asList(vo, vo1));// 通过to方法从集合得到转换后的集合 List&lt;CategoryVo&gt; voList = categoryMapper.from(pcList); // 反转集合 &#125;&#125; 2.如何直接使用CategoryMapper 1234567891011121314151617181920212223package com.ampmind.service.skumng.api.mapper;import com.ampmind.framework.api.base.BasicObjectMapper;import com.ampmind.service.skumng.api.protocol.vo.CategoryVo;import com.ampmind.service.skumng.domain.ProductCategory;import org.mapstruct.Mapper;import org.mapstruct.Mapping;import org.mapstruct.Mappings;import org.mapstruct.factory.Mappers;/** * */@Mapperpublic interface CategoryMapper extends BasicObjectMapper&lt;CategoryVo, ProductCategory&gt; &#123; CategoryMapper MAPPER = Mappers.getMapper(CategoryMapper.class); @Mappings(&#123; @Mapping(source = "code", target = "categoryCode"), @Mapping(source = "name", target = "categoryName") &#125;) ProductCategory to(CategoryVo source);&#125; 直接可以通过main方法进行测试 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; CategoryVo vo = new CategoryVo; vo.setCategoryCode("0000"); vo.setCategoryName("属性名称"); ProductCategory pc = CategoryMapper.MAPPER.to(vo);// 通过to方法得到 ProductCategory CategoryVo vo1 = CategoryMapper.MAPPER.form(pc);// 通过from方法得到CategoryVo，既反转to方法。 List&lt;ProductCategory&gt; pcList = CategoryMapper.MAPPER.to(Arrays.asList(vo, vo1));// 通过to方法从集合得到转换后的集合 List&lt;CategoryVo&gt; voList = CategoryMapper.MAPPER.from(pcList); // 反转集合 &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE PO VO BO DTO POJO DAO 整理总结]]></title>
    <url>%2Fjava%2Fjava-pojo%2F</url>
    <content type="text"><![CDATA[DAO[data access object]数据访问对象 DAO层对开发人员黑盒，由架构师设计封装。在很长一段时间内，我将它理解为对数据库的访问，后面随着项目的积累。发现自己的理解相对狭隘，对数据访问不仅仅指的是对数据库的访问。假如A系统调用B系统的服务获取数据，这时候A系统对B系统访问数据对象的封装也可以称为DAO。 DTO[data transfer object]数据传输对象 假设数据表中存在20个字段，但是在页面展示列表的时候，这20个字段显然都不会用到。我想对其中的5个字段进行展示，而且这5个字段展示的时候，也并不是数据库中他们原有的样子。还需要进行计算、截取、业务代码转名称 …..等等数据传输对象因此而被诞生，一是能提高数据传输的速度，二能隐藏后端表结构。 PO[persistant object]持久层对象 持久对象属性和数据库中的字段是一一对应的，数据库中的一条数据可以理解为一个持久对象。因ORM框架的广泛使用而被引入到 JavaEE 项目设计当中。 BO[bussiness object]业务对象 业务对象顾名思义是在业务处理中抽象出来的对象，里面除了get/set 方法外，也可以有对字段进行业务处理的方法。假设你要对一个班级进行业务处理，其中的学生、教师、甚至是桌椅板凳都是业务对象的组成部分。当然其中的学生、教室….都可以是和数据库对应的PO。 VO[value object]值对象 值对象也可以称做页面对象，如果称做页面对象，那门它所代表的将是整个页面展示层的对象。可以由需要的业务对象进行的换算转换而来。如果称呼他为值对象的话，那门他可以理解为存放业务对象的一个地方。假设锅碗瓢盆分别为对应的业务对象的话，那门整个碗柜就是一个值对象。 POJO[plain ordiary java object] 简单java对象 简单java对象应该是JavaEE世界里面最灵活的对象。在简单系统中，如果从数据库到页面展示都是POJO的话，它可以是DTO。如果从数据库中到业务处理中都是POJO的话，他也可以是BO。同样如果从数据库到整个页面的展示的话，它同样可以是VO。 小结： 各个数据对象之间的转换是相当灵活的，在项目中可以定义上述对象的全部和其中的几种类型，这取决与架构师和需求。在大型项目中，架构师在项目初期的任务除了搭建起整个开发环境以外，定义在系统中流转的数据结构对象同样是重重之重。这项工作需要许多项目的积累和长期对软件开发的思考，多实践，多思考，提供最合适的数据对象解决方法，方能展现架构师的魅力。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>pojo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm使用]]></title>
    <url>%2Fnodejs%2Fnpm-1%2F</url>
    <content type="text"><![CDATA[NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功: 12$ npm -v2.3.0 如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下： 123$ sudo npm install npm -g/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.jsnpm@2.14.2 /usr/local/lib/node_modules/npm 如果是 Window 系统使用以下命令即可： 1$ npm install npm -g 使用 npm 命令安装模块npm 安装 Node.js 模块语法格式如下： 1$ npm install &lt;Module Name&gt; 以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express: 1$ npm install express 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 1var express = require('express'); 全局安装与本地安装npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如 12$ npm install express # 本地安装$ npm install express -g # 全局安装 如果出现以下错误： 1npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 解决办法为： 1$ npm config set proxy null 本地安装 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。接下来我们使用全局方式安装 express 1$ npm install express -g 查看安装信息你可以使用以下命令来查看所有全局安装的模块： 1$ npm list -g 如果要查看某个模块的版本号，可以使用命令如下： 1$ npm list grunt 使用 package.jsonpackage.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容： 12345678910111213141516171819202122232425262728293031&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.4.4" &#125;, "dependencies": &#123; "hexo": "^3.2.0", "hexo-deployer-git": "^0.3.1", "hexo-generator-archive": "^0.1.4", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.0", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.0", "hexo-renderer-marked": "^0.3.0", "hexo-renderer-stylus": "^0.3.1", "hexo-server": "^0.2.0" &#125;, "devDependencies": &#123; "gulp": "^3.9.1", "gulp-htmlclean": "^2.7.16", "gulp-htmlmin": "^4.0.0", "gulp-minify-css": "^1.2.4", "gulp-uglify": "^3.0.0", "hexo-admin": "^2.3.0", "hexo-generator-searchdb": "^1.0.8", "hexo-wordcount": "^3.0.2" &#125;&#125;` Package.json 属性说明 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 卸载模块我们可以使用以下命令来卸载 Node.js 模块。 1$ npm uninstall express 卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看： 1$ npm ls 更新模块我们可以使用以下命令更新模块： 1$ npm update express 搜索模块使用以下来搜索模块： 1$ npm search express 使用淘宝 NPM 镜像大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。 淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 安装不创建bin链接1$ npm install --no-bin-links 编译并不创建bin链接1$ npm rebuild node-sass --no-bin-links]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox建立软链接]]></title>
    <url>%2FVirtualBox%2FVirtualBox-1%2F</url>
    <content type="text"><![CDATA[VirtualBox共享目录，建立软链接 关闭 VirtualBox。 将VirtualBox安装目录的路径加入系统环境变量PATH中。 打开命令行窗口，执行如下命令： 12VBoxManage setextradata &#123;YOURVMNAME&#125;VBoxInternal2/SharedFoldersEnableSymlinksCreate/&#123;YOURSHAREFOLDERNAME&#125; 1 参数说明YOURVMNAME：为虚拟机中ubuntu系统的名YOURSHAREFOLDERNAME：为共享的目录名称 “以管理者身份运行” VirtualBox 即可！]]></content>
      <categories>
        <category>VirtualBox</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9个常用iptables配置实例]]></title>
    <url>%2Flinux%2Flinux-shell-iptabls-2%2F</url>
    <content type="text"><![CDATA[iptables命令可用于配置Linux的包过滤规则，常用于实现防火墙、NAT。咋一看iptables的配置很复杂，掌握规律后，其实用iptables完成指定任务并不难，下面我们通过具体实例，学习iptables的详细用法。 删除已有规则 在新设定iptables规则时，我们一般先确保旧规则被清除，用以下命令清除旧规则 12$ iptables -F(or iptables --flush) 设置chain策略 对于filter table，默认的chain策略为ACCEPT，我们可以通过以下命令修改chain的策略 123$ iptables -P INPUT DROP$ iptables -P FORWARD DROP$ iptables -P OUTPUT DROP 以上命令配置将接收、转发和发出包均丢弃，施行比较严格的包管理。由于接收和发包均被设置为丢弃，当进一步配置其他规则的时候，需要注意针对INPUT和OUTPUT分别配置。当然，如果信任本机器往外发包，以上第三条规则可不必配置。 屏蔽指定ip 有时候我们发现某个ip不停的往服务器发包，这时我们可以使用以下命令，将指定ip发来的包丢弃 12$ BLOCK_THIS_IP="x.x.x.x"$ iptables -A INPUT -i eth0 -p tcp -s "$BLOCK_THIS_IP" -j DROP 以上命令设置将由x.x.x.x ip发往eth0网口的tcp包丢弃 配置服务项 利用iptables，我们可以对日常用到的服务项进行安全管理，比如设定只能通过指定网段、由指定网口通过SSH连接本机 12$ iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0/24 --dport 22 -m state --state NEW,ESTABLESHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 若要支持由本机通过SSH连接其他机器，由于在本机端口建立连接，因而还需要设置以下规则 12$ iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0/24 --dport 22 -m state --state ESTABLESHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 类似的，对于HTTP/HTTPS(80/443)、pop3(110)、rsync(873)、MySQL(3306)等基于tcp连接的服务，也可以参照上述命令配置。 对于基于udp的dns服务，使用以下命令开启端口服务 12$ iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT$ iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT 网口转发配置 对于用作防火墙或网关的服务器，一个网口连接到公网，其他网口的包转发到该网口实现内网向公网通信，假设eth0连接内网，eth1连接公网，配置规则如下 1$ iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT 端口转发配置 对于端口，我们也可以运用iptables完成转发配置 1$ iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22 以上命令将422端口的包转发到22端口，因而通过422端口也可进行SSH连接，当然对于422端口，我们也需要像以上“4.配置服务项”一节一样，配置其支持连接建立的规则。 DoS攻击防范 利用扩展模块limit，我们还可以配置iptables规则，实现DoS攻击防范 1$ iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT –litmit 25/minute 指示每分钟限制最大连接数为25–litmit-burst 100 指示当总连接数超过100时，启动 litmit/minute 限制 配置web流量均衡 我们可以将一台服务器作为前端服务器，利用iptables进行流量分发，配置方法如下 123$ iptables -A PREROUTING -i eth0 -p tcp --dport 80 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:80$ iptables -A PREROUTING -i eth0 -p tcp --dport 80 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.102:80$ iptables -A PREROUTING -i eth0 -p tcp --dport 80 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.103:80 以上配置规则用到nth扩展模块，将80端口的流量均衡到三台服务器 将丢弃包情况记入日志 使用LOG目标和syslog服务，我们可以记录某协议某端口下的收发包情况。拿记录丢包情况举例，可以通过以下方式实现。 首先自定义一个chain 1$ iptables -N LOGGING 其次将所有接收包导入LOGGING chain中 1$ iptables -A INPUT -j LOGGING 然后设置日志前缀、日志级别 1$ iptables -A LOGGING -m limit --limit 2/min -j LOG --log-prefix "IPTables Packet Dropped: " --log-level 7 最后将包倒向DROP，将包丢弃 1$ iptables -A LOGGING -j DROP 另可以配置syslog.conf文件，指定iptables的日志输出]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TC基于CBQ队列的流量管理范例]]></title>
    <url>%2Flinux%2Flinux-shell-tc-1%2F</url>
    <content type="text"><![CDATA[简介参考了TC的很多文档，自己也整理了一篇配置记录。在实际使用过程中效果还不错，在此分享给大家以备参考。环境：局域网规模不是很大40多台机器。 NAT共享上网（内网：eth0 外网：eth2）CBQ是通过硬件的闲置时间来计算队列，硬件不同，效果也不同，对于比较大的网络使用HTB比较好。以下限制上传和下载的方法可以写成脚本，通过mrtg发现流量的异常情况，然后通过ntop查处是谁在干坏事，最后用写好的tc脚本限制他的流量，避免影响其他人的网络使用。 示例针对网络物理设备绑定一个CBQ队列 1$ tc qdisc add dev eth0 root handle 1: cbq bandwidth 10Mbit avpkt 1000 cell 8 mpu 64 将一个cbq队列绑定到网络物理设备eth0上，其编号为1:0；网络物理设备eth0的实际带宽为10Mbit，包的平均大小为1000字节；包间隔发送单元的大小为8字节，最小传输包大小为64字节。 在该队列上建立分类 1$ tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 10Mbit rate 10Mbit maxburst 20 allot 1514 prio 1 avpkt 1000 cell 8 weight 1Mbit 创建根分类1:1；分配带宽为10Mbit，优先级别为1。该队列的最大可用带宽为10Mbit，实际分配的带宽为10Mbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为1，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为1Mbit。 创建子分类 创建分类1:2，其父分类为1:1，分配带宽为64Kbit，优先级别为8。该队列的最大可用带宽为10Mbit，实际分配的带宽为64Kbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为8，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，且不可借用未使用带宽。$ tc class add dev eth0 parent 1:1 classid 1:2 cbq bandwidth 10Mbit rate 64Kbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 100Kbit bounded 创建分类1:3，其父分类为1:1，分配带宽为64Kbit，优先级别为9。该队列的最大可用带宽为10Mbit，实际分配的带宽为64Kbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为9，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，且不可借用未使用带宽。$ tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 10Mbit rate 64Kbit maxburst 20 allot 1514 prio 9 avpkt 1000 cell 8 weight 100Kbit bounded 在子分类地下创建队列，使用sfq随机公平队列 12$ tc qdisc add dev eth0 parent 1:2 sfq quantum 1514b perturb 15$ tc qdisc add dev eth0 parent 1:3 sfq quantum 1514b perturb 15 在分类底下，创建队列，使用sfq随即公平队列 为每一分类建立一个基于路由的过滤 12$ tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.116 flowid 1:2$ tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.66 flowid 1:3 限制各ip地址的下载带宽，使用u32过滤器，对目的地址进行分类，对应已经创建的队列需要添加新的被限制ip的下载带宽，需要先要创建新的分类(比如1:4),然后根据新的分类创建新的sfq队列，最后使用u32过滤器对目的地址进行带宽限制。需要对几个ip限制下载带宽，就需要创建几个分类、队列、过滤器 限制上传 将一个cbq队列绑定到网络物理设备eth2上，其编号为2:0；网络物理设备eth2的实际带宽为2Mbit，包的平均大小为1000字节；包间隔发送单元的大小为8字节，最小传输包大小为64字节。 1$ tc qdisc add dev eth2 root handle 2: cbq bandwidth 2Mbit avpkt 1000 cell 8 mpu 64 创建根分类2:1；分配带宽为2Mbit，优先级别为1。该队列的最大可用带宽为2Mbit，实际分配的带宽2Mbit， 可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为1，包的平均 大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为200Kbit。 1$ tc class add dev eth2 parent 2:0 classid 2:1 cbq bandwidth 2Mbit rate 2Mbit maxburst 20 allot 1514 prio 1 avpkt 1000 cell 8 weight 200Kbit 创建分类2:2，其父分类为2:1，分配带宽为64Kbit，优先级别为8。该队列的最大可用带宽为2Mbit，实际分配的带宽为64Kbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为8，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，且不可借用未使用带宽。 1$ tc class add dev eth2 parent 2:1 classid 2:2 cbq bandwidth 2Mbit rate 64Kbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 200Kbit bounded 在分类底下，创建队列，使用sfq随即公平队列 1$ tc qdisc add dev eth2 parent 2:2 sfq quantum 1514b perturb 15 应用路由分类器到cbq队列的根，过滤协议为ip，优先级为100 1$ tc filter add dev eth2 parent 2:0 protocol ip prio 1 handle 2 fw classid 2:2 给数据包打标签,可以通过RETURN方法避免遍历所有的规则，加快处理速度 12$ iptables –t mangle –A PREROUTING –i eth0 –s 192.111.1.xxx –j MARK --set-mark 2$ iptables –t mangle –A PREROUTING –i eth0 –s 192.111.1.xxx –j RETURN nat模式 1$ iptables -t nat -A POSTROUTING -s 192.111.1.0/24 -o eth2 -j SNAT --to 外网IP 需要添加新的被限制ip的上传带宽，需要先要创建新的分类(比如2:3),然后根据新的分类创建新的sfq队列，最后使用路由过滤器，过滤协议为ip，给原地址是需要限制的ip地址来的数据包打标记。需要对几个ip限制下载带宽，就需要创建几个分类、队列、路由过滤器、iptable的mangle表的PREROUTING链 另外还有其他的过滤器比如 1$ tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 2 flowid 1:2 ip route add 192.111.1.24 dev eth0 via 192.111.1.4 realm 2 维护 主要包括对队列、分类、过滤器和路由的增添、修改和删除。 增添动作一般依照”队列-&gt;分类-&gt;过滤器-&gt;路由”的顺序进行；修改动作则没有什么要求；删除则依照”路由-&gt;过滤器-&gt;分类-&gt;队列”的顺序进行。 简单显示指定设备的队列状况 1$ tc qdisc ls dev eth0 详细显示指定设备的队列状况 1$ tc –s qdisc ls dev eth0 简单显示指定设备的分类状况 1$ tc class ls dev eth0 详细显示指定设备的分类状况 1$ tc –s class ls dev eth0 显示过滤器的状况 1$ tc –s filter ls dev eth0 队列的维护 一般对于一台流量控制器来说，出厂时针对每个以太网卡均已配置好一个队列了，通常情况下对队列无需进行增添、修改和删除动作了。 分类的维护 增添动作通过tc class add命令实现。 修改动作通过tc class change命令实现，如下所示： 1$ tc class change dev eth0 parent 1:1 classid 1:2 cbq bandwidth 10Mbit rate 64Kbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 100Kbit bounded 对于bounded命令应慎用，一旦添加后就进行修改，只可通过删除后再添加来实现。 过滤器的维护 增添动作通过tc filter add命令实现。 修改动作通过tc filter change命令实现，如下所示： 1$ tc filter change dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.116 flowid 1:2 删除动作通过tc filter del命令实现，如下所示： 1$ tc filter del dev eth0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.111.1.116 flowid 1:]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>tc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables之nat表应用——IP与端口的映射]]></title>
    <url>%2Flinux%2Flinux-shell-iptables-1%2F</url>
    <content type="text"><![CDATA[需求 将192.168.3.195：80 映射到192.168.3.193：80，即访问192.168.3.195：80，得到192.168.3.193：80的结果，实现linux的路由。 实现 123456789101112131415161718192021#!/bin/bash#打开转发功能echo "1" &gt; /proc/sys/net/ipv4/ip_forward /sbin/iptables -F -t filter#清空iptables/sbin/iptables -F -t nat #去192.168.3.193的一条路/sbin/iptables -t nat -A PREROUTING -d 192.168.3.195 -p tcp --dport 80 -j DNAT --to-destination 192.168.3.193:80 #返回的时候的一条路，ip传输要有去有回才能连通 /sbin/iptables -t nat -A POSTROUTING -s 192.168.3.0/24 -o eth0 -j SNAT --to 192.168.3.195 #用2网段访问的时候的回路/sbin/iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -o eth0 -j SNAT --to 192.168.3.195 #用0网段访问的时候的回路/sbin/iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to 192.168.3.195 回路的那一条，或者只用下面这一句：iptables -t nat -A POSTROUTING -s 0.0.0.0/0 -o eth0 -j SNAT --to 192.168.3.195或者iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 192.168.3.195把193上的80端口打开 测试 在192.168.3.195上访问 192.168.3.195：80看到 195的apache主页，因为在本机上访问，没有走PREROUTING这条链。在其他主机上访问192.168.3.195：80 返回193的apache主页，路线为PREROUTING–&gt;FORWARD–&gt;PSOTROUTING.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iptables命令]]></title>
    <url>%2Flinux%2Flinux-shell-iptables%2F</url>
    <content type="text"><![CDATA[简介iptables命令是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。 参数说明12345678910111213141516-t&lt;表&gt;：指定要操纵的表；-A：向规则链中添加条目；-D：从规则链中删除条目；-i：向规则链中插入条目；-R：替换规则链中的条目；-L：显示规则链中已有的条目；-F：清楚规则链中已有的条目；-Z：清空规则链中的数据包计算器和字节计数器；-N：创建新的用户自定义规则链；-P：定义规则链中的默认目标；-h：显示帮助信息；-p：指定要匹配的数据包协议类型；-s：指定要匹配的数据包源ip地址；-j&lt;目标&gt;：指定要跳转的目标；-i&lt;网络接口&gt;：指定数据包进入本机的网络接口；-o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。 命令格式iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作 表名包括 1234raw：高级功能，如：网址过滤。mangle：数据包修改（QOS），用于实现服务质量。net：地址转换，用于网关路由器。filter：包过滤，用于防火墙规则。 规则链名包括 12345INPUT链：处理输入数据包。OUTPUT链：处理输出数据包。PORWARD链：处理转发数据包。PREROUTING链：用于目标地址转换（DNAT）。POSTOUTING链：用于源地址转换（SNAT）。 动作包括 1234567accept：接收数据包。DROP：丢弃数据包。REDIRECT：重定向、映射、透明代理。SNAT：源地址转换。DNAT：目标地址转换。MASQUERADE：IP伪装（NAT），用于ADSL。LOG：日志记录。 示例清除已有iptables规则123$ iptables -F$ iptables -X$ iptables -Z 开放指定的端口123456789$ iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT #允许本地回环接口(即运行本机访问本机)$ iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已建立的或相关连的通行$ iptables -A OUTPUT -j ACCEPT #允许所有本机向外的访问$ iptables -A INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口$ iptables -A INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口$ iptables -A INPUT -p tcp --dport 21 -j ACCEPT #允许ftp服务的21端口$ iptables -A INPUT -p tcp --dport 20 -j ACCEPT #允许FTP服务的20端口$ iptables -A INPUT -j reject #禁止其他未允许的规则访问$ iptables -A FORWARD -j REJECT #禁止其他未允许的规则访问 屏蔽IP1234$ iptables -I INPUT -s 123.45.6.7 -j DROP #屏蔽单个IP的命令$ iptables -I INPUT -s 123.0.0.0/8 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令$ iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令$ iptables -I INPUT -s 123.45.6.0/24 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是 查看已添加的iptables规则123456789101112131415$ iptables -L -n -vChain INPUT (policy DROP 48106 packets, 2690K bytes) pkts bytes target prot opt in out source destination 5075 589K ACCEPT all -- lo * 0.0.0.0/0 0.0.0.0/0 191K 90M ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:221499K 133M ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:804364K 6351M ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 6256 327K ACCEPT icmp -- * * 0.0.0.0/0 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes) pkts bytes target prot opt in out source destination 5075 589K ACCEPT all -- * lo 0.0.0.0/0 0.0.0.0/0 删除已添加的iptables规则 将所有iptables以序号标记显示，执行 1$ iptables -L -n --line-numbers 比如要删除INPUT里序号为8的规则，执行 1$ iptables -D INPUT 8]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell /bin/bash^M: bad interpreter错误解决]]></title>
    <url>%2Flinux%2Flinux-error-bash-1%2F</url>
    <content type="text"><![CDATA[错误原因之一很有可能是你的脚本文件是DOS格式的, 即每一行的行尾以\r\n来标识, 其ASCII码分别是0x0D, 0x0A.可以有很多种办法看这个文件是DOS格式的还是UNIX格式的, 还是MAC格式的。 vi filename然后用命令:set ff?可以看到dos或unix的字样. 如果的确是dos格式的, 那么你可以用set ff=unix把它强制为unix格式的, 然后存盘退出. 再运行一遍看. 用joe filename如果是DOS格式的, 那么行尾会有很多绿色的^M字样出现. 你也可以用上述办法把它转为UNIX格式的. 用od -t x1 filename如果你看到有0d 0a 这样的字符, 那么它是dos格式的, 如果只有0a而没有0d, 那么它是UNIX格式的, 同样可以用上述方法把它转为UNIX格式的. 转换不同平台的文本文件格式可以用 unix2dos或dos2unix这两个小程序来做. 很简单. 在djgpp中这两个程序的名字叫dtou和utod, u代表unix, d代表dos 也可以用sed 这样的工具来做: 12$ sed 's/^M//' filename &gt; tmp_filename$ mv -f tmp_filename filename 来做说明:^M并不是按键shift + 6产生的^和字母M, 它是一个字符, 其ASCII是0x0D, 生成它的办法是先按CTRL+V, 然后再回车(或CTRL+M)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tcpdump命令]]></title>
    <url>%2Flinux%2Flinux-shell-tcpdump%2F</url>
    <content type="text"><![CDATA[简介用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。 参数说明 使用格式 $ tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -wfile ] [ expression ] 抓包选项 12345678910111213-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定"-c 10"将获取10个包，但可能已经 处理了100个包，只不过只有10个包是满足条件的包。 -i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)，一旦找到第一个符合条件的接口，搜寻马上结束。可以使用'any'关键字表示所有网络接口。 -n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-N：不打印出host的域名部分。例如tcpdump将会打印'nic'而不是'nic.ddn.mil'。-P：指定要抓取的包是流入还是流出的包。可以给定的值为"in"、"out"和"inout"，默认为"inout"。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断，输出行中会出现"[|proto]"的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。 输出选项 1234567-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：当分析和打印的时候，产生详细的输出。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。 其他功能性选项 12345-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于"-i"后。-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。-w：将抓包数据输出到文件中而不是标准输出。可以同时配合"-G time"选项使得输出文件每time秒就自动切换到另一个文件。可通过"-r"选项载入这些文件以进行分析和打印。-r：从给定的数据包文件中读取数据。使用"-"表示从标准输入中读取。 示例 监视指定网络接口的数据包 1$ tcpdump -i eth1 如果不指定网卡，默认tcpdump只会监视第一个网络接口，如eth0。 监视指定主机的数据包，例如所有进入或离开longshuai的数据包 1$ tcpdump host longshuai 打印helios&lt;–&gt;hot或helios&lt;–&gt;ace之间通信的数据包 1$ tcpdump host helios and \( hot or ace \) 打印ace与任何其他主机之间通信的IP数据包,但不包括与helios之间的数据包 1$ tcpdump ip host ace and not helios 截获主机hostname发送的所有数据 1$ tcpdump src host hostname 监视所有发送到主机hostname的数据包 1$ tcpdump dst host hostname 监视指定主机和端口的数据包 1$ tcpdump tcp port 22 and host hostname 对本机的udp 123端口进行监视(123为ntp的服务端口) 1$ tcpdump udp port 123 监视指定网络的数据包，如本机与192.168网段通信的数据包，”-c 10”表示只抓取10个包 1$ tcpdump -c 10 net 192.168 打印所有通过网关snup的ftp数据包(注意,表达式被单引号括起来了,这可以防止shell对其中的括号进行错误解析) 1$ tcpdump 'gateway snup and (port ftp or ftp-data)' 抓取ping包 1$ tcpdump -c 5 -nn -i eth0 icmp 如果明确要抓取主机为192.168.100.70对本机的ping，则使用and操作符。 1$ tcpdump -c 5 -nn -i eth0 icmp and src 192.168.100.62 注意不能直接写icmp src 192.168.100.70，因为icmp协议不支持直接应用host这个type。 抓取到本机22端口包 1$ tcpdump -c 10 -nn -i eth0 tcp dst port 22 解析包数据 1$ tcpdump -c 2 -q -XX -vvv -nn -i eth0 tcp dst port 22]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DATE命令]]></title>
    <url>%2Flinux%2Flinux-shell-date%2F</url>
    <content type="text"><![CDATA[简介很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。 参数说明12345-d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；-u：显示GMT；--help：在线帮助；--version：显示版本信息。 格式列表1234567891011121314151617181920212223242526272829%n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区 %a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999) 示例设置时间1234567date -s //设置当前时间，只有root权限才能设置，其他只能查看。date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00date -s 01:01:01 //设置具体时间，不会对日期做更改date -s “01:01:01 2008-05-23″ //这样可以设置全部时间date -s “01:01:01 20080523″ //这样可以设置全部时间date -s “2008-05-23 01:01:01″ //这样可以设置全部时间date -s “20080523 01:01:01″ //这样可以设置全部时间 时间加减1234567date +%Y%m%d //显示现在天年月日date +%Y%m%d --date="+1 day" //显示后一天的日期date +%Y%m%d --date="-1 day" //显示前一天的日期date +%Y%m%d --date="-1 month" //显示上一月的日期date +%Y%m%d --date="+1 month" //显示下一月的日期date +%Y%m%d --date="-1 year" //显示前一年的日期date +%Y%m%d --date="+1 year" //显示下一年的日期]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hwclock命令]]></title>
    <url>%2Flinux%2Flinux-shell-hwclock%2F</url>
    <content type="text"><![CDATA[简介hwclock命令是一个硬件时钟访问工具，它可以显示当前时间、设置硬件时钟的时间和设置硬件时钟为系统时间，也可设置系统时间为硬件时钟的时间。 在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。 参数说明12345678910--adjust：hwclock每次更改硬件时钟时，都会记录在/etc/adjtime文件中。使用--adjust参数，可使hwclock根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟；--debug：显示hwclock执行时详细的信息；--directisa：hwclock预设从/dev/rtc设备来存取硬件时钟。若无法存取时，可用此参数直接以I/O指令来存取硬件时钟；--hctosys：将系统时钟调整为与目前的硬件时钟一致；--set --date=&lt;日期与时间&gt;：设定硬件时钟；--show：显示硬件时钟的时间与日期；--systohc：将硬件时钟调整为与目前的系统时钟一致；--test：仅测试程序，而不会实际更改硬件时钟；--utc：若要使用格林威治时间，请加入此参数，hwclock会执行转换的工作；--version：显示版本信息。 示例设置硬件时间要依赖于操作系统时间12$ hwclock –systohc$ hwclock --systohc –-utc 查看当前的硬件日期和时间1$ hwclock 设置硬件时间1$ hwclock -w 查看clock文件，确认是否设置了UTC12$ cat /etc/default/rcS UTC=yes]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>hwclock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vsftpd安装]]></title>
    <url>%2Flinux%2Flinux-software-vsftpd%2F</url>
    <content type="text"><![CDATA[准备工作 linux系统centos7 vsftpd软件 yum安装 执行步骤安装vsftpd服务器 1$ yum install vsftpd 安装一个加密工具 1$ yum install libdb-utils.x86_64 修改配置VSFTP 1$ vi /etc/vsftpd/vsftpd.conf 配置文件参数说明 anonymous_enable=NO #设定不允许匿名访问 local_enable=YES #设定本地用户可以访问。注：如使用虚拟宿主用户，在该项目设定为NO的情况下所有虚拟用户将无法访问。 chroot_list_enable=YES #使用户不能离开主目录 ascii_upload_enable=YES #允许使用ASCII模式上传 ascii_download_enable=YES #设定支持ASCII模式的上传和下载功能。 pam_service_name=vsftpd #PAM认证文件名。PAM将根据/etc/pam.d/vsftpd进行认证 guest_enable=YES #设定启用虚拟用户功能。 guest_username=ftp #指定虚拟用户的宿主用户。-RHEL/CentOS中已经有内置的ftp用户了 user_config_dir=/etc/vsftpd/vuser_conf #设定虚拟用户个人vsftp的RHEL/CentOS FTP服务文件存放路 径。 listen=YES # 只监听ipv4的地址 xferlog_file=/var/log/xferlog # 日志文件的路径 listen_port=1315 #FTP端口 pasv_enable=YES #开启被动模式 pasv_min_port=10060 pasv_max_port=10070 创建chroot list，将ftp用户加入其中 12$ touch /etc/vsftpd/chroot_list$ echo ftp &gt;&gt; /etc/vsftpd/chroot_list 安装Berkeley DB工具 1$ yum install db4 db4-utils 创建用户密码文本 1$ touch /etc/vsftpd/vuser_passwd.txt 生成虚拟用户认证的db文件 12$ db_load -T -t hash -f /etc/vsftpd/vuser_passwd.txt /etc/vsftpd/vuser_passwd.db$ chmod 600 /etc/vsftpd/vuser_passwd.db 编辑认证文件 1$ vi /etc/pam.d/vsftpd 把前面的注释去掉，然后加上以下几条 系统为32位： auth required pam_userdb.so db=/etc/vsftpd/vuser_passwd account required pam_userdb.so db=/etc/vsftpd/vuser_passwd 系统为64位：auth required /lib64/security/pam_userdb.sodb=/etc/vsftpd/vuser_passwd account required/lib64/security/pam_userdb.so db=/etc/vsftpd/vuser_passwd 修改VSFTPD端口 执行vi /etc/services，将其中的 ftp 21/tcp 改为 ftp 1315/tcp , ftp21/udp改为 ftp 1315/udp 重启动vsftp服务 1$ service vsftpd restart]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>software</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GREP命令]]></title>
    <url>%2Flinux%2Flinux-shell-grep%2F</url>
    <content type="text"><![CDATA[简介grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 参数说明12345678910111213141516171819202122232425-a 不要忽略二进制数据。-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。-c 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。-F 将范本样式视为固定字符串的列表。-G 将范本样式视为普通的表示法来使用。-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H 在显示符合范本样式的那一列之前，标示该列的文件名称。-i 忽略字符大小写的差别。-l 列出文件内容符合指定的范本样式的文件名称。-L 列出文件内容不符合指定的范本样式的文件名称。-n 在显示符合范本样式的那一列之前，标示出该列的编号。-q 不显示任何信息。-R/-r 此参数的效果和指定“-d recurse”参数相同。-s 不显示错误信息。-v 反转查找。-w 只显示全字符合的列。-x 只显示全列符合的列。-y 此参数效果跟“-i”相同。-o 只输出文件中匹配到的部分。 示例 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行： 12$ grep match_pattern file_name$ grep "match_pattern" file_name 在多个文件中查找 1$ grep "match_pattern" file_1 file_2 file_3 ... 输出除之外的所有行 -v 选项 1$ grep -v "match_pattern" file_name 标记匹配颜色 –color=auto 选项 1$ grep "match_pattern" file_name --color=auto 使用正则表达式 -E 选项 12$ grep -E "[1-9]+"$ egrep "[1-9]+" 只输出文件中匹配到的部分 -o 选项 12$ echo this is a test line. | grep -o -E "[a-z]+\."$ echo this is a test line. | egrep -o "[a-z]+\." 统计文件或者文本中包含匹配字符串的行数 -c 选项 1$ grep -c "text" file_name 输出包含匹配字符串的行数 -n 选项 123456$ grep "text" -n file_name或$ cat file_name | grep "text" -n#多个文件$ grep "text" -n file_1 file_2 打印样式匹配所位于的字符或字节偏移 1234$ echo gun is not unix | grep -b -o "not"7:not#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。 搜索多个文件并查找匹配文本在哪些文件中 1$ grep -l "text" file1 file2 file3... 在多级目录中对文本进行递归搜索 12$ grep "text" . -r -n# .表示当前目录。 忽略匹配样式中的字符大小写 1$ echo "hello world" | grep -i "HELLO" 选项 -e 制动多个匹配样式 12345$ echo this is a text line | grep -e "is" -e "line" -o#也可以使用-f选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。$ echo aaa bbb ccc ddd eee | grep -f patfile -o 在grep搜索结果中包括或者排除指定文件 12345678#只在目录中所有的.php和.html文件中递归搜索字符"main()"$ grep "main()" . -r --include *.&#123;php,html&#125;#在搜索结果中排除所有README文件$ grep "main()" . -r --exclude "README"#在搜索结果中排除filelist文件列表里的文件$ grep "main()" . -r --exclude-from filelist 使用0值字节后缀的grep与xargs 12345678#测试文件：$ echo "aaa" &gt; file1$ echo "bbb" &gt; file2$ echo "aaa" &gt; file3$ grep "aaa" file* -lZ | xargs -0 rm#执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。 grep静默输出 123$ grep -q "test" filename#不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。 打印出匹配文本之前或者之后的行 1234567891011#显示匹配某个结果之后的3行，使用 -A 选项：$ seq 10 | grep "5" -A 3#显示匹配某个结果之前的3行，使用 -B 选项：$ seq 10 | grep "5" -B 3#显示匹配某个结果的前三行和后三行，使用 -C 选项：$ seq 10 | grep "5" -C 3#如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：$ echo -e "a\nb\nc\na\nb\nc" | grep a -A 1]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux设置全路径显示]]></title>
    <url>%2Flinux%2Flinux-config-setallpath%2F</url>
    <content type="text"><![CDATA[在Linux中，编辑vi /etc/bashrc文件，搜索PS1=&quot;[\u@\h \W]，将大写的W改为w 修改前： 修改后: 效果显示:]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DF命令]]></title>
    <url>%2Flinux%2Flinux-shell-df%2F</url>
    <content type="text"><![CDATA[简介df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 参数说明12345678910111213141516-a或--all：包含全部的文件系统；--block-size=&lt;区块大小&gt;：以指定的区块大小来显示区块数目；-h或--human-readable：以可读性较高的方式来显示信息；-H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；-i或--inodes：显示inode的信息；-k或--kilobytes：指定区块大小为1024字节；-l或--local：仅显示本地端的文件系统；-m或--megabytes：指定区块大小为1048576字节；--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；-P或--portability：使用POSIX的输出格式；--sync：在取得磁盘使用信息前，先执行sync指令；-t&lt;文件系统类型&gt;或--type=&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息；-T或--print-type：显示文件系统的类型；-x&lt;文件系统类型&gt;或--exclude-type=&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息；--help：显示帮助；--version：显示版本信息。 示例查看系统磁盘设备，默认是KB为单位1$ df 结果显示： 字段说明：Filesystem: 文件系统1K-blocks: 1K-块Used: 已用Available: 可用Use%: 已用%Mounted on: 挂载点 使用-h选项以KB以上的单位来显示，可读性高1$ df -h 结果显示：]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>df</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Route命令]]></title>
    <url>%2Flinux%2Flinux-shell-route%2F</url>
    <content type="text"><![CDATA[简介route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。 在Linux系统中设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的ip地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 参数说明1234567-A：设置地址类型；-C：打印将Linux核心的路由缓存；-v：详细信息模式；-n：不执行DNS反向查找，直接显示数字形式的IP地址；-e：netstat格式显示路由表；-net：到一个网络的路由表；-host：到一个主机的路由表。 示例显示当前路由1$ route -n 结果显示： 字段说明： U Up表示此路由当前为启动状态。H Host，表示此网关为一主机。G Gateway，表示此网关为一路由器。R Reinstate Route，使用动态路由重新初始化的路由。D Dynamically,此路由是动态性地写入。M Modified，此路由是由路由守护程序或导向器动态修改。! 表示此路由当前为关闭状态。 添加网关/设置网关1$ route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0 屏蔽一条路由1$ route add -net 224.0.0.0 netmask 240.0.0.0 reject 删除路由记录12$ route del -net 224.0.0.0 netmask 240.0.0.0$ route del -net 224.0.0.0 netmask 240.0.0.0 reject 删除和添加设置默认网关12$ route del default gw 192.168.120.240$ route add default gw 192.168.120.240]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tail命令]]></title>
    <url>%2Flinux%2Flinux-shell-tail%2F</url>
    <content type="text"><![CDATA[简介tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。 注意：如果表示字节或行数的N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。 参数说明1234567891011--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；-c&lt;N&gt;或——bytes=&lt;N&gt;：输出文件尾部的N（N为整数）个字节内容；-f&lt;name/descriptor&gt;或；--follow&lt;nameldescript&gt;：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；-F：与选项“-follow=name”和“--retry"连用时功能相同；-n&lt;N&gt;或——line=&lt;N&gt;：输出文件的尾部N（N位数字）行内容。--pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；-s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数；-v或——verbose：当有多个文件参数时，总是输出各个文件名；--help：显示指令的帮助信息；--version：显示指令的版本信息。 示例显示文件末尾内容1$ tail -n 5 log2014.log 循环查看文件内容1$ tail -f test.log 从第5行开始显示文件1$ tail -n +5 log2014.log]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>tail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LN命令]]></title>
    <url>%2Flinux%2Flinux-shell-ln%2F</url>
    <content type="text"><![CDATA[简介ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用-s选项。 注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。 参数说明1234567891011-b: 删除，覆盖以前建立的链接-d: 允许超级用户制作目录的硬链接-f: 强制执行-i: 交互模式，文件存在则提示用户是否覆盖-n: 把符号链接视为一般目录-s: 软链接(符号链接)-v: 显示详细的处理过程-S: “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”-V: “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”--help: 显示帮助信息--version: 显示版本信息 示例建立一个符号链接 在目录/usr/liu下建立一个符号链接文件abc，使它指向目录/usr/mengqc/mub1 1$ ln -s /usr/mengqc/mub1 /usr/liu/abc 删除一个符号链接 将目录/usr/liu/下的abc链接删除，注意不是rm -rf symbolic_name/ 12$ cd /usr/liu/$ rm -rf symbolic_name]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>ln</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LS命令]]></title>
    <url>%2Flinux%2Flinux-shell-ls%2F</url>
    <content type="text"><![CDATA[简介ls命令用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。 参数说明12345678910111213141516171819202122-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；-A：显示除影藏文件“.”和“..”以外的所有文件列表；-C：多列显示输出结果。这是默认选项；-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；-F：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；--file-type：与“-F”选项的功能相同，但是不显示“*”；-k：以KB（千字节）为单位显示文件大小；-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；-m：用“,”号区隔每个文件和目录的名称；-n：以用户识别码和群组识别码替代其名称；-r：以文件名反序排列并输出目录内容列表；-s：显示文件和目录的大小，以区块为单位；-t：用文件和目录的更改时间排序；-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；-R：递归处理，将指定目录下的所有文件及子目录一并处理；--full-time：列出完整的日期与时间；--color[=WHEN]：使用不同的颜色高亮显示不同类型的。 示例使用长清单模式1$ ls -l 显示文件大小1$ ls -lh 排序文件大小1$ ls -lhS 测量大小1$ ls -l --block-size=M 显示隐藏文件1$ ls -a 只列出目录条目1$ ls -d */ 不打印所有者信息1$ ls -g 不打印组信息1$ ls -lG 打印UID和GID1$ ls -n 不带颜色打印1$ ls --color=never 打印每个文件的索引号1$ ls -li 增加 / (斜线) 标记目录1$ ls -p 排序时反转顺序1$ ls -r 递归列出子目录1$ ls -R 扩展名排序1$ ls -lX 通过修改时间列出1$ ls -lt 列出你的主目录1$ ls ~ 打印ls命令版本1$ ls --version]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP响应头和请求头信息对照表]]></title>
    <url>%2Fhttp%2Fhttp-header%2F</url>
    <content type="text"><![CDATA[简介HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。HTTP的头信息包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。 通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。 请求头标：允许客户端传递关于自身的信息和希望的响应形式。 响应头标：服务器和于传递自身信息的响应。 实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。 根据以上分类的HTTP请求头介绍可以参考此文，本工具根据请求和输出分为Request和Response两部分。 HTTP Request Header Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: gzip, deflate Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: keep-alive Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: admckid=1607301350151121825; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 c.xxx.com.cn If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.iqiyi.com/a_19rrhahmi9.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent 内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning HTTP Responses Header Header 解释 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: max-age=31536000 Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: application/octet-stream Date 原始服务器消息发出的时间 Mon, 15 Aug 2016 02:43:15 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Tue, 15 Aug 2017 02:42:58 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Fri, 29 Jul 2016 16:26:41 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.xxx.com/act/RdFHgKt4WyNYv27z.html P3P P3P提供的个人隐私保护策略 P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: http://www.xxx.com/ Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: nginx/7ed94dd662ffeb274371f6f0438ac6587fed8d84 Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME类型列表]]></title>
    <url>%2Fhttp%2Fhttp-mime%2F</url>
    <content type="text"><![CDATA[简介MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。官方的 MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的： RFC-822 Standard for ARPA Internet text messagesRFC-2045 MIME Part 1: Format of Internet Message BodiesRFC-2046 MIME Part 2: Media TypesRFC-2047 MIME Part 3: Header Extensions for Non-ASCII TextRFC-2048 MIME Part 4: Registration ProceduresRFC-2049 MIME Part 5: Conformance Criteria and Examples 不同的应用程序支持不同的 MIME 类型。下面的参考手册是由 Microsoft Internet Information Server version 5 所支持的 MIME 类型列表。 按照内容类型排列的 Mime 类型列表 类型/子类型 扩展名 application/envoy evy application/fractals fif application/futuresplash spl application/hta hta application/internet-property-stream acx application/mac-binhex40 hqx application/msword doc application/msword dot application/octet-stream * application/octet-stream bin application/octet-stream class application/octet-stream dms application/octet-stream exe application/octet-stream lha application/octet-stream lzh application/oda oda application/olescript axs application/pdf pdf application/pics-rules prf application/pkcs10 p10 application/pkix-crl crl application/postscript ai application/postscript eps application/postscript ps application/rtf rtf application/set-payment-initiation setpay application/set-registration-initiation setreg application/vnd.ms-excel xla application/vnd.ms-excel xlc application/vnd.ms-excel xlm application/vnd.ms-excel xls application/vnd.ms-excel xlt application/vnd.ms-excel xlw application/vnd.ms-outlook msg application/vnd.ms-pkicertstore sst application/vnd.ms-pkiseccat cat application/vnd.ms-pkistl stl application/vnd.ms-powerpoint pot application/vnd.ms-powerpoint pps application/vnd.ms-powerpoint ppt application/vnd.ms-project mpp application/vnd.ms-works wcm application/vnd.ms-works wdb application/vnd.ms-works wks application/vnd.ms-works wps application/winhlp hlp application/x-bcpio bcpio application/x-cdf cdf application/x-compress z application/x-compressed tgz application/x-cpio cpio application/x-csh csh application/x-director dcr application/x-director dir application/x-director dxr application/x-dvi dvi application/x-gtar gtar application/x-gzip gz application/x-hdf hdf application/x-internet-signup ins application/x-internet-signup isp application/x-iphone iii application/x-javascript js application/x-latex latex application/x-msaccess mdb application/x-mscardfile crd application/x-msclip clp application/x-msdownload dll application/x-msmediaview m13 application/x-msmediaview m14 application/x-msmediaview mvb application/x-msmetafile wmf application/x-msmoney mny application/x-mspublisher pub application/x-msschedule scd application/x-msterminal trm application/x-mswrite wri application/x-netcdf cdf application/x-netcdf nc application/x-perfmon pma application/x-perfmon pmc application/x-perfmon pml application/x-perfmon pmr application/x-perfmon pmw application/x-pkcs12 p12 application/x-pkcs12 pfx application/x-pkcs7-certificates p7b application/x-pkcs7-certificates spc application/x-pkcs7-certreqresp p7r application/x-pkcs7-mime p7c application/x-pkcs7-mime p7m application/x-pkcs7-signature p7s application/x-sh sh application/x-shar shar application/x-shockwave-flash swf application/x-stuffit sit application/x-sv4cpio sv4cpio application/x-sv4crc sv4crc application/x-tar tar application/x-tcl tcl application/x-tex tex application/x-texinfo texi application/x-texinfo texinfo application/x-troff roff application/x-troff t application/x-troff tr application/x-troff-man man application/x-troff-me me application/x-troff-ms ms application/x-ustar ustar application/x-wais-source src application/x-x509-ca-cert cer application/x-x509-ca-cert crt application/x-x509-ca-cert der application/ynd.ms-pkipko pko application/zip zip audio/basic au audio/basic snd audio/mid mid audio/mid rmi audio/mpeg mp3 audio/x-aiff aif audio/x-aiff aifc audio/x-aiff aiff audio/x-mpegurl m3u audio/x-pn-realaudio ra audio/x-pn-realaudio ram audio/x-wav wav image/bmp bmp image/cis-cod cod image/gif gif image/ief ief image/jpeg jpe image/jpeg jpeg image/jpeg jpg image/pipeg jfif image/svg+xml svg image/tiff tif image/tiff tiff image/x-cmu-raster ras image/x-cmx cmx image/x-icon ico image/x-portable-anymap pnm image/x-portable-bitmap pbm image/x-portable-graymap pgm image/x-portable-pixmap ppm image/x-rgb rgb image/x-xbitmap xbm image/x-xpixmap xpm image/x-xwindowdump xwd message/rfc822 mht message/rfc822 mhtml message/rfc822 nws text/css css text/h323 323 text/html htm text/html html text/html stm text/iuls uls text/plain bas text/plain c text/plain h text/plain txt text/richtext rtx text/scriptlet sct text/tab-separated-values tsv text/webviewhtml htt text/x-component htc text/x-setext etx text/x-vcard vcf video/mpeg mp2 video/mpeg mpa video/mpeg mpe video/mpeg mpeg video/mpeg mpg video/mpeg mpv2 video/quicktime mov video/quicktime qt video/x-la-asf lsf video/x-la-asf lsx video/x-ms-asf asf video/x-ms-asf asr video/x-ms-asf asx video/x-msvideo avi video/x-sgi-movie movie x-world/x-vrml flr x-world/x-vrml vrml x-world/x-vrml wrl x-world/x-vrml wrz x-world/x-vrml xaf x-world/x-vrml xof]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS命令]]></title>
    <url>%2Flinux%2Flinux-shell-ps%2F</url>
    <content type="text"><![CDATA[简介要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程,而ps命令就是最基本同时也是非常强大的进程查看命令.使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到的. 参数说明12345678-a：显示现行终端机下的所有进程，包括其他用户的进程-A：所有的进程均显示出来，与 -e 具有同样的效用-u：以用户为主的进程状态-f：做一个更为完整的输出-e：等于“-A”x： 通常与 a 这个参数一起使用，可列出较完整信息l： 较长、较详细的将该 PID 的的信息列出j： 工作的格式 (jobs format) PS L字段说明 F ：代表这个程序的旗标 (flag)， 4 代表使用者为 super userS ：代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍UID ：程序被该 UID 所拥有PID ：就是这个程序的 ID ！PPID ：则是其上级父程序的IDC ：CPU 使用的资源百分比PRI ：这个是 Priority (优先执行序) 的缩写，详细后面介绍NI ：这个是 Nice 值，在下一小节我们会持续介绍ADDR ：这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“SZ ：使用掉的内存大小WCHAN ：目前这个程序是否正在运作当中，若为 - 表示正在运作TTY ：登入者的终端机位置TIME ：使用掉的 CPU 时间。CMD ：所下达的指令为何 PS AUX字段说明 USER：该进程属于那个使用者账号的？PID ：该进程的进程ID号。%CPU：该进程使用掉的 CPU 资源百分比；%MEM：该进程所占用的物理内存百分比；VSZ ：该进程使用掉的虚拟内存量 (Kbytes)RSS ：该进程占用的固定的内存量 (Kbytes)TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。START：该进程被触发启动的时间；TIME ：该进程实际使用 CPU 运作的时间。COMMAND：该程序的实际指令为什么？ STAT：该程序目前的状态，主要的状态有： R ：该程序目前正在运作，或者是可被运作； S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号(signal) 唤醒。 T ：该程序目前正在侦测或者是停止了； Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态 示例显示所有进程信息1$ ps -A 显示指定用户信息1$ ps -u root 显示所有进程信息，连同命令行1$ ps -ef ps 与grep 常用组合用法，查找特定进程1$ ps -ef|grep ssh 列出类似程序树的程序显示1$ ps -axjf 找出与 cron 与 syslog 这两个服务有关的 PID 号码1$ ps aux | egrep '(cron|syslog)']]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WGET命令]]></title>
    <url>%2Flinux%2Flinux-shell-wget%2F</url>
    <content type="text"><![CDATA[简介wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 参数说明12345678910111213141516171819202122-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；-b：进行后台的方式运行wget；-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；-c：继续执行上次终端的任务；-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；-d：调试模式运行指令；-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；-h：显示指令帮助信息；-i&lt;文件&gt;：从指定文件获取要下载的URL地址；-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；-L：仅顺着关联的连接；-r：递归下载方式；-nc：文件存在时，下载文件不覆盖原有文件；-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；-q：不显示指令执行过程；-nh：不查询主机名称；-v：显示详细执行过程；-V：显示版本信息；--passive-ftp：使用被动模式PASV连接FTP服务器；--follow-ftp：从HTML文件中下载FTP连接文件。 示例下载单个文件 以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。 1$ wget http://www.xxx.net/xxx.zip 下载并以不同的文件名保存 wget默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确。 1$ wget -O wordpress.zip http://www.xxx.net/xxx.aspx?id=1080 wget限速下载 当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。 1$ wget --limit-rate=300k http://www.xxx.net/testfile.zip 使用wget断点续传 使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 1$ wget -c http://www.xxx.net/testfile.zip 使用wget后台下载1$ wget -b http://www.xxx.net/testfile.zip 伪装代理名称下载1$ wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.xxx.net/testfile.zip 测试下载链接 当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 1$ wget --spider URL 增加重试次数 如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。 1$ wget --tries=40 URL 下载多个文件 首先，保存一份下载链接文件：cat &gt; filelist.txturl1url2url3url4接着使用这个文件和参数-i下载。 1$ wget -i filelist.txt 镜像网站 下载整个网站到本地。–miror开户镜像下载。-p下载所有为了html页面显示正常的文件。–convert-links下载后，转换成本地的链接。-P ./LOCAL保存所有文件和目录到本地指定目录。 1$ wget --mirror -p --convert-links -P ./LOCAL URL 过滤指定格式下载 下载一个网站，但你不希望下载图片，可以使用这条命令。 1$ wget --reject=gif ur 把下载信息存入日志文件 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 1$ wget -o download.log URL 限制总下载文件大小 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 1$ wget -Q5m -i filelist.txt 下载指定格式文件 可以在以下情况使用该功能：下载一个网站的所有图片。下载一个网站的所有视频。下载一个网站的所有PDF文件。 1$ wget -r -A.pdf url FTP下载12$ wget ftp-url$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url Https下载1$ wget -r -np -nd --accept=gz --no-check-certificate https://www.xxx.com/dir/ --http-user=username --http-password=password]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>wget</tag>
      </tags>
  </entry>
</search>
